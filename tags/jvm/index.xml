<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JVM on pipo&#39;s site</title>
    <link>https://asgpipo.github.io/tags/jvm/</link>
    <description>Recent content in JVM on pipo&#39;s site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 13 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://asgpipo.github.io/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JMM</title>
      <link>https://asgpipo.github.io/posts/java/concurrency/jmm/</link>
      <pubDate>Mon, 13 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/java/concurrency/jmm/</guid>
      <description>&lt;h1 id=&#34;jmm&#34;&gt;JMM&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是-jmm&#34;&gt;&lt;strong&gt;1. 什么是 JMM？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Java 内存模型（JMM）是一个&lt;strong&gt;抽象模型&lt;/strong&gt;，它定义了线程和主内存之间的抽象关系。JMM 的核心目的是&lt;strong&gt;屏蔽各种硬件和操作系统的内存访问差异&lt;/strong&gt;，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果，为开发者提供清晰的并发编程保证。
&lt;img src=&#34;https://asgpipo.github.io/pics/Java/JMM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-jmm-的核心抽象&#34;&gt;&lt;strong&gt;2. JMM 的核心抽象&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;JMM 通过以下概念来抽象内存交互：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主内存&lt;/strong&gt;：所有线程共享的区域，存储了所有的实例字段、静态字段和构成数组对象的元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地内存&lt;/strong&gt;：每个线程私有的区域，是 JMM 的一个抽象概念。它存储了该线程对主内存变量的副本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通信原则&lt;/strong&gt;：线程间的通信必须通过主内存进行。一个线程将本地内存的变量副本写入主内存，另一个线程再从主内存读取到最新的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/JMMAbstract.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-jmm-诞生的原因&#34;&gt;&lt;strong&gt;3. JMM 诞生的原因&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;JMM 的出现主要是为了解决现代计算机体系结构带来的两个核心问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU 缓存导致的可见性问题&lt;/strong&gt;：为了提高速度，每个 CPU 都有自己的高速缓存。当多个线程运行在不同 CPU 上时，它们可能各自持有一个共享变量的缓存副本，导致一个线程的修改对另一个线程不可见。尽管硬件层面有缓存一致性协议（如 MESI）来协调，但 JMM 提供了更高层、更强的可见性保证。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指令重排导致的有序性问题&lt;/strong&gt;：为了优化性能，编译器和处理器可能会对输入的代码进行指令重排序。在单线程环境下，重排序不会影响最终结果，但在多线程环境下，可能会破坏代码原有的执行逻辑，导致意想不到的结果。
&lt;img src=&#34;https://asgpipo.github.io/pics/Java/HowJMMBrith.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-jmm-的核心工具happens-before-原则&#34;&gt;&lt;strong&gt;4. JMM 的核心工具：Happens-Before 原则&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;happens-before&lt;/code&gt; 是 JMM 中最核心的概念，它定义了两个操作之间的偏序关系。如果操作 A &lt;code&gt;happens-before&lt;/code&gt; 操作 B，那么 A 操作的执行结果对 B 操作是可见的，且 A 操作的执行顺序在 B 操作之前。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：&lt;code&gt;happens-before&lt;/code&gt; 原则主要用于保证并发环境下的&lt;strong&gt;可见性&lt;/strong&gt;和&lt;strong&gt;有序性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;程序顺序规则&lt;/strong&gt;：在一个线程内，书写在前面的代码操作 &lt;code&gt;happens-before&lt;/code&gt; 书写在后面的代码操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监视器锁规则&lt;/strong&gt;：对一个锁的解锁操作 &lt;code&gt;happens-before&lt;/code&gt; 后续对同一个锁的加锁操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile 变量规则&lt;/strong&gt;：对一个 &lt;code&gt;volatile&lt;/code&gt; 变量的写操作 &lt;code&gt;happens-before&lt;/code&gt; 后续对该变量的读操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传递性&lt;/strong&gt;：如果 A &lt;code&gt;happens-before&lt;/code&gt; B，且 B &lt;code&gt;happens-before&lt;/code&gt; C，那么 A &lt;code&gt;happens-before&lt;/code&gt; C。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程启动规则&lt;/strong&gt;：线程的 &lt;code&gt;start()&lt;/code&gt; 方法 &lt;code&gt;happens-before&lt;/code&gt; 于此线程的每一个动作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程终止规则&lt;/strong&gt;：线程中的所有操作都 &lt;code&gt;happens-before&lt;/code&gt; 对此线程的终止检测。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程中断规则&lt;/strong&gt;：对线程 &lt;code&gt;interrupt()&lt;/code&gt; 方法的调用 &lt;code&gt;happens-before&lt;/code&gt; 发生于被中断线程的代码检测到中断时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象终结规则&lt;/strong&gt;：一个对象的初始化完成（构造函数执行结束）&lt;code&gt;happens-before&lt;/code&gt; 它的 &lt;code&gt;finalize()&lt;/code&gt; 方法的开始。
&lt;img src=&#34;https://asgpipo.github.io/pics/Java/HappensBefore.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;JMM 通过抽象出主内存和本地内存，并提供一套 &lt;code&gt;happens-before&lt;/code&gt; 规则，成功地为 Java 开发者屏蔽了底层硬件的复杂性。理解 JMM 有助于我们编写出正确、可靠的并发程序，避免可见性和有序性带来的问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>volatile &amp; synchronized</title>
      <link>https://asgpipo.github.io/posts/java/concurrency/volatile--synchronized/</link>
      <pubDate>Mon, 13 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/java/concurrency/volatile--synchronized/</guid>
      <description>&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 关键字是 Java 并发编程中的一个基础且至关重要的概念。它就像是 Java 虚拟机 ([[JVM]]) 和底层硬件之间立下的一份“契约”，专门用于解决多线程环境下&lt;strong&gt;共享变量的可见性（Visibility）和有序性（Ordering）问题&lt;/strong&gt;。
&lt;img src=&#34;https://asgpipo.github.io/pics/Java/VolatileMindMap.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一-volatile-的含义及在-java-中的作用&#34;&gt;一、 &lt;code&gt;volatile&lt;/code&gt; 的含义及在 Java 中的作用&lt;/h2&gt;
&lt;h3 id=&#34;1-单词的意思literal-meaning&#34;&gt;1. 单词的意思（Literal Meaning）&lt;/h3&gt;
&lt;p&gt;在 Java 中，&lt;code&gt;volatile&lt;/code&gt; 关键字用来标记一个 Java 变量是 &amp;ldquo;&lt;strong&gt;存储在主内存中&lt;/strong&gt;&amp;quot;（&amp;ldquo;being stored in main memory&amp;rdquo;）的。它指示 JVM，这个变量是&lt;strong&gt;共享且不稳定的&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2-它在-java-中干什么核心机制&#34;&gt;2. 它在 Java 中干什么（核心机制）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 的核心作用是&lt;strong&gt;强制读写操作直接与主内存进行交互&lt;/strong&gt;，从而解决了由于 CPU 缓存和指令重排序带来的并发问题。&lt;/p&gt;
&lt;h4 id=&#34;a-解决可见性问题强制内存访问&#34;&gt;A. 解决可见性问题（强制内存访问）&lt;/h4&gt;
&lt;p&gt;由于现代 CPU 为了性能，会将变量副本存储在 CPU 寄存器或缓存中。如果变量未被声明为 &lt;code&gt;volatile&lt;/code&gt;，线程在操作共享变量时，对主内存的读写时间是不确定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读取操作：&lt;/strong&gt; 对 &lt;code&gt;volatile&lt;/code&gt; 变量的每一次读取都将直接从计算机的&lt;strong&gt;主内存&lt;/strong&gt;中读取，而不是从 CPU 寄存器中读取。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写入操作：&lt;/strong&gt; 对 &lt;code&gt;volatile&lt;/code&gt; 变量的每一次写入都将立即被&lt;strong&gt;写入到主内存&lt;/strong&gt;中，而不仅仅是写入到 CPU 寄存器或写缓冲区中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这种方式，&lt;code&gt;volatile&lt;/code&gt; 确保了当一个线程更新变量值时，处理器会立即&lt;strong&gt;刷新&lt;/strong&gt;这些更新，保证其他线程随后读取时能看到这个最新值。&lt;/p&gt;
&lt;h4 id=&#34;b-解决有序性问题禁止指令重排序&#34;&gt;B. 解决有序性问题（禁止指令重排序）&lt;/h4&gt;
&lt;p&gt;编译器、运行时环境或处理器可能会对指令进行重排序以优化性能。&lt;code&gt;volatile&lt;/code&gt; 变量是与运行时和处理器进行通信，以&lt;strong&gt;避免重排序任何涉及该 &lt;code&gt;volatile&lt;/code&gt; 变量的指令&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它通过插入&lt;strong&gt;内存屏障 (Memory Barrier)&lt;/strong&gt; 来实现这一目标。内存屏障就像一道墙，禁止某些类型的处理器重排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-volatile-保证了什么核心承诺&#34;&gt;二、 &lt;code&gt;volatile&lt;/code&gt; 保证了什么？（核心承诺）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 关键字提供了 Java 内存模型 ([[Java/Concurrency/JMM|JMM]]) 规定的两大核心保证：&lt;/p&gt;
&lt;h3 id=&#34;1-内存可见性visibility-guarantee&#34;&gt;1. 内存可见性（Visibility Guarantee）&lt;/h3&gt;
&lt;p&gt;这是 &lt;code&gt;volatile&lt;/code&gt; 最主要也是最基础的保证。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一致性保证：&lt;/strong&gt; &lt;code&gt;volatile&lt;/code&gt; 保证了所有线程看到的共享变量的值是&lt;strong&gt;一致的&lt;/strong&gt;。当对 &lt;code&gt;volatile&lt;/code&gt; 字段进行更新后，&lt;strong&gt;该字段的共享值会立即更新&lt;/strong&gt;，其他线程不会获取到不一致的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完整可见性保证（Full Volatile Visibility Guarantee）：&lt;/strong&gt; &lt;code&gt;volatile&lt;/code&gt; 的可见性保证甚至延伸到了变量本身之外。
&lt;ul&gt;
&lt;li&gt;如果线程 A 写入一个 &lt;code&gt;volatile&lt;/code&gt; 变量，随后线程 B 读取了它，那么&lt;strong&gt;在 A 写入该 &lt;code&gt;volatile&lt;/code&gt; 变量之前对所有其他变量所做的更改，对 B 来说都是可见的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;类似地，当线程 A 读取 &lt;code&gt;volatile&lt;/code&gt; 变量时，所有对线程 A 可见的变量都会&lt;strong&gt;被强制重新从主内存读取&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-有序性与-happens-before-关系&#34;&gt;2. 有序性与 Happens-Before 关系&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 关键字提供了 Java 内存模型中的 &lt;strong&gt;Happens-Before 保证&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Volatile 变量规则：&lt;/strong&gt; 对一个 &lt;code&gt;volatile&lt;/code&gt; 变量的&lt;strong&gt;写操作 Happens-Before 后面对这个 &lt;code&gt;volatile&lt;/code&gt; 变量的读操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重排序约束：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写入屏障：&lt;/strong&gt; 发生在 &lt;code&gt;volatile&lt;/code&gt; 变量写入&lt;strong&gt;之前&lt;/strong&gt;对其他变量的读写，&lt;strong&gt;不能&lt;/strong&gt;被重排到 &lt;code&gt;volatile&lt;/code&gt; 写入&lt;strong&gt;之后&lt;/strong&gt;发生。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读取屏障：&lt;/strong&gt; 发生在 &lt;code&gt;volatile&lt;/code&gt; 变量读取&lt;strong&gt;之后&lt;/strong&gt;对其他变量的读写，&lt;strong&gt;不能&lt;/strong&gt;被重排到 &lt;code&gt;volatile&lt;/code&gt; 读取&lt;strong&gt;之前&lt;/strong&gt;发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-对-64-位值操作的原子性保障&#34;&gt;3. 对 64 位值操作的原子性保障&lt;/h3&gt;
&lt;p&gt;[[Java/Concurrency/JMM|JMM]] 对 64 位值（如 &lt;code&gt;long&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt;）的访问原子性有所放宽，因为在某些 32 位平台上，读写 64 位值可能需要两次内存事务，导致操作非原子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; 作为一种&lt;strong&gt;逃生出口（escape hatch）&lt;/strong&gt;，可以用来&lt;strong&gt;强制确保 64 位值的访问原子性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果代码可能在 32 位平台上运行，开发者必须使用 &lt;code&gt;volatile&lt;/code&gt; 关键字来保障 64 位操作的可移植性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-什么时候使用-volatile适用场景&#34;&gt;三、 什么时候使用 &lt;code&gt;volatile&lt;/code&gt;？（适用场景）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 是一个&lt;strong&gt;轻量级的同步机制&lt;/strong&gt;，适用于只需要保证可见性和有序性，但不需要互斥的场景。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;单写多读场景 (State Flag)&lt;/strong&gt;：当&lt;strong&gt;只有一个线程&lt;/strong&gt;会修改（写入）变量的值，而其他所有线程只负责读取该变量时，&lt;code&gt;volatile&lt;/code&gt; 是足够的。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 状态标志：只有一个线程会把它设为 true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isRunning&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;shutdown&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isRunning&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 单写操作&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;doWork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isRunning&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 多读操作&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ... 执行任务&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Server has been shut down.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;值不依赖于旧值：&lt;/strong&gt; 即使有多个线程写入 &lt;code&gt;volatile&lt;/code&gt; 变量，只要写入的新值&lt;strong&gt;不依赖于其旧值&lt;/strong&gt;（例如，设置一个布尔状态标记，而不是计数器递增），&lt;code&gt;volatile&lt;/code&gt; 也是足够的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替代重量级锁：&lt;/strong&gt; 当应用程序需要确保数据的可见性方面，但同时又希望避免 &lt;code&gt;synchronized&lt;/code&gt; 方法和块带来的性能开销时，&lt;code&gt;volatile&lt;/code&gt; 很有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ldquo;搭便车&amp;quot;技巧 (Piggybacking)&lt;/strong&gt;：利用 &lt;code&gt;volatile&lt;/code&gt; 带来的 happens-before 顺序性，将普通变量的写入放在 &lt;code&gt;volatile&lt;/code&gt; 变量写入之前，可以使普通变量的可见性“搭上” &lt;code&gt;volatile&lt;/code&gt; 变量的便车。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;四-什么时候不使用-volatile局限性与替代方案&#34;&gt;四、 什么时候不使用 &lt;code&gt;volatile&lt;/code&gt;？（局限性与替代方案）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 具有明显的局限性，在需要复杂同步时，不应单独依赖它。&lt;/p&gt;
&lt;h3 id=&#34;1-不能保证互斥性mutual-exclusion&#34;&gt;1. 不能保证互斥性（Mutual Exclusion）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; 字段的读写&lt;strong&gt;不会阻塞&lt;/strong&gt;其他线程的读写操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; 关键字&lt;strong&gt;不提供互斥（mutual exclusion）&lt;/strong&gt;，即它不能保证在任何时刻只有一个线程执行关键代码段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-无法保障复合操作的原子性&#34;&gt;2. 无法保障复合操作的原子性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一旦线程需要&lt;strong&gt;先读取 &lt;code&gt;volatile&lt;/code&gt; 变量的值，然后根据该值生成一个新的值&lt;/strong&gt;（即复合操作，如 &lt;code&gt;i++&lt;/code&gt; 或 &lt;code&gt;count = count + 1&lt;/code&gt;），&lt;strong&gt;单独的 &lt;code&gt;volatile&lt;/code&gt; 就不够了&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在读取和写入新值之间的短暂时间差内，会产生&lt;strong&gt;竞态条件（race condition）&lt;/strong&gt;，多个线程可能读取到相同的值，导致相互覆盖，最终结果错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替代方案：&lt;/strong&gt; 在这种需要&lt;strong&gt;原子性&lt;/strong&gt;（读取和写入是一个不可分割操作）的情况下，必须使用：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;synchronized&lt;/code&gt; 块或方法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt; 包中的各种&lt;strong&gt;原子数据类型&lt;/strong&gt;，如 &lt;code&gt;AtomicLong&lt;/code&gt; 或 &lt;code&gt;AtomicReference&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-性能考量&#34;&gt;3. 性能考量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;访问 &lt;code&gt;volatile&lt;/code&gt; 变量会将其读写到主内存，这比访问 CPU 寄存器&lt;strong&gt;更昂贵&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; 还会阻止指令重排序，而指令重排序是&lt;strong&gt;常见的性能增强技术&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;因此，应该&lt;strong&gt;只在真正需要强制变量可见性时&lt;/strong&gt;才使用 &lt;code&gt;volatile&lt;/code&gt; 变量，以避免不必要的同步开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;UnsafeCounter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 即使使用了 volatile，也无法保证正确性&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;increment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 这不是原子操作！它包含三步：&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 1. 读取 count 的值&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 2. 将值加 1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 3. 写入新值&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;特性&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;code&gt;volatile&lt;/code&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;code&gt;synchronized&lt;/code&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;code&gt;AtomicInteger&lt;/code&gt; (原子类)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证可见性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证有序性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (禁止重排序)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证原子性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt; (仅限单次读/写)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (代码块)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (特定操作)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;互斥/阻塞&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt; (非阻塞)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (阻塞)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt; (非阻塞，CAS)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;性能开销&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较低&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较高&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较低 (通常优于 &lt;code&gt;volatile&lt;/code&gt;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;状态标志、单写多读&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;复杂同步逻辑、临界区保护&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计数器、累加等复合操作&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 关键字是 Java 并发编程的基石，它提供了一种强大而直接的同步机制。它就像是为一间“共享资源室”配备的“唯一钥匙”&lt;strong&gt;，专门用于解决多线程环境下的&lt;/strong&gt;原子性、可见性和有序性&lt;strong&gt;问题，其核心是&lt;/strong&gt;互斥访问。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一-synchronized-的含义及在-java-中的作用&#34;&gt;一、 &lt;code&gt;synchronized&lt;/code&gt; 的含义及在 Java 中的作用&lt;/h2&gt;
&lt;h3 id=&#34;1-意思&#34;&gt;1. 意思&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 的字面意思是“同步的”。在 Java 中，它用于确保一段代码或一个方法在同一时刻&lt;strong&gt;最多只有一个线程&lt;/strong&gt;能执行它。&lt;/p&gt;
&lt;h3 id=&#34;2-它在-java-中干什么核心机制-1&#34;&gt;2. 它在 Java 中干什么（核心机制）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 的核心作用是实现&lt;strong&gt;线程间的互斥&lt;/strong&gt;，它通过一个叫做&lt;strong&gt;监视器锁&lt;/strong&gt; 的东西来实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监视器锁&lt;/strong&gt;：每个 Java 对象都可以作为一个锁，这个锁就是对象的内置锁或监视器锁。当线程试图进入一个被 &lt;code&gt;synchronized&lt;/code&gt; 保护的代码块时，它必须先获取该代码块所关联对象的锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;锁的获取与释放&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;获取锁&lt;/strong&gt;：如果锁未被其他线程持有，当前线程会获取锁并进入代码块执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞等待&lt;/strong&gt;：如果锁已被其他线程持有，当前线程将被&lt;strong&gt;阻塞&lt;/strong&gt;，并进入锁的等待队列，直到锁被释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;释放锁&lt;/strong&gt;：当线程执行完 &lt;code&gt;synchronized&lt;/code&gt; 代码块或方法，或者在代码块中抛出异常时，锁会自动被释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-synchronized-保证了什么核心承诺&#34;&gt;二、 &lt;code&gt;synchronized&lt;/code&gt; 保证了什么？（核心承诺）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 关键字提供了三大核心保证，比 &lt;code&gt;volatile&lt;/code&gt; 更为强大。&lt;/p&gt;
&lt;h3 id=&#34;1-原子性&#34;&gt;1. 原子性&lt;/h3&gt;
&lt;p&gt;这是 &lt;code&gt;synchronized&lt;/code&gt; 最核心的保证。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥执行&lt;/strong&gt;：&lt;code&gt;synchronized&lt;/code&gt; 确保被它保护的代码块（临界区）是&lt;strong&gt;原子的&lt;/strong&gt;。一个线程一旦进入该代码块，在它退出之前，其他任何线程都无法进入。这从根本上杜绝了竞态条件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类比&lt;/strong&gt;：就像一个只有一把钥匙的洗手间。一个人进去后锁上门（获取锁），在里面无论待多久，外面的人都只能排队等待（阻塞）。直到他出来并交出钥匙（释放锁），下一个人才能进去。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-内存可见性&#34;&gt;2. 内存可见性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 保证可见性，&lt;code&gt;synchronized&lt;/code&gt; 同样保证，而且更强。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Happens-Before 保证&lt;/strong&gt;：[[Java/Concurrency/JMM|JMM]] 规定，对一个锁的&lt;strong&gt;解锁操作 [[Java/Concurrency/JMM#^444be5|Happens-Before]] 后面对同一个锁的加锁操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强制刷新&lt;/strong&gt;：这意味着，当线程 A 释放锁时，[[Java/Concurrency/JMM|JMM]] 会强制将该线程工作内存中的所有共享变量的最新值&lt;strong&gt;刷新到主内存&lt;/strong&gt;。而当线程 B 随后获取同一个锁时，[[Java/Concurrency/JMM|JMM]] 会强制将该线程的工作内存置为无效，使其必须&lt;strong&gt;从主内存中重新读取&lt;/strong&gt;所有共享变量的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效果&lt;/strong&gt;：这确保了前一个线程对共享变量的修改，对后一个获取锁的线程是立即可见的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-有序性&#34;&gt;3. 有序性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 通过内存屏障禁止指令重排，&lt;code&gt;synchronized&lt;/code&gt; 通过其“原子性”隐式地保证了有序性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;隐式保证&lt;/strong&gt;：由于 &lt;code&gt;synchronized&lt;/code&gt; 块内的代码与块外的代码是互斥执行的，一个线程在 &lt;code&gt;synchronized&lt;/code&gt; 块内观察到的状态，一定是另一个线程在之前或之后同步块内操作的结果。[[Java/Concurrency/JMM|JMM]] 可以在保证最终结果正确性的前提下，对 &lt;code&gt;synchronized&lt;/code&gt; 块内的代码进行重排序，但它绝不会允许块内的代码“[[Runtime Data Area#Escape|逃逸]]”到块外，从而破坏整体的同步语义。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-可重入性&#34;&gt;4. 可重入性&lt;/h3&gt;
&lt;p&gt;这是 &lt;code&gt;synchronized&lt;/code&gt; 一个非常重要的特性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：一个已经获取到锁的线程，可以&lt;strong&gt;再次进入&lt;/strong&gt;由它自己持有的锁所保护的任何代码块，而不会造成死锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;机制&lt;/strong&gt;：JVM 会为每个锁关联一个持有计数器和一个持有线程。当一个线程获取锁时，计数器加一。当同一线程再次获取时，计数器再次加一。当线程退出同步块时，计数器减一。直到计数器为 0 时，锁才被真正释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;意义&lt;/strong&gt;：可重入性极大地简化了代码编写，避免了因在同步方法中调用另一个同步方法而导致的自我死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-什么时候使用-synchronized适用场景&#34;&gt;三、 什么时候使用 &lt;code&gt;synchronized&lt;/code&gt;？（适用场景）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 是一个重量级的同步工具，适用于需要强一致性保证的场景。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;保护临界区&lt;/strong&gt;：当多个线程需要访问和修改&lt;strong&gt;共享资源&lt;/strong&gt;（如共享的数据结构、文件、设备等）时，必须使用 &lt;code&gt;synchronized&lt;/code&gt; 来保护访问这些资源的代码块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保证复合操作的原子性&lt;/strong&gt;：对于像 &lt;code&gt;check-then-act&lt;/code&gt;（检查再操作，如单例模式的懒加载）或 &lt;code&gt;read-modify-write&lt;/code&gt;（读取再修改，如 &lt;code&gt;i++&lt;/code&gt;）这样的复合操作，&lt;code&gt;volatile&lt;/code&gt; 无能为力，&lt;code&gt;synchronized&lt;/code&gt; 是最直接的解决方案。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现简单的线程安全类&lt;/strong&gt;：在创建自定义的线程安全容器或工具类时，&lt;code&gt;synchronized&lt;/code&gt; 是最基础、最可靠的实现手段。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;三种使用方式&#34;&gt;&lt;strong&gt;三种使用方式&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MySynchronizedClass&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 1. 修饰实例方法，锁是当前实例对象 (this)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;instanceMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 临界区代码&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Instance method. Lock on: &amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 2. 修饰静态方法，锁是当前类的 Class 对象 (MySynchronizedClass.class)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;staticMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 临界区代码&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Static method. Lock on: &amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MySynchronizedClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lockObject&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 专用锁对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;blockMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 3. 修饰代码块，锁是指定的对象 (lockObject)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lockObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 临界区代码&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Code block. Lock on: &amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lockObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;四-什么时候不使用-synchronized局限性与替代方案&#34;&gt;四、 什么时候不使用 &lt;code&gt;synchronized&lt;/code&gt;？（局限性与替代方案）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 虽然强大，但其“重量级”的特性也带来了局限。&lt;/p&gt;
&lt;h3 id=&#34;1-性能开销&#34;&gt;1. 性能开销&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程阻塞与上下文切换&lt;/strong&gt;：当锁竞争激烈时，无法获取锁的线程会被阻塞，涉及从用户态到内核态的切换，这是一个&lt;strong&gt;非常昂贵的操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能瓶颈&lt;/strong&gt;：在高并发场景下，&lt;code&gt;synchronized&lt;/code&gt; 容易成为系统的性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-灵活性不足&#34;&gt;2. 灵活性不足&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不可中断&lt;/strong&gt;：一个线程在等待获取 &lt;code&gt;synchronized&lt;/code&gt; 锁时，不能被中断。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无法设置超时&lt;/strong&gt;：无法设置一个线程等待锁的最长时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非公平锁&lt;/strong&gt;：&lt;code&gt;synchronized&lt;/code&gt; 是非公平的，即等待时间长的线程不一定能优先获取锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-替代方案&#34;&gt;3. 替代方案&lt;/h3&gt;
&lt;p&gt;为了克服 &lt;code&gt;synchronized&lt;/code&gt; 的局限性，Java 提供了更灵活、更高效的并发工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;volatile&lt;/code&gt;&lt;/strong&gt;：当只需要保证可见性和有序性，而不需要互斥访问时，&lt;code&gt;volatile&lt;/code&gt; 是更轻量级的选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 包&lt;/strong&gt;：对于单个变量的原子性复合操作（如计数器），&lt;code&gt;AtomicInteger&lt;/code&gt; 等原子类基于 CAS（Compare-And-Swap）操作，通常比 &lt;code&gt;synchronized&lt;/code&gt; 性能更好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt; 接口&lt;/strong&gt;：提供了更高级的锁功能，如可中断的锁获取（&lt;code&gt;lockInterruptibly()&lt;/code&gt;）、可超时的锁获取（&lt;code&gt;tryLock()&lt;/code&gt;）和公平锁（&lt;code&gt;ReentrantLock&lt;/code&gt; 的构造函数参数）。它为复杂并发场景提供了更精细的控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;核心要点总结一图流&#34;&gt;&lt;strong&gt;核心要点总结（一图流）&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;特性&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;code&gt;synchronized&lt;/code&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证原子性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证可见性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证有序性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;互斥/阻塞&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (阻塞)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (阻塞)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可重入&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (如 &lt;code&gt;ReentrantLock&lt;/code&gt;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可中断&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (&lt;code&gt;lockInterruptibly()&lt;/code&gt;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可超时&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (&lt;code&gt;tryLock()&lt;/code&gt;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;公平性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt; (仅非公平)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (可选公平/非公平)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;使用方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;关键字 (JVM 实现，自动释放)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;接口 (API 调用，需手动 &lt;code&gt;unlock()&lt;/code&gt;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;性能开销&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较高 (JDK 6 后大幅优化)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;通常较低，但依赖具体实现&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>乐观锁 &amp; 悲观锁</title>
      <link>https://asgpipo.github.io/posts/java/concurrency/%E4%B9%90%E8%A7%82%E9%94%81--%E6%82%B2%E8%A7%82%E9%94%81/</link>
      <pubDate>Sun, 12 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/java/concurrency/%E4%B9%90%E8%A7%82%E9%94%81--%E6%82%B2%E8%A7%82%E9%94%81/</guid>
      <description>&lt;h1 id=&#34;悲观锁&#34;&gt;悲观锁&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/PessimisticLock.png&#34; alt=&#34;&#34;&gt;
悲观锁的核心思想是&lt;strong&gt;在共享资源被操作时假设冲突一定会发生&lt;/strong&gt;全部都加锁.&lt;/p&gt;
&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;synchronized&lt;/strong&gt; : Java 中的关键字，可以修饰方法或代码块，保证同一时刻只有一个线程可以执行被修饰的代码。&lt;/li&gt;
&lt;li&gt;ReentrantLock: Java &lt;code&gt;java.util.concurrent.locks&lt;/code&gt; 包下的一个类，提供了比 &lt;code&gt;synchronized&lt;/code&gt; 更广泛的锁操作。例如，它可以实现公平锁、非公平锁，可以被中断地获取锁等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缺点&#34;&gt;缺点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;多个线程在持有锁并请求对方已持有的锁时，会造成相互等待，导致所有线程都无法继续执行。&lt;/li&gt;
&lt;li&gt;当一个线程获取锁失败后，会被阻塞（挂起），操作系统需要将其从运行态切换到等待态。当锁被释放时，又需要将等待的线程唤醒，这个线程上下文的切换会消耗一定的 CPU 资源。&lt;/li&gt;
&lt;li&gt;只要有一个线程持有了锁，其他所有想要访问该资源的线程都必须等待，这会降低系统的并发性能和吞吐量。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;适用场景&#34;&gt;适用场景&lt;/h2&gt;
&lt;p&gt;适合写多读少的情况,因为读操作并不对资源进行修改不会出现线程问题,而写操作要求强数值一致性所以适合悲观锁.&lt;/p&gt;
&lt;h1 id=&#34;乐观锁&#34;&gt;乐观锁&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;pics/Java/OptimisticLock.png&#34; alt=&#34;&#34;&gt;
它总是假设最好的情况，认为数据在被自己操作时不会被其他线程修改。所以它不会加锁，&lt;strong&gt;而是在更新数据时，去检查&lt;/strong&gt;在此期间有没有其他线程修改过数据。&lt;/p&gt;
&lt;h2 id=&#34;实现方式-1&#34;&gt;实现方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;concurrent.atomic&lt;/code&gt;&lt;/strong&gt;: Java 的 &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 包下的一系列原子类，如 &lt;code&gt;AtomicInteger&lt;/code&gt;, &lt;code&gt;AtomicLong&lt;/code&gt; 等。它们内部使用了 CAS 机制来实现原子操作。&lt;/p&gt;
&lt;h2 id=&#34;机制&#34;&gt;机制&lt;/h2&gt;
&lt;h3 id=&#34;版本控制&#34;&gt;版本控制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/VersionControl.png&#34; alt=&#34;&#34;&gt;
在数据库中加入版本属性,当线程操作时需要携带当前操作数据的版本号,操作完成后比较此时版本与数据库中版本是否相同.&lt;/p&gt;
&lt;h3 id=&#34;cascompare-and-swap&#34;&gt;CAS(&lt;strong&gt;Compare And Swap&lt;/strong&gt;)&lt;/h3&gt;
&lt;p&gt;CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原子操作&lt;/strong&gt; 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;CAS 涉及到三个操作数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;V&lt;/strong&gt;：要更新的变量值(Var)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E&lt;/strong&gt;：预期值(Expected)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;N&lt;/strong&gt;：拟写入的新值(New)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。&lt;/p&gt;
&lt;h1 id=&#34;来源&#34;&gt;来源&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://javaguide.cn/java/concurrent/optimistic-lock-and-pessimistic-lock.html&#34;&gt;Javaguide# 乐观锁和悲观锁详解&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GC 垃圾回收</title>
      <link>https://asgpipo.github.io/posts/java/jvm/gcgarbage-collectors/</link>
      <pubDate>Sat, 27 Sep 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/java/jvm/gcgarbage-collectors/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;GC（Garbage Collection）是&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt;&lt;a href=&#34;https://www.yuque.com/xkfpipv/hwbfiy/diw7o8r28acyynrt&#34;&gt;&lt;!-- raw HTML omitted --&gt;JVM&lt;!-- raw HTML omitted --&gt;&lt;/a&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt; 中实现自动内存管理的一类机制的统称&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;，其&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;具体实现包括 Parallel、G1、ZGC&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt; 等垃圾回收器。&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;GC 主要作用于堆（Heap）内存&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;——在&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;新生代执行 Minor GC，在老年代触发 Major GC 或 Full GC&lt;!-- raw HTML omitted --&gt;****&lt;!-- raw HTML omitted --&gt;。虽然 GC 不直接管理直接内存，但会间接影响其回收（例如通过 GC 触发 Cleaner 释放 DirectByteBuffer）。在 JVM 架构中，GC 与运行时数据区（Runtime Data Area）、执行引擎（Execution Engine）、本地方法接口（Native Method Interface）等组件协同工作，共同支撑 Java 程序的运行。&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;什么是可被回收的如何判断&#34;&gt;什么是可被回收的,如何判断?&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;引用计数器&#34;&gt;引用计数器&lt;/h3&gt;
&lt;p&gt;通过一个计数器标记一个对象被引用的次数来判断是否进行垃圾回收,当引用数量为 0 时在垃圾回收时将会进行回收.&lt;/p&gt;
&lt;p&gt;问题: 出现循环引用时将导致无法释放内存.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如 A 引用 B,B 引用 A.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/cricleReference.jpeg&#34; alt=&#34;循环引用&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;可达性分析算法&#34;&gt;可达性分析算法&lt;/h3&gt;
&lt;p&gt;GC 会从一组“GC 根”（GCRoots）出发，沿着引用链一路向下找到所有可达对象。这些可达对象被认为是“存活”的，不会被回收。其他不可达的对象（被称为“可回收对象”）则有资格被回收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/GCRoots.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4&gt;&lt;/h4&gt;
&lt;h4 id=&#34;gc-roots&#34;&gt;GC Roots&lt;/h4&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;GC Roots 是一组在Java虚拟机中被直接&lt;!-- raw HTML omitted --&gt;引用&lt;!-- raw HTML omitted --&gt;的对象，是垃圾收集器从它们开始遍历所有可达对象（即存活对象）的起点&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;来源包括（但不限于）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈中的引用（局部变量、方法参数）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;localObj&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// localObj 是 GC Root&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;           &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// str 是 GC Root&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 这些变量在栈帧中，直接引用堆中的对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;param&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// param 是 GC Root，引用传入的对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;concat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 编译器可能生成临时变量引用中间结果&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Meta Space 中的静态 (static) 变量 和 常量引用对象&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MyClass&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;staticField&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 静态字段是 GC Root&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CONSTANT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;constant&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 静态常量也是 GC Root&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 即使没有 MyClass 的实例，staticField 仍然可达&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Constants&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 字符串常量池中的对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;literal&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// &amp;#34;literal&amp;#34; 对象被常量池引用，是 GC Root&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;created&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// &amp;#34;created&amp;#34; 也在常量池中&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;JNI 环境引用&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// C/C++ 本地代码&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JNIEXPORT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JNICALL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Java_MyClass_nativeMethod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JNIEnv&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jobject&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 通过 JNI 创建的全局引用或局部引用&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 这些引用的对象都是 GC Root&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;jobject&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;globalRef&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NewGlobalRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;someObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;HeapHprofBinWriter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AbstractHeapGraphWriter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// hprof binary file header&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HPROF_HEADER_1_0_2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;JAVA PROFILE 1.0.2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//    .....&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HPROF_GC_ROOT_UNKNOWN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0xFF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HPROF_GC_ROOT_JNI_GLOBAL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0x01&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HPROF_GC_ROOT_JNI_LOCAL&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0x02&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HPROF_GC_ROOT_JAVA_FRAME&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0x03&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HPROF_GC_ROOT_NATIVE_STACK&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0x04&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HPROF_GC_ROOT_STICKY_CLASS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0x05&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HPROF_GC_ROOT_THREAD_BLOCK&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0x06&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HPROF_GC_ROOT_MONITOR_USED&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0x07&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HPROF_GC_ROOT_THREAD_OBJ&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0x08&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//    .....&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;方法区回收或meta-space&#34;&gt;方法区回收(或Meta Space)&lt;/h3&gt;
&lt;h3 id=&#34;finalize&#34;&gt;&lt;!-- raw HTML omitted --&gt;finalize()&lt;!-- raw HTML omitted --&gt;&lt;/h3&gt;
&lt;h2 id=&#34;gc-主要作用范围&#34;&gt;GC 主要作用范围&lt;/h2&gt;
&lt;h3 id=&#34;heap&#34;&gt;Heap&lt;/h3&gt;
&lt;p&gt;堆内的垃圾收集算法主要基于分代收集法，根据对象的生命周期长短将内存分为年轻代和老年代，分别采用不同的收集策略，以提高垃圾收集的效率。&lt;/p&gt;
&lt;h3 id=&#34;部分-gc&#34;&gt;部分 GC&lt;/h3&gt;
&lt;p&gt;部分 GC (Partial GC) 是指不完整的垃圾收集，只针对堆的特定部分进行收集。主要包括 Young GC 和 Old GC。&lt;/p&gt;
&lt;h3 id=&#34;young-gc&#34;&gt;Young GC&lt;/h3&gt;
&lt;p&gt;仅作用于 Young generation 的垃圾收集，每次将可回收内存标记回收，存活内存移入 Survivor 区域。由于大多数对象的生命周期较短，Young GC 发生频繁但速度较快。&lt;/p&gt;
&lt;p&gt;Old GC (Major GC) 是指只针对老年代进行的垃圾收集。通常会导致应用程序暂停，但发生频率低于 Young GC。当老年代空间不足时触发。&lt;/p&gt;
&lt;h3 id=&#34;full-gc&#34;&gt;Full GC&lt;/h3&gt;
&lt;p&gt;Full GC 是对整个堆进行垃圾收集，包括年轻代、老年代和元空间（JDK 8 之前称为永久代）。Full GC 的暂停时间通常较长，会导致应用程序长时间停顿，影响用户体验。&lt;/p&gt;
&lt;p&gt;混合 GC (Mixed GC)&lt;/p&gt;
&lt;p&gt;G1 收集器特有的收集方式，既会收集年轻代也会收集部分老年代。G1 通过将堆分成多个区域（Region），每次收集时可以有选择地收集部分区域，减少停顿时间。&lt;/p&gt;
&lt;p&gt;MetaSpace&lt;/p&gt;
&lt;p&gt;MetaSpace 使用的是本地内存，不在 JVM 堆中。它主要用于存储类的元数据信息，如类结构、方法数据、常量池等。MetaSpace 的垃圾收集通常在 Full GC 时进行。&lt;/p&gt;
&lt;h2 id=&#34;引用类型&#34;&gt;&lt;!-- raw HTML omitted --&gt;引用类型&lt;!-- raw HTML omitted --&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;strongreference&#34;&gt;StrongReference&lt;/h3&gt;
&lt;p&gt;Java 中最常见最普通的引用方式，比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个 &lt;code&gt;foo&lt;/code&gt; 就是一个强引用。只要存在这样的强引用链路指向 &lt;code&gt;Foo&lt;/code&gt; 对象，GC 就不会回收它,即使发生 OOM,&lt;/p&gt;
&lt;p&gt;几乎所有日常编码用到的对象引用都是强引用。&lt;/p&gt;
&lt;h3 id=&#34;softreference&#34;&gt;SoftReference&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SoftReference&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sf&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SoftReference&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 使对象只被软引用关联&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果一个对象只有软引用可达（即没有强引用链路指向它），JVM 并不一定立刻回收它。只有在内存紧张、垃圾回收器判断“需要腾出空间”的时候，才可能清除这些对象。&lt;/p&gt;
&lt;p&gt;用途通常是缓存（cache）例如你希望保留一个对象作为缓存，但如果 JVM 内存紧张，希望它被垃圾回收掉，而不是导致 OOM。&lt;/p&gt;
&lt;h3 id=&#34;weakreference&#34;&gt;WeakReference&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WeakReference&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wf&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WeakReference&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果一个对象 &lt;strong&gt;仅&lt;/strong&gt; 被弱引用可达（即没有强引用或软引用链路指向它），那么在下一次垃圾回收时，GC 就可以回收它，不要保留。换言之，弱引用对象是最容易被回收的那类。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;PhantomReference&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;引用类型&lt;/th&gt;
          &lt;th&gt;可达性状态名称&lt;/th&gt;
          &lt;th&gt;是否阻止 GC&lt;/th&gt;
          &lt;th&gt;&lt;code&gt;get()&lt;/code&gt; 方法是否可得&lt;/th&gt;
          &lt;th&gt;被清除 / 入队列时机 / 特性&lt;/th&gt;
          &lt;th&gt;典型用途&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Strong (强引用)&lt;/td&gt;
          &lt;td&gt;“强可达”（strong reachable）&lt;/td&gt;
          &lt;td&gt;阻止 GC — 只要有强引用，GC 不会回收这个对象&lt;/td&gt;
          &lt;td&gt;—（不是通过 &lt;code&gt;Reference&lt;/code&gt; 对象访问的）&lt;/td&gt;
          &lt;td&gt;不会自动被 GC 清除&lt;/td&gt;
          &lt;td&gt;日常使用、常规引用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;SoftReference (软引用)&lt;/td&gt;
          &lt;td&gt;“软可达”（soft reachable）&lt;/td&gt;
          &lt;td&gt;不阻止 GC，但 GC 在内存紧张时可能清除&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;get()&lt;/code&gt; 返回对象，除非已被清除&lt;/td&gt;
          &lt;td&gt;在内存不足时（JVM 判断需要）可被回收；若注册了 ReferenceQueue，则被清除后其引用对象会入队&lt;/td&gt;
          &lt;td&gt;缓存 (cache)、内存敏感的数据保留&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;WeakReference (弱引用)&lt;/td&gt;
          &lt;td&gt;“弱可达”（weak reachable）&lt;/td&gt;
          &lt;td&gt;不阻止 GC — 一旦对象 &lt;strong&gt;只被弱引用&lt;/strong&gt; 可达，就将被回收&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;get()&lt;/code&gt; 若对象未被回收则返回，否则返回 null&lt;/td&gt;
          &lt;td&gt;在下一次垃圾回收（或更早）就可被回收；若注册队列，则在清除／回收时入队&lt;/td&gt;
          &lt;td&gt;WeakHashMap、 canonicalizing map、避免内存泄漏辅助结构&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;PhantomReference (虚引用，也称幻影引用)&lt;/td&gt;
          &lt;td&gt;“虚可达”（phantom reachable）&lt;/td&gt;
          &lt;td&gt;不阻止回收（比软弱还“弱”）&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;get()&lt;/code&gt; 总是返回 null（永远不可通过它获取对象）&lt;/td&gt;
          &lt;td&gt;当对象“几乎要被回收”时被入队列（通常是在对象 finalize/清理之后） — 但 GC 在回收对象之前，必须先将其 phantom 引用入队（让程序得知该对象将被回收）&lt;/td&gt;
          &lt;td&gt;用于跟踪对象被回收的时刻，做清理 (cleanup)、资源释放、内存调度等&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;referencequeue&#34;&gt;ReferenceQueue&lt;/h3&gt;
&lt;h2 id=&#34;垃圾回收算法&#34;&gt;&lt;!-- raw HTML omitted --&gt;垃圾回收算法&lt;!-- raw HTML omitted --&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/6844904117433794567#heading-5&#34;&gt;垃圾收集动图示例&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;标记-清除mark-sweep&#34;&gt;标记-清除（Mark-Sweep）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;核心思想：两阶段完成回收。先从 GC Roots 出发“标记”所有存活对象，再“清除”未标记对象以回收其占用的内存。&lt;/li&gt;
&lt;li&gt;典型流程：
&lt;ol&gt;
&lt;li&gt;Stop-The-World，遍历对象图进行可达性分析并标记存活对象&lt;/li&gt;
&lt;li&gt;扫描堆空间，释放未标记对象所占内存&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;优点：实现简单，无需移动大量对象&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;会产生内存碎片，后续大对象分配可能失败而触发 Full GC&lt;/li&gt;
&lt;li&gt;清除阶段需要遍历堆，吞吐不佳&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适用场景：老年代的早期实现或碎片不敏感的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;标记-整理mark-compact&#34;&gt;标记-整理（Mark-Compact）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;核心思想：同样先标记，再把存活对象“压缩”到一端，保持内存连续，最后清理边界之外的区域。&lt;/li&gt;
&lt;li&gt;典型流程：
&lt;ol&gt;
&lt;li&gt;标记存活对象&lt;/li&gt;
&lt;li&gt;计算新地址并更新引用（有的实现先计算转发表）&lt;/li&gt;
&lt;li&gt;将对象按新地址搬迁并整理出连续可用空间&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;优点：避免内存碎片，便于后续大对象分配&lt;/li&gt;
&lt;li&gt;缺点：对象移动成本较高，需要更新引用，暂停时间可能更长&lt;/li&gt;
&lt;li&gt;适用场景：老年代常用策略，G1、ZGC 等也在混合或并发阶段引入压缩思想&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复制copying&#34;&gt;复制（Copying）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;核心思想：将内存按比例分为两个对等或不对等的区域，每次只使用其中一个。GC 时把存活对象复制到“空闲”区域，随后整体清空原区域。&lt;/li&gt;
&lt;li&gt;典型流程：
&lt;ol&gt;
&lt;li&gt;新生代常见布局：Eden + S0 + S1（两个 Survivor）&lt;/li&gt;
&lt;li&gt;Minor GC 时从 Eden 和一个 Survivor 里复制存活对象到另一个 Survivor&lt;/li&gt;
&lt;li&gt;完成后交换两个 Survivor 的角色&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;优点：复制后空间天然连续，没有碎片，分配可用指针碰撞，速度快&lt;/li&gt;
&lt;li&gt;缺点：需要预留额外空间，内存利用率较低；存活率高时复制成本上升&lt;/li&gt;
&lt;li&gt;适用场景：新生代（对象朝生夕死，存活率低，复制效率高）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分代收集generational-collection&#34;&gt;分代收集（Generational Collection）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;核心思想：依据“绝大多数对象朝生夕死”的经验法则，将堆划分为新生代与老年代，针对不同代采用不同算法和回收频率。&lt;/li&gt;
&lt;li&gt;典型实现：
&lt;ul&gt;
&lt;li&gt;新生代：多用复制算法（Eden + Survivor），Minor GC 频繁且停顿短&lt;/li&gt;
&lt;li&gt;老年代：多用标记-清除或标记-整理，Major/Full GC 频率低但停顿长&lt;/li&gt;
&lt;li&gt;跨代引用：通过 Remembered Set 或 Card Table 跟踪老年代指向新生代的引用，避免每次扫描整个老年代&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点：综合性能好，在典型负载下能显著降低总停顿时间&lt;/li&gt;
&lt;li&gt;缺点：需要维护跨代写屏障与集合结构，调参复杂&lt;/li&gt;
&lt;li&gt;适用场景：几乎所有 HotSpot 回收器的基础设计，如 Parallel、CMS（历史）、G1、Shenandoah、ZGC 等都体现了分代思想&lt;/li&gt;
&lt;li&gt;小结
&lt;ul&gt;
&lt;li&gt;标记-清除：简单但易碎片化&lt;/li&gt;
&lt;li&gt;标记-整理：无碎片但移动成本高&lt;/li&gt;
&lt;li&gt;复制：快速无碎片，牺牲一部分空间&lt;/li&gt;
&lt;li&gt;分代：按对象存活特征选择算法，工程上最常见的组合策略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;垃圾回收器&#34;&gt;垃圾回收器&lt;/h2&gt;
&lt;h2 id=&#34;来源&#34;&gt;来源&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://tinyzzh.github.io/java/gcroot/2022/10/12/JVM_GCRoot.html&#34;&gt;详解Java的 GCRoot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/7123853933801373733&#34;&gt;JVM之垃圾回收机制（GC）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://javaguide.cn/java/jvm/jvm-garbage-collection.html&#34;&gt;JVM垃圾回收详解（重点）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@ali.gelenler/types-of-references-in-java-d8fe0da6d656&#34;&gt;Types of References in Java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000039994284#item-6&#34;&gt;Java四种引用类型原理你真的搞明白了吗？五分钟带你深入理解！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/7348729694509334555&#34;&gt;说一说Java中的四种引用类型？&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RuntimeDataArea</title>
      <link>https://asgpipo.github.io/posts/java/jvm/runtime-data-area/</link>
      <pubDate>Thu, 25 Sep 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/java/jvm/runtime-data-area/</guid>
      <description>&lt;h2 id=&#34;java-virtual-machine-stacks&#34;&gt;Java Virtual Machine Stacks&lt;/h2&gt;
&lt;p&gt;是一块内存区域,用于存放存放单个线程的数据如方法和局部变量,一个Stack里有多个Stack Frame.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/Pasted-image-20251009145538.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更大的栈内存设置不会提高效率，会减少最大同时运行线程数量&lt;/li&gt;
&lt;li&gt;栈内存可固定也可以动态变化&lt;/li&gt;
&lt;li&gt;static变量可以被多个线程同时调用，需要考虑线程安全&lt;/li&gt;
&lt;li&gt;私有局部变量只存在在该栈内只能被这个栈调用，通常认为是安全的。&lt;/li&gt;
&lt;li&gt;当局部变量发生&lt;a href=&#34;#escape&#34;&gt;Escape&lt;/a&gt;时，不再线程安全，如参数传递，返回值泄露&lt;/li&gt;
&lt;li&gt;即使没有递归也有可能发生StackOverFlow,比如循环引用.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heap&#34;&gt;Heap&lt;/h2&gt;
&lt;p&gt;最大的一块内存空间,被所有线程共享,存放着大部分的对象实例,就是new出来的对象.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/HotspotHeapStructure.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/HeapInJDK1.7vs1.8p.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Heap分为三大类,新生区,老年区和元空间(永久代).&lt;/p&gt;
&lt;h3 id=&#34;young-generation&#34;&gt;Young Generation&lt;/h3&gt;
&lt;p&gt;新生代由Eden和两组Survivor空间组成,通常eden要远大于Survivor区域,而Survivor中s0 : s1 == 1 : 1&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;当有新的对象加入 Heap 时通常首先进入 Eden.&lt;/li&gt;
&lt;li&gt;当发生 [[GC(Garbage Collectors)#^Young GC|Young GC]] 时Eden尝试会将Eden和 s1/s0 中全部对象移入s0或s1,并给这些对象年龄加1&lt;/li&gt;
&lt;li&gt;当对象进行多次 GC 后年龄达到阈值会被移入** Old Generation **&lt;/li&gt;
&lt;li&gt;如果新加入的对象过大会直接进入 Old Generation&lt;/li&gt;
&lt;li&gt;Survivor Space的 from 和 to 指的是在复制整理对象时的原位置 和 复制位置.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;old-generation&#34;&gt;Old Generation&lt;/h3&gt;
&lt;p&gt;老年代存放着大对象和长期存活的对象&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。&lt;/p&gt;
&lt;p&gt;大对象直接进入老年代的行为是由虚拟机动态决定的，它与具体使用的垃圾回收器和相关参数有关。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;当对象经历过多次 Young GC 依旧存活达到阈值(通常是15/8) 将被移入 Old Generation.&lt;/p&gt;
&lt;h2 id=&#34;method-area&#34;&gt;Method Area&lt;/h2&gt;
&lt;p&gt;是JVM运行时内存结构中的一块 区域, 被所有JVM线程共享, 存储每个类的结构信息.&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;run-time constant pool&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;, &lt;!-- raw HTML omitted --&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;field&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt; and &lt;!-- raw HTML omitted --&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;method data&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;, and the &lt;!-- raw HTML omitted --&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;code for methods and constructors&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;, including the &lt;!-- raw HTML omitted --&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;special methods&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt; used in class and interface initialization and in instance initialization.&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/MethodAreaStructureInJDK1.8.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;stirngtable&#34;&gt;StirngTable&lt;/h3&gt;
&lt;p&gt;StringTable(String Pool) 在Java7之前存放在 ConstantPool,之后Method Area移动到本地内存实现,但是 StringTable 依旧在堆中.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String 存放在 StringTable中,是不可变对象,能够被多个对象引用.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//StirngBuilder().append(s1).append.(s2).toString(); new String(&amp;#34;ab&amp;#34;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ab&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// s3 != s4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//s4 == s5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;因为s3 相当于new了一个新对象存储,所以存储在堆中.&lt;/p&gt;
&lt;p&gt;而s4则是存储在 StringPool 当中.&lt;/p&gt;
&lt;p&gt;两者指向的对象不同, 而 == 是比较的引用地址,所以flase&lt;/p&gt;
&lt;p&gt;如果使用.equals() 就相同.&lt;/p&gt;
&lt;p&gt;在拼接s5时编译器进行优化,直接从StringPool找到 a b 进行拼接,发现结果是已有的 ab,&lt;/p&gt;
&lt;p&gt;于是直接指向ab.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;intern方法-18&#34;&gt;intern方法 1.8&lt;/h4&gt;
&lt;p&gt;调用字符串对象的 intern 方法，会将&lt;!-- raw HTML omitted --&gt;当前&lt;!-- raw HTML omitted --&gt;**&lt;!-- raw HTML omitted --&gt;堆中字符串对象的引用注册&lt;!-- raw HTML omitted --&gt;**到串池中&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;检查&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;字符串常量池中是否已存在该字符串&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;如果不存在&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;，则将&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;当前堆中字符串对象的引用&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;注册到字符串常量池中&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;如果存在&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;，直接返回池中的引用,不更新引用.&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Main&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;		&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// &amp;#34;a&amp;#34; &amp;#34;b&amp;#34; 被放入串池中，str 则存在于堆内存之中&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;		&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;		&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 调用 str 的 intern 方法，这时串池中没有 &amp;#34;ab&amp;#34; ，则会将堆中字符串对象的引用注册到串池，此时堆内存与串池中的 &amp;#34;ab&amp;#34; 是同一个对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;		&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;st2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;intern&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;		&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 给 str3 赋值，因为此时串池中已有 &amp;#34;ab&amp;#34; ，则直接将串池中的内容返回&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;		&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ab&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;		&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 因为堆内存与串池中的 &amp;#34;ab&amp;#34; 是同一个对象，所以以下两条语句打印的都为 true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;		&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;st2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;		&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;native-method-stack&#34;&gt;Native Method Stack&lt;/h2&gt;
&lt;h2 id=&#34;pc-register&#34;&gt;PC Register&lt;/h2&gt;
&lt;h5 id=&#34;escape&#34;&gt;Escape&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-plain&#34; data-lang=&#34;plain&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static StringBuffer craeteStringBuffer(String s1, String s2) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   StringBuffer sb = new StringBuffer();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   sb.append(s1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   sb.append(s2);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   return sb;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;创建的局部变量 sb 通过return方法传递,将sb脱离了自己掌控,线程逃逸.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;来源&#34;&gt;来源&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://pdai.tech/md/java/jvm/java-jvm-struct.html&#34;&gt;JVM 基础 - JVM 内存结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1yE411Z7AP?p=21&#34;&gt;21_堆_内存诊断_jvirsualvm_哔哩哔哩_bilibili&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.oracle.com/javase/specs/jvms/se17/html/jvms-2.html#jvms-2.5.4&#34;&gt;Chapter 2. The Structure of the Java Virtual Machine&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-eden-%E5%8C%BA%E5%88%86%E9%85%8D&#34;&gt;JVM垃圾回收详解（重点）&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
