<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OOP on pipo&#39;s site</title>
    <link>https://asgpipo.github.io/tags/oop/</link>
    <description>Recent content in OOP on pipo&#39;s site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 06 Nov 2025 15:34:35 +0800</lastBuildDate><atom:link href="https://asgpipo.github.io/tags/oop/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HashMap</title>
      <link>https://asgpipo.github.io/posts/java/java_base/%E9%9B%86%E5%90%88/test/</link>
      <pubDate>Thu, 06 Nov 2025 15:34:35 +0800</pubDate>
      
      <guid>https://asgpipo.github.io/posts/java/java_base/%E9%9B%86%E5%90%88/test/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;date_creation: 2025-10-13 17:26&lt;/p&gt;
&lt;p&gt;date_modify: 2025-11-16 15:34&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;hashmap&#34;&gt;HashMap&lt;/h1&gt;
&lt;p&gt;HashMap 是 Java 中常用的键值对几何结构，通过生成唯一的 Key 查找和存放删除 Value, 通常查找时间复杂度是 &lt;code&gt;O(1)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;其中通过 Key 来生成 Hash 值选择位置存放,因此 HashMap 的 Key 必须是唯一的,但是 Value 可以重复.&lt;/p&gt;
&lt;h2 id=&#34;hashmap-底层是如何是实现的&#34;&gt;HashMap 底层是如何是实现的?&lt;/h2&gt;
&lt;p&gt;HashMap 在底层是通过数组+链表+红黑树的形式实现的.&lt;/p&gt;
&lt;p&gt;在 JDK 1.7 之前 只由 数组+链表实现.&lt;/p&gt;
&lt;h3 id=&#34;哈希&#34;&gt;哈希&lt;/h3&gt;
&lt;h4 id=&#34;jdk-17--18-是如何计算哈希的&#34;&gt;JDK 1.7 &amp;amp; 1.8 是如何计算哈希的?&lt;/h4&gt;
&lt;p&gt;使用**扰动函数 (spreading function)**的目的是为了防止键的 &lt;code&gt;hashCode()&lt;/code&gt; 方法实现较差，导致大量哈希冲突，从而提高键值对在数组中的分散性.&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;JDK 1.7 &lt;code&gt;hash(int h)&lt;/code&gt;&lt;/th&gt;
          &lt;th&gt;JDK 1.8 &lt;code&gt;hash(Object key)&lt;/code&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;函数体&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;多次位移和异或操作，扰动 4 次。&lt;/td&gt;
          &lt;td&gt;键的哈希值与自身无符号右移 16 位的值进行异或。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12); return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;(h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;性能/复杂度&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;性能稍差一点点，因为扰动了 4 次。&lt;/td&gt;
          &lt;td&gt;更加简化，但原理不变，通过高位低位异或分散性更好。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;高位低位哈希（扰动）的作用：&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;HashMap&lt;/code&gt; 的数组长度 &lt;em&gt;N&lt;/em&gt; 总是 &lt;strong&gt;2 的幂次方&lt;/strong&gt;，计算索引时使用的是 &lt;strong&gt;位运算&lt;/strong&gt;：&lt;code&gt;index = (N - 1) &amp;amp; hash&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当 &lt;em&gt;N&lt;/em&gt; 较小（例如 16）时，&lt;em&gt;N&lt;/em&gt;−1 的二进制只有低 4 位是 1，这意味着只有哈希值的&lt;strong&gt;低位&lt;/strong&gt;参与了索引计算。如果键的哈希值只有高位不同，低位相同，它们会映射到同一个桶，造成冲突。&lt;/p&gt;
&lt;p&gt;JDK 1.8 的扰动函数 &lt;code&gt;(h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)&lt;/code&gt; 解决了这个问题：&lt;/p&gt;
&lt;p&gt;• 它将哈希值的高 16 位（即 &lt;em&gt;h&lt;/em&gt;&amp;raquo;&amp;gt;16）与原哈希值 &lt;em&gt;h&lt;/em&gt; 进行 &lt;strong&gt;异或&lt;/strong&gt; (&lt;code&gt;^&lt;/code&gt;) 运算。&lt;/p&gt;
&lt;p&gt;• 这样，哈希值的高位信息也能够影响最终的低位，从而增加了哈希值在低位上的随机性，&lt;strong&gt;减少了哈希冲突的概率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么容量选择 2 的幂？非 2 的幂会怎样？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 总是使用 &lt;strong&gt;2 的幂&lt;/strong&gt;作为哈希表的大小（容量）。&lt;/p&gt;
&lt;h4 id=&#34;为什么容量总是-2-的幂&#34;&gt;为什么容量总是 2 的幂？&lt;/h4&gt;
&lt;p&gt;选择 2 的幂的主要原因是为了高效地计算元素在数组中的位置（索引）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;位运算替代取模：&lt;/strong&gt; 如果容量 &lt;em&gt;N&lt;/em&gt; 是 2 的幂（例如 16=24），那么计算索引 &lt;code&gt;index = hash % N&lt;/code&gt; 就可以通过效率更高的 &lt;strong&gt;位运算&lt;/strong&gt; 来实现：&lt;code&gt;index = (N - 1) &amp;amp; hash&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率高：&lt;/strong&gt; 位运算比传统的取模运算 (&lt;code&gt;%&lt;/code&gt;) 速度快得多。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;掩码有效性：&lt;/strong&gt; 当 &lt;em&gt;N&lt;/em&gt; 是 2 的幂时，&lt;em&gt;N&lt;/em&gt;−1 的二进制表示是全 1，作为掩码能够最大限度地利用哈希值的所有低位，减少碰撞。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;如果容量不是 2 的幂会怎样&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;如果传入的 &lt;code&gt;initialCapacity&lt;/code&gt; 不是 2 的幂，它会被立即通过 &lt;code&gt;tableSizeFor&lt;/code&gt; &lt;strong&gt;调整为最接近且大于或等于它的 2 的幂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果容量 &lt;em&gt;N&lt;/em&gt; 不是 2 的幂（例如 &lt;em&gt;N&lt;/em&gt;=10），那么 &lt;em&gt;N&lt;/em&gt;−1=9 (二进制为 &lt;code&gt;1001&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;• 此时，使用 &lt;code&gt;(N - 1) &amp;amp; hash&lt;/code&gt; 进行索引计算时，&lt;strong&gt;某些哈希位永远不会被使用&lt;/strong&gt;（例如第 2 位和第 4 位），这会导致哈希值不能均匀地分布在所有桶中，从而&lt;strong&gt;加剧哈希冲突&lt;/strong&gt; 并降低性能。&lt;/p&gt;
&lt;h3 id=&#34;树&#34;&gt;树&lt;/h3&gt;
&lt;h4 id=&#34;为什么要-在-17-之后加入红黑树&#34;&gt;为什么要 在 1.7 之后加入红黑树?&lt;/h4&gt;
&lt;p&gt;因为大量元素插入 HashMap 之后可能会出现 Hash 冲突,而 Java 中解决 Hash 冲突的方式是&lt;strong&gt;链式地址法.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../../../pics/Java/hash_table_chaining.png&#34; alt=&#34;链式地址哈希表&#34;&gt;&lt;/p&gt;
&lt;p&gt;当发生冲突后(即 Hash 值相同时),会在这个数组位置后加入一个节点,形成链表.&lt;/p&gt;
&lt;p&gt;当形成&lt;strong&gt;长链表之后再去查找某个元素此时时间复杂度就会退化为&lt;code&gt;O(n)&lt;/code&gt;&lt;/strong&gt;,因此需要新的数据结构引入来缓解这种情况.&lt;/p&gt;
&lt;h4 id=&#34;为什么要引入树而不是其他&#34;&gt;为什么要引入树而不是其他?&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;为什么要引入红黑树,而不是B+树或者AVL树?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在多种自平衡二叉树中，&lt;code&gt;HashMap&lt;/code&gt; 最终选择了 &lt;strong&gt;红黑树 (Red-Black Tree)&lt;/strong&gt;，而非严格平衡的 &lt;strong&gt;AVL 树 (AVL Tree)&lt;/strong&gt; 或常用于磁盘存储的 &lt;strong&gt;B+ 树 (B+ Tree)&lt;/strong&gt;，主要是基于内存操作场景下的&lt;strong&gt;插入/删除成本与查询性能之间的权衡&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么不是AVL树?&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;特性&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;红黑树&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;AVL 树&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;平衡标准&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;相对宽松&lt;/strong&gt;。最长路径不超过最短路径的 2 倍。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;非常严格&lt;/strong&gt;。任何节点的左右子树高度差不超过 1。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;查找性能&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;略慢于 AVL 树。因为树可能更高。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;理论上更快&lt;/strong&gt;。因为树更矮，查找路径更短。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;插入/删除性能&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;更快&lt;/strong&gt;。因为平衡标准宽松，插入/删除后需要进行的旋转操作次数更少。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;更慢。因为平衡标准严格，插入/删除后可能需要更多的旋转来维持平衡。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;• &lt;strong&gt;AVL 树追求“完全平衡”：&lt;/strong&gt; AVL 树要求任何节点的左右子树高度差不能超过 1。这种严格的平衡状态保证了&lt;strong&gt;极佳的查找性能&lt;/strong&gt;（最坏情况下也是 &lt;code&gt;O(log n)&lt;/code&gt;）。然而，维护这种严格平衡状态的成本很高，&lt;strong&gt;每次插入或删除几乎都会破坏平衡规则&lt;/strong&gt;，需要频繁地通过左旋和右旋进行调整。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;红黑树追求“弱平衡”：&lt;/strong&gt; 红黑树牺牲了对“完全平衡”的追求，转而追求“弱平衡”状态，即&lt;strong&gt;整棵树最长路径不会超过最短路径的 2 倍&lt;/strong&gt;。虽然这略微牺牲了一部分查找性能效率，但它换取了&lt;strong&gt;维持树平衡状态的成本的降低&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;权衡考量：&lt;/strong&gt; 在 &lt;code&gt;HashMap&lt;/code&gt; 这种动态数据结构中，元素的&lt;strong&gt;插入和删除操作相对频繁&lt;/strong&gt;。红黑树在插入、删除等操作时，不像 AVL 树那样频繁地破坏规则，因此&lt;strong&gt;不需要频繁地进行调整&lt;/strong&gt;。这种在维护成本上的优势，使得红黑树在 &lt;code&gt;HashMap&lt;/code&gt; 这种读写操作都频繁的场景下成为更优的选择。&lt;/p&gt;
&lt;p&gt;2.为什么不是 B+树?&lt;/p&gt;
&lt;p&gt;B+ 树（或更广泛的 B 树）通常设计用于&lt;strong&gt;外部存储（如数据库索引）&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;特性&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;红黑树&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;B+ 树&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设计目标&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;内存中&lt;/strong&gt;的数据结构。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;磁盘等外部存储&lt;/strong&gt;的数据结构。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;节点结构&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;二叉结构，每个节点最多 2 个子节点。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;多路平衡查找树，每个节点可以有大量子节点（高扇出）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;数据存储&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;键和值存储在所有节点上。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;所有数据（或指针）都存储在叶子节点，内部节点只存索引。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;树的高度&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;相对较高。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;非常矮胖（高度极低）。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;• &lt;strong&gt;B+ 树的主要设计目标是减少磁盘 I/O 次数&lt;/strong&gt;。它通过将节点设计为与磁盘页大小匹配的大块，并确保数据只存储在叶子节点，从而优化了数据检索效率。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;HashMap 操作在内存中：&lt;/strong&gt; &lt;code&gt;HashMap&lt;/code&gt; 运行在 Java 虚拟机内存中，&lt;strong&gt;不存在磁盘 I/O 瓶颈&lt;/strong&gt;。在这种场景下，使用 B+ 树这种复杂的、为磁盘操作优化的数据结构是不必要的，并且会带来更大的空间开销（红黑树的节点大小已经是常规节点大小的两倍左右了）。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;应用场景不匹配&lt;/strong&gt;：B+树最大的优势是&lt;strong&gt;范围查询&lt;/strong&gt;和&lt;strong&gt;顺序遍历&lt;/strong&gt;（因为叶子节点是链表连接的）。而 &lt;code&gt;HashMap&lt;/code&gt; 的核心是&lt;strong&gt;通过 key 进行精确的哈希查找&lt;/strong&gt;，完全不需要范围查询的功能。&lt;/p&gt;
&lt;h2 id=&#34;hashmap-的转化&#34;&gt;HashMap 的转化&lt;/h2&gt;
&lt;h3 id=&#34;树化&#34;&gt;树化&lt;/h3&gt;
&lt;h4 id=&#34;hashmap-什么条件下会从链表变成树&#34;&gt;HashMap 什么条件下会从链表变成树?&lt;/h4&gt;
&lt;p&gt;HashMap 在发生较多哈希冲突且单个桶（数组位置）内元素较多时，会将链表转换为红黑树，以提升查询效率。具体条件为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单个桶内节点数&lt;/strong&gt; ≥ 8（TREEIFY_THRESHOLD = 8）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总元素个数&lt;/strong&gt; ≥ 64（MIN_TREEIFY_CAPACITY = 64）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;满足以上两个条件时，HashMap 才会执行树化操作。&lt;/p&gt;
&lt;h4 id=&#34;为什么选择-8-和-64-这两个数字&#34;&gt;为什么选择 8 和 64 这两个数字?&lt;/h4&gt;
&lt;p&gt;这是一个典型的权衡（trade-off）设计：树节点（TreeNode）的大小约为普通链表节点的两倍，且维护红黑树的平衡需要额外资源。因此，不能在冲突较少时就贸然树化，以免浪费内存和性能。阈值的选择基于理想的随机哈希码分布（遵循泊松分布，参数约为 0.5）下的统计概率。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Because&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TreeNodes&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;are&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;about&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;twice&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;the&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;regular&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nodes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;we&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;them&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;only&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;when&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bins&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;contain&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enough&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nodes&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;warrant&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;see&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TREEIFY_THRESHOLD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;And&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;when&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;they&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;become&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;too&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;small&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;due&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;removal&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;or&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resizing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;they&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;are&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;converted&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;back&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;plain&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;usages&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;with&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;well&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;distributed&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hashCodes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bins&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;are&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rarely&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;used&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Ideally&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;under&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;random&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hashCodes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;the&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frequency&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nodes&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bins&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;follows&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Poisson&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;distribution&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//en.wikipedia.org/wiki/Poisson_distribution) with a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parameter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;about&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;average&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;the&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resizing&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;threshold&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;75&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;although&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;with&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;large&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;variance&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;because&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resizing&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;granularity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Ignoring&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;variance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;the&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;expected&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;occurrences&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;are&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;非线程安全&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)).&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;The&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;first&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;values&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;are&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;60653066&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;30326533&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;07581633&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;01263606&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;00157952&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;00015795&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;00001316&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;00000094&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;00000006&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;more&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;less&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;than&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ten&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;million&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;为什么是 8 ?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个桶内节点数达到 8 的概率仅为 &lt;strong&gt;百万分之一&lt;/strong&gt;（约 0.00000006），这表明已发生严重冲突。&lt;/li&gt;
&lt;li&gt;在良好分布的哈希码下，树化极少触发，避免了不必要的资源开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;为什么是 64？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;阈值 8 可能并非纯因冲突严重，还可能源于数组容量过小导致的偶发碰撞。为避免频繁树化（树化后退化回链表的开销较高），HashMap 优先通过扩容解决问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当总容量 &amp;lt; 64 时，即使单个桶节点 ≥ 8，也会先扩容（而非树化）。&lt;/li&gt;
&lt;li&gt;只有容量 ≥ 64 且桶内节点 ≥ 8 时，才真正树化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此设计确保树化仅在**“容量充足但局部冲突极端”**时发生，平衡了性能与资源消耗。&lt;/p&gt;
&lt;h3 id=&#34;链表化&#34;&gt;链表化&lt;/h3&gt;
&lt;h4 id=&#34;什么时候会退回为链表&#34;&gt;什么时候会退回为链表?&lt;/h4&gt;
&lt;p&gt;当桶中节点数≤ 6 时就会退化为链表.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/**  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;UNTREEIFY_THRESHOLD&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;为什么选择单个桶内节点数为-6-时退化&#34;&gt;为什么选择单个桶内节点数为 6 时退化?&lt;/h4&gt;
&lt;p&gt;选择节点数为 6 时链表化主要是为了防止频繁地抖动,如果设置为 7 ,此时桶内有 8 个节点,删除一个元素,退化成链表,再插入一个元素又会树化,为了避免在不同数据结构之间频繁地转化,设置为 6.&lt;/p&gt;
&lt;h2 id=&#34;执行过程&#34;&gt;执行过程&lt;/h2&gt;
&lt;h3 id=&#34;链表扩容&#34;&gt;链表扩容&lt;/h3&gt;
&lt;h4 id=&#34;17-vs-18-扩容时哈希过程&#34;&gt;1.7 vs 1.8 扩容时哈希过程&lt;/h4&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;方面&lt;/th&gt;
          &lt;th&gt;JDK 1.7&lt;/th&gt;
          &lt;th&gt;JDK 1.8&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;重新哈希方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;所有节点需完整重算 &lt;code&gt;hash % Nnew&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;仅检查 &lt;code&gt;(hash &amp;amp; oldCap)&lt;/code&gt;，复用原 hash&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;计算开销&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;高（O(n) 全扫描 + 模运算）&lt;/td&gt;
          &lt;td&gt;低（O(1) 位运算 per 节点）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;风险&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;头插法易死循环&lt;/td&gt;
          &lt;td&gt;尾插法 + 分裂规则，更安全&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当 &lt;code&gt;HashMap&lt;/code&gt; 容量达到阈值时，会进行扩容（&lt;code&gt;resize&lt;/code&gt;），容量扩大为原来的 &lt;strong&gt;2 倍&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 JDK 1.8 中，扩容时的重新分配节点位置被设计得&lt;strong&gt;非常巧妙和高效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于新容量 Nnew 是旧容量 Nold 的两倍，这意味着 Nnew 的二进制表示比 Nold 多了一个高位 bit（这个 bit 的值就是 Nold）。&lt;/p&gt;
&lt;p&gt;JDK 1.8 利用这个特性来确定节点的新位置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;判断新增位：&lt;/strong&gt; 算法只需要判断原始哈希值 &lt;code&gt;hash&lt;/code&gt; 在新增的那个 &lt;em&gt;bit&lt;/em&gt; 位置上是 0 还是 1。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;◦ 通过计算 &lt;code&gt;(e.hash &amp;amp; oldCap)&lt;/code&gt; 来判断这个新增的位。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;位置规则：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;◦ 如果 &lt;code&gt;(e.hash &amp;amp; oldCap) == 0&lt;/code&gt;，则新索引位置&lt;strong&gt;不变&lt;/strong&gt;（&lt;code&gt;index = 原索引&lt;/code&gt;）。这些节点被归类到 &lt;code&gt;loHead&lt;/code&gt; 链表/子树中。&lt;/p&gt;
&lt;p&gt;◦ 如果 &lt;code&gt;(e.hash &amp;amp; oldCap) != 0&lt;/code&gt;，则新索引位置为 &lt;strong&gt;原索引 + 旧容量&lt;/strong&gt;（&lt;code&gt;index = 原索引 + oldCap&lt;/code&gt;）。这些节点被归类到 &lt;code&gt;hiHead&lt;/code&gt; 链表/子树中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;减少计算：&lt;/strong&gt; 避免了重新对所有键计算完整的哈希值和索引。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;均匀分散：&lt;/strong&gt; 由于新增的 &lt;em&gt;bit&lt;/em&gt; 是随机的，它能均匀地将原来冲突的节点分散到新的两个桶中（原索引和原索引 + 旧容量），从而有效地减少了哈希冲突&lt;/p&gt;
&lt;h4 id=&#34;为什么-18-改为了尾插法&#34;&gt;为什么 1.8 改为了尾插法?&lt;/h4&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;JDK 1.7 (HashMap)&lt;/th&gt;
          &lt;th&gt;JDK 1.8 (HashMap)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;插入方法&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;头插法&lt;/strong&gt; (Add to Head)。新元素插入到链表头部，作为新的头节点。&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;尾插法&lt;/strong&gt; (Add to Tail)。新元素插入到链表的尾部。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;插入快，但扩容时&lt;strong&gt;顺序反转&lt;/strong&gt;。&lt;/td&gt;
          &lt;td&gt;维持链表元素的相对顺序，防止线程安全问题。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;多线程问题&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;不安全&lt;/strong&gt;。在多线程环境下，扩容时可能导致链表形成&lt;strong&gt;环形链表&lt;/strong&gt;（死循环），从而使 &lt;code&gt;get&lt;/code&gt; 操作陷入无限循环。&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;安全&lt;/strong&gt;。解决了环形链表的问题，但在多线程下仍可能存在数据覆盖（&lt;strong&gt;非线程安全&lt;/strong&gt;）。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; JDK 1.8 采用尾插法的主要原因是解决了 JDK 1.7 在多线程竞争扩容时，链表节点指针错乱，导致产生&lt;strong&gt;死循环&lt;/strong&gt;的严重线程安全问题。&lt;/p&gt;
&lt;h3 id=&#34;一条-k-v-插入的流程&#34;&gt;一条 K-V 插入的流程&lt;/h3&gt;
&lt;div class=&#34;mermaid&#34;&gt;flowchart TD
    A[&#34;开始: put(K key, V value)&#34;] --&gt; B[&#34;计算哈希值: hash = hash(key) 扰动函数&#34;]
    B --&gt; C[&#34;初始化/扩容检查: table == null 或 size == 0?&#34;]
    C --&gt;|是| D[&#34;resize(): 初始化容量 16 或指定容量&#34;]
    C --&gt;|否| E[&#34;计算索引: i = (N-1) &amp; hash&#34;]
    D --&gt; E
    E --&gt; F[&#34;检查 table[i] == null?&#34;]
    F --&gt;|是: 空桶| G[&#34;创建新 Node 并插入 table[i]&#34;]
    F --&gt;|否: 非空桶| H[&#34;检查头节点 hash &amp; key 相同?&#34;]
    G --&gt; Z[&#34;值覆盖? 无, 新增 size++&#34;]
    H --&gt;|是| I[&#34;找到 e, 准备覆盖值&#34;]
    H --&gt;|否| J[&#34;头节点是 TreeNode?&#34;]
    J --&gt;|是: 红黑树| K[&#34;putTreeVal: 树中插入/更新&#34;]
    J --&gt;|否: 链表| L[&#34;遍历链表: 尾插法&#34;]
    L --&gt; M[&#34;遍历中找到相同 hash &amp; key 的 e?&#34;]
    M --&gt;|是| I
    M --&gt;|否| N[&#34;插入到链表尾部&#34;]
    N --&gt; O[&#34;检查链表长度 binCount &gt;= 8?&#34;]
    O --&gt;|是| P[&#34;treeifyBin(): 容量 &lt; 64? 先扩容, 否则树化&#34;]
    O --&gt;|否| Q[&#34;无操作&#34;]
    P --&gt; R[&#34;树化完成&#34;]
    K --&gt; R
    I --&gt; S[&#34;替换 e.value = value, 返回旧值&#34;]
    S --&gt; Z
    R --&gt; Z
    Q --&gt; Z
    Z[&#34;modCount++, size++ 检查阈值&#34;] --&gt; T[&#34;size &gt; threshold?&#34;]
    T --&gt;|是: 负载因子超| U[&#34;resize(): 扩容 2倍&#34;]
    T --&gt;|否| V[&#34;结束: 返回 null 或旧值&#34;]
    U --&gt; V
    style A fill:#e1f5fe
    style V fill:#c8e6c9
&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;计算哈希值：&lt;/strong&gt; 调用 &lt;code&gt;hash(key)&lt;/code&gt; 方法（扰动函数）计算键的哈希值 &lt;code&gt;hash&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化/扩容检查 (Resize)：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;◦ 检查哈希表数组 &lt;code&gt;table&lt;/code&gt; 是否为 &lt;code&gt;null&lt;/code&gt; 或长度为 0。&lt;/p&gt;
&lt;p&gt;◦ 如果是，调用 &lt;code&gt;resize()&lt;/code&gt; 方法进行&lt;strong&gt;初始化&lt;/strong&gt;（分配默认容量 16，或使用构造函数指定的初始容量）。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;确定索引位置：&lt;/strong&gt; 根据哈希值和当前数组长度 &lt;em&gt;N&lt;/em&gt;，计算元素在数组中的索引 &lt;code&gt;i = (N - 1) &amp;amp; hash&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空桶处理 (直接插入)：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;◦ 如果 &lt;code&gt;table[i]&lt;/code&gt; 处为 &lt;code&gt;null&lt;/code&gt; (空桶)，则直接在该位置创建新的 &lt;code&gt;Node&lt;/code&gt; 节点并插入。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;非空桶处理 (哈希冲突)：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;◦ &lt;strong&gt;快速检查头节点：&lt;/strong&gt; 检查 &lt;code&gt;table[i]&lt;/code&gt; 处的头节点的 &lt;code&gt;hash&lt;/code&gt; 值和 &lt;code&gt;key&lt;/code&gt; 是否与待插入的键值相同。如果相同，则找到目标节点 &lt;code&gt;e&lt;/code&gt;，准备进行值覆盖。&lt;/p&gt;
&lt;p&gt;◦ &lt;strong&gt;红黑树处理：&lt;/strong&gt; 如果头节点是 &lt;code&gt;TreeNode&lt;/code&gt; 实例，说明该桶已树化。调用红黑树的 &lt;code&gt;putTreeVal&lt;/code&gt; 方法在树中插入/更新元素。&lt;/p&gt;
&lt;p&gt;◦ &lt;strong&gt;链表处理：&lt;/strong&gt; 否则，遍历链表。&lt;/p&gt;
&lt;p&gt;​    ▪ 使用 &lt;strong&gt;尾插法&lt;/strong&gt;：遍历到链表末尾，将新节点插入到链表的尾部。&lt;/p&gt;
&lt;p&gt;​    ▪ &lt;strong&gt;查找重复键：&lt;/strong&gt; 在遍历过程中，如果找到相同 &lt;code&gt;hash&lt;/code&gt; 和 &lt;code&gt;key&lt;/code&gt; 的节点 &lt;code&gt;e&lt;/code&gt;，则跳出循环，准备进行值覆盖。&lt;/p&gt;
&lt;p&gt;​    ▪ &lt;strong&gt;树化判断：&lt;/strong&gt; 节点插入后，检查当前链表长度 &lt;code&gt;binCount&lt;/code&gt;。如果链表长度达到 &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; (默认 &lt;strong&gt;8&lt;/strong&gt;)，会调用 &lt;code&gt;treeifyBin()&lt;/code&gt; 方法。该方法会进一步判断：如果数组容量小于 &lt;code&gt;MIN_TREEIFY_CAPACITY&lt;/code&gt; (默认 &lt;strong&gt;64&lt;/strong&gt;)，则先进行&lt;strong&gt;扩容&lt;/strong&gt;，而不是直接树化。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;值覆盖：&lt;/strong&gt; 如果步骤 5 中找到了相同键的节点 &lt;code&gt;e&lt;/code&gt;，则用新值替换旧值，并返回旧值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩容检查 (Load Factor)：&lt;/strong&gt; 增加 &lt;code&gt;modCount&lt;/code&gt; (修改次数)。如果 &lt;code&gt;size&lt;/code&gt; 增加后超过了 &lt;code&gt;threshold&lt;/code&gt; (容量 × 负载因子)，则调用 &lt;code&gt;resize()&lt;/code&gt; 方法进行&lt;strong&gt;扩容&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
