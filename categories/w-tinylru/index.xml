<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>W-TinyLRU on pipo&#39;s site</title>
    <link>https://asgpipo.github.io/categories/w-tinylru/</link>
    <description>Recent content in W-TinyLRU on pipo&#39;s site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 10 Dec 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://asgpipo.github.io/categories/w-tinylru/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>W-TinyLFU</title>
      <link>https://asgpipo.github.io/posts/caffeine/</link>
      <pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/caffeine/</guid>
      <description>&lt;h2 id=&#34;w-tinylfu&#34;&gt;W-TinyLFU&lt;/h2&gt;
&lt;h3 id=&#34;前置理解&#34;&gt;前置理解&lt;/h3&gt;
&lt;h4 id=&#34;slru-分段最久未使用&#34;&gt;SLRU 分段最久未使用&lt;/h4&gt;
&lt;p&gt;分段的意思是将原来只有一段的队列分成两段，一段为 &lt;strong&gt;保护段&lt;/strong&gt; 另一段为 &lt;strong&gt;试用段&lt;/strong&gt;，其内部逻辑与 LRU 相同。
核心流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新数据会进入试用段&lt;/li&gt;
&lt;li&gt;试用段中的数据再次被访问进入保护段&lt;/li&gt;
&lt;li&gt;保护段中被淘汰的数据会回到试用段
&lt;img src=&#34;https://asgpipo.github.io/pics/SLRU.png&#34; alt=&#34;&#34;&gt;
&lt;strong&gt;SLRU 相比 LRU 的优势&lt;/strong&gt;
在 LRU 场景下 如果短时有大量新的 散列的非热点数据访问可能导致缓存中的热点数据被移除替换导致 &lt;strong&gt;缓存污染&lt;/strong&gt;，SLRU 的多级淘汰制可以减少这种情况的发送。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;countminsketch-近似计数器器&#34;&gt;CountMinSketch 近似计数器器&lt;/h4&gt;
&lt;p&gt;原理与布隆过滤器类似，将输入的元素通过散列函数映射到不同的数组位置，每个位置每被映射一次该处的计数器就加一。当请求结果时就返回散列结果中计数最小的值作为计数结果，所以会导致类似布隆过滤器“假阳性”的问题，也就是返回计数比实际计数偏大。&lt;img src=&#34;https://asgpipo.github.io/pics/CountMinSketch.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;w-tinylfu-1&#34;&gt;W-TinyLFU&lt;/h3&gt;
&lt;p&gt;LRU 窗口缓存 + CountMinSketch + SLRU
核心流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新加入的缓存进入 LRU 窗口缓存&lt;/li&gt;
&lt;li&gt;被窗口淘汰的缓存如果 SLRU 段未满则直接进入&lt;/li&gt;
&lt;li&gt;否则从 SLRU 尾部选出将被淘汰的缓存 PK 最少使用的会被淘汰，胜利的会进入 SLRU&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/WTiny-LFU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;title: &amp;#34;W-TinyLFU缓存淘汰策略W-TinyLFU是一种非常优秀的缓存淘汰策略，它综合的考虑了现实场景中可能会遇到的各种问 - 掘金&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;image: &amp;#34;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cb71ed5731e4cddb4c664381140c6f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;description: &amp;#34;W-TinyLFU是一种非常优秀的缓存淘汰策略，它综合的考虑了现实场景中可能会遇到的各种问题，具有能够提高缓存命中率的准入策略，带有LFU的基于频率的优点，还具备元素保鲜机制，同时还能保证低空间消耗。&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;url: &amp;#34;https://juejin.cn/post/7144327955353698334#heading-6&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;favicon: &amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;aspectRatio: &amp;#34;22.90249433106576&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
  </channel>
</rss>
