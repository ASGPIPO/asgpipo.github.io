<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MySQL on pipo&#39;s site</title>
    <link>https://asgpipo.github.io/categories/mysql/</link>
    <description>Recent content in MySQL on pipo&#39;s site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 23 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://asgpipo.github.io/categories/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>索引</title>
      <link>https://asgpipo.github.io/posts/mysql/%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Thu, 23 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/mysql/%E7%B4%A2%E5%BC%95/</guid>
      <description>&lt;h2 id=&#34;索引简介&#34;&gt;索引简介&lt;/h2&gt;
&lt;h3 id=&#34;concept&#34;&gt;Concept&lt;/h3&gt;
&lt;h4 id=&#34;index-是什么&#34;&gt;Index 是什么&lt;/h4&gt;
&lt;p&gt;Index 是一种数据结构,用于加速查找和快速定位数据,.&lt;/p&gt;
&lt;h4 id=&#34;为什么需要-index&#34;&gt;为什么需要 Index&lt;/h4&gt;
&lt;p&gt;传统数据库中进行查找时往往需要在全表全库中进行查找, Index 可以帮助快速定位表,行所在的位置,避免全表查找减少硬盘IO.&lt;/p&gt;
&lt;h3 id=&#34;contrast&#34;&gt;Contrast&lt;/h3&gt;
&lt;h4 id=&#34;有哪些不同实现的-index&#34;&gt;有哪些不同实现的 Index&lt;/h4&gt;
&lt;p&gt;Index有不同的数据结构,如 B+树, Hash索引, 全文索引. 在 InnoDB 中使用 B+树进行索引.&lt;/p&gt;
&lt;h3 id=&#34;context&#34;&gt;Context&lt;/h3&gt;
&lt;h4 id=&#34;如何使用和创建索引&#34;&gt;如何使用和创建索引&lt;/h4&gt;
&lt;p&gt;当创建好索引之后,只要进行&lt;strong&gt;等值查询&lt;/strong&gt; (&lt;code&gt;=&lt;/code&gt; , &lt;code&gt;IN()&lt;/code&gt;,  &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;) 时索引在查询条件的左侧,即可自动使用索引.&lt;/p&gt;
&lt;p&gt;创建索引:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接创建 &lt;code&gt;CREATE INDEX index_name ON table_name (key1, key2, ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改表时创建 &lt;code&gt;ALTER TABLE users ADD INDEX idx_email (email);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;建表时创建&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;products&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;PRIMARY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;KEY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;VARCHAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;INDEX&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;idx_name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;什么时候需要索引&#34;&gt;什么时候需要索引&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当前数据具有&lt;strong&gt;唯一性&lt;/strong&gt;可以当成主键.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当某些数据段的查询十分频繁时可以考虑添加索引.即经常出现在 &lt;strong&gt;&lt;code&gt;WHERE&lt;/code&gt; 和 &lt;code&gt;JOIN&lt;/code&gt;&lt;/strong&gt; 条件里.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当前数据需要频繁排序(&lt;strong&gt;&lt;code&gt;GROUP BY&lt;/code&gt; 和 &lt;code&gt;ORDER BY&lt;/code&gt;&lt;/strong&gt;) 时添加索引后就不再需要每次重排序.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;索引的不同分类&#34;&gt;索引的不同分类&lt;/h2&gt;
&lt;h3 id=&#34;索引的不同分类-1&#34;&gt;索引的不同分类&lt;/h3&gt;
&lt;p&gt;按不同方法分,索引可以分一下几种:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Clustered 与 Secondary&lt;/li&gt;
&lt;li&gt;B+树索引 哈希索引 全文索引&lt;/li&gt;
&lt;li&gt;主键索引 唯一索引 前缀索引 普通索引&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;clustered-与-secondary&#34;&gt;Clustered 与 Secondary&lt;/h4&gt;
&lt;p&gt;在InnoDB 中 每创建一个表都会自动创建一个 Clustered 索引,在没有创建其他索引前提下所有查找都通过 Clustered进行查找.&lt;/p&gt;
&lt;p&gt;Secondary 是用户自己创建的 非主索引(二级索引)&lt;/p&gt;
&lt;h4 id=&#34;哈希索引-b树索引&#34;&gt;哈希索引 B+树索引&lt;/h4&gt;
&lt;h5 id=&#34;哈希索引&#34;&gt;哈希索引&lt;/h5&gt;
&lt;p&gt;通过哈希函数无序地将数据一一对应起来,因此哈希函数在等值查找时速度极佳 &lt;code&gt;O(1)&lt;/code&gt; 但是因为哈希表的无序型使得 哈希索引无法进行范围查询.&lt;/p&gt;
&lt;p&gt;优点: 速度快 占用内存小&lt;/p&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不支持范围查询 模糊查询&lt;/li&gt;
&lt;li&gt;无法进行排序&lt;/li&gt;
&lt;li&gt;可能会发生哈希冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;b-树索引&#34;&gt;B+ 树索引&lt;/h5&gt;
&lt;p&gt;通过树结构将 从小到大 为 index 安排位置形成有序的树结构. 非子叶节点不存放数据,最后一层子叶节点从小到大进行排列,以链表形式彼此连接&lt;/p&gt;
&lt;p&gt;优点 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持范围查询 模糊查询&lt;/li&gt;
&lt;li&gt;支持最左前缀匹配&lt;/li&gt;
&lt;li&gt;可以进行排序&lt;/li&gt;
&lt;li&gt;低层级树减少磁盘 IO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护树需要消耗更多资源&lt;/li&gt;
&lt;li&gt;速度相对哈希较慢 &lt;code&gt;O(lgN)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;contrast-1&#34;&gt;Contrast&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;特性对比&lt;/th&gt;
          &lt;th&gt;Hash 索引&lt;/th&gt;
          &lt;th&gt;B+ 树索引&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;查找速度&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;极快，平均O(1)&lt;/td&gt;
          &lt;td&gt;较快，O(logN)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;存储空间&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;通常较小&lt;/td&gt;
          &lt;td&gt;通常较大&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;支持的查询&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;仅支持等值查询 (=, IN)&lt;/td&gt;
          &lt;td&gt;支持等值、范围 (&amp;gt;, &amp;lt;, BETWEEN)、排序和前缀模糊查询 (LIKE &amp;lsquo;abc%&amp;rsquo;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;哈希冲突&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;存在，需要处理&lt;/td&gt;
          &lt;td&gt;不存在&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;维护成本&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;高 (尤其在数据频繁变更时)&lt;/td&gt;
          &lt;td&gt;高 (需要维护树平衡)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;索引的创建与使用&#34;&gt;索引的创建与使用&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/index_create_use_mindmap.svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;索引越多越好吗&#34;&gt;索引越多越好吗&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每一次索引的创建都要构建对应的 B+ 树,会占用一定空间&lt;/li&gt;
&lt;li&gt;索引的更新与维护会占用数据库的资源&lt;/li&gt;
&lt;li&gt;索引创建不合理会导致大量回表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以只有合适数量的索引才能达到最好效果.&lt;/p&gt;
&lt;h3 id=&#34;索引创建应遵循什么原则&#34;&gt;索引创建应遵循什么原则&lt;/h3&gt;
&lt;h4 id=&#34;1-索引创建应该遵循最左前缀原则要把区分度大的字段排在前面这样区分度大的字段越有可能被更多的-sql-使用到&#34;&gt;1. 索引创建应该遵循最左前缀原则,要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sex&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Department&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;张三&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;男&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;软件工程师&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;技术部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;李四&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;女&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;产品经理&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	      &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;产品部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;王五&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;男&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;销售专员&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	      &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;销售部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;赵六&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;女&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;人力资源专员&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;人力资源部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;钱七&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;男&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;财务分析师&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;财务部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;孙八&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;女&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;前端开发工程师&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;技术部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;周九&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;男&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;市场专员&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	      &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;市场部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;吴十&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;女&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;测试工程师&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;技术部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们查找在技术部的测试工程师&amp;quot;吴十&amp;quot;  应该如何创建索引?&lt;/p&gt;
&lt;p&gt;依据最左前缀,我们要由上到下地不断起进行过滤,所以如此安排 (Department, position, name)&lt;/p&gt;
&lt;p&gt;注意, 应尽量&lt;strong&gt;将范围查询和模糊查询靠右放置&lt;/strong&gt;,B+树数据存储节点也是先按最左边第一个字段排序，在第一个字段的排序基础上，然后在对后续字段进行排序.&lt;/p&gt;
&lt;p&gt;![img](/home/pipo/文档/Obsidian Vault/Java/pics/BplusTreeSort.png)&lt;/p&gt;
&lt;h4 id=&#34;2-应选取多读少写的常用的字段组成索引&#34;&gt;2. 应选取多读少写的,常用的字段组成索引&lt;/h4&gt;
&lt;p&gt;选取多读少写的字段,即不更新的字段以避免频繁更新导致的树重建造成的资源浪费.&lt;/p&gt;
&lt;h4 id=&#34;3-应尽量建立覆盖索引减少回表次数&#34;&gt;3. 应尽量建立覆盖索引减少回表次数&lt;/h4&gt;
&lt;p&gt;通过覆盖索引我们只需在 Secondary 索引中查询便可以得到全部所需信息,不需要再次进入 Clusters 索引查找字段.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是覆盖索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;覆盖索引就是指在当前使用索引查询中无需再次回到 Clusters 索引树即可拿到该次查询所需信息的索引.&lt;/p&gt;
&lt;h3 id=&#34;索引如何更新和维护&#34;&gt;索引如何更新和维护?&lt;/h3&gt;
&lt;h4 id=&#34;1-索引更新&#34;&gt;1. &lt;strong&gt;索引更新&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;索引更新通常发生在数据发生变化时，例如插入、删除或修改操作。索引需要相应地进行调整以反映这些变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;插入数据时&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新记录会根据索引键值插入到索引结构中。例如，在B树索引中，新键值会被插入到适当的位置，可能需要拆分节点以保持树的平衡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;删除数据时&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引中的对应记录会被标记为删除或直接移除。如果删除操作导致节点变得空闲，可能会合并相邻节点以优化空间使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;修改数据时&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果修改了索引键值，索引会进行更新，可能包括删除旧键值并插入新键值。这可能导致索引树的重新平衡。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-索引维护&#34;&gt;2. &lt;strong&gt;索引维护&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;索引维护是为了保持索引的高效性和准确性，通常包括以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引重建&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定期重建索引可以优化索引结构，合并碎片，释放空间，提高查询效率。重建索引通常在低峰时段进行，以减少对系统性能的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引优化&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化索引结构，例如重新组织索引节点以减少树的高度，提高查询速度。这可能涉及重新平衡索引树或调整索引参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;清理无用索引&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定期检查索引的使用情况，删除不再使用的索引，以避免占用不必要的存储空间和影响性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引碎片整理&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;碎片整理可以减少索引中的碎片，优化存储空间，提高访问效率。对于B树索引，这可能涉及合并相邻的空闲页。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能监控&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监控索引的查询性能和存储使用情况，及时发现索引膨胀或性能下降的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析工具&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用数据库的分析工具（如 &lt;code&gt;EXPLAIN&lt;/code&gt; 语句）来检查查询是否有效利用索引，并根据结果调整索引策略。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;索引什么时候会失效&#34;&gt;索引什么时候会失效&lt;/h3&gt;
&lt;h4 id=&#34;1-用联合索引时加入了范围和模糊查询&#34;&gt;1. 用联合索引时加入了范围和模糊查询&lt;/h4&gt;
&lt;h4 id=&#34;2-索引使用函数或表达式&#34;&gt;2. 索引使用函数或表达式&lt;/h4&gt;
&lt;p&gt;查询语句中，如果对索引字段**使用“函数”或“表达式”，**会导致索引失效。&lt;/p&gt;
&lt;p&gt;因为索引树存储的是索引字段的原始值，因此无法索引经过函数计算或表达式计算后的值。&lt;/p&gt;
&lt;p&gt;❌ 错误示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actor_id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actor&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actor_id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TO_DAYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;current_date&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TO_DAYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;date_col&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3-对索引隐式类型转换&#34;&gt;3. 对索引隐式类型转换&lt;/h4&gt;
&lt;p&gt;查询语句中，如果对索引字段进行隐式类型转换，会导致索引失效。由于隐式类型转换是通过 &lt;code&gt;CAST&lt;/code&gt; 函数实现的，等同于对索引列使用了函数，所以会导致索引失效。&lt;/p&gt;
&lt;h4 id=&#34;4-联合索引不遵循最左匹配原则&#34;&gt;4. 联合索引不遵循最左匹配原则&lt;/h4&gt;
&lt;p&gt;联合索引如果不遵循最左匹配原则，就会导致索引失效。原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。&lt;/p&gt;
&lt;h4 id=&#34;5-索引列判空&#34;&gt;5. 索引列判空&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;索引列与&lt;/strong&gt; &lt;code&gt;NULL&lt;/code&gt; &lt;strong&gt;或者&lt;/strong&gt; &lt;code&gt;NOT NULL&lt;/code&gt; &lt;strong&gt;进行判断的时候也会失效&lt;/strong&gt;。这是因为索引并不存储空值.&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/7311623433817620517&#34;&gt;理解Mysql索引原理及特性 | 京东物流技术团队&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dunwu.github.io/pages/fcb19c/&#34;&gt;https://dunwu.github.io/pages/fcb19c/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[04 深入浅出索引（上）](&lt;a href=&#34;https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/04&#34;&gt;https://learn.lianglianglee.com/专栏/MySQL实战45讲/04&lt;/a&gt;  深入浅出索引（上）.md)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;待完成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;索引优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;叶子节点内部查找&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>InnoDB 组成</title>
      <link>https://asgpipo.github.io/posts/mysql/innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Tue, 21 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/mysql/innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description>&lt;h1 id=&#34;innodb-组成&#34;&gt;InnoDB 组成&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/InnoDB_Structure.png&#34; alt=&#34;Mysql 官方图示&#34;&gt;&lt;/p&gt;
&lt;p&gt;内存结构 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buffer Pool&lt;/li&gt;
&lt;li&gt;AHI&lt;/li&gt;
&lt;li&gt;Log Buffer&lt;/li&gt;
&lt;li&gt;Change Buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;硬盘结构:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TableSpace&lt;/li&gt;
&lt;li&gt;Redo Log&lt;/li&gt;
&lt;li&gt;UnDo Log&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;buffer-pool&#34;&gt;Buffer Pool&lt;/h2&gt;
&lt;p&gt;是内存中一块连续的区域,用于缓存表和索引的数据. 用于加速数据访问与读写.&lt;/p&gt;
&lt;h3 id=&#34;page&#34;&gt;Page&lt;/h3&gt;
&lt;p&gt;buffer pool 中存放着 许多 page, 每个 page 记录着表中的数据行（rows）、索引条目（index entries）大小为16kb.
page 中存放的不是整张表 而是多行数据.&lt;/p&gt;
&lt;p&gt;当进行 SQL 查找时（如 SELECT 查询），InnoDB 会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过主键或索引定位到具体的 page（由空间 ID + 页号标识）。&lt;/li&gt;
&lt;li&gt;检查 Buffer Pool 中是否已有该 page（命中率高时，直接从内存返回数据）。&lt;/li&gt;
&lt;li&gt;如果未命中，从磁盘（.ibd 文件）加载整个 16KB page 到 Buffer Pool。&lt;/li&gt;
&lt;li&gt;返回所需数据行，同时将该 page 标记为“活跃”，以便后续快速访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;存储方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 page 被连接成&lt;strong&gt;双向循环链表&lt;/strong&gt;,并分为两块区域.&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;LRU（Least Recently Used，最近最少使用&lt;/strong&gt;）算法的变体来淘汰不常用的页面.&lt;/li&gt;
&lt;li&gt;新子列表（young sublist）（最近访问的页面）和旧子列表（old sublist）（较少访问的页面）。&lt;/li&gt;
&lt;li&gt;中点（midpoint）：young 和 old 的分界线。新加载的 page 先插入中点（old 的头部），观察其是否被访问。
&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/bufferPoolList.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ahi&#34;&gt;AHI&lt;/h2&gt;
&lt;p&gt;InnoDB 的自适应哈希索引，是一个内置在 Buffer Pool 中的内存哈希表，用于加速等值查找&lt;/p&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;加速查询&lt;/strong&gt;：对于频繁的精确匹配查询，哈希表提供 O(1) 访问速度，比 B+ 树索引的 O(log n) 更快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态构建&lt;/strong&gt;：InnoDB 根据实际查询模式自动创建/删除哈希条目，无需手动配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：读密集型工作负载，尤其是点查询（point queries），如主键查找或唯一索引等值条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日志系统&#34;&gt;日志系统&lt;/h2&gt;
&lt;p&gt;InnoDB 的事务恢复基于 &lt;strong&gt;WAL&lt;/strong&gt; 技术，采用 &lt;strong&gt;NO-FORCE + STEAL&lt;/strong&gt; 策略，通过 &lt;strong&gt;Redo Log（重做）与 Undo Log（回滚）&lt;strong&gt;来保障事务的&lt;/strong&gt;持久性与原子性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;log-buffer&#34;&gt;Log Buffer&lt;/h3&gt;
&lt;p&gt;Log Buffer（又称 &lt;strong&gt;redo log buffer&lt;/strong&gt;）是 InnoDB 在内存中用于暂存 &lt;strong&gt;redo log&lt;/strong&gt; 记录的区域。当事务修改 Buffer Pool 中的数据页时，InnoDB 会同时生成对应的 redo log（描述该物理修改），并写入 log buffer。随后，这些 redo log 会根据策略（如事务提交、超时或缓冲区满）被刷入磁盘的 redo log 文件。若数据库崩溃，InnoDB 可在重启时通过重放已持久化的 redo log，&lt;strong&gt;恢复那些已提交但尚未写入数据文件的更改&lt;/strong&gt;，从而保证事务的持久性。&lt;/p&gt;
&lt;h3 id=&#34;redo-log&#34;&gt;Redo Log&lt;/h3&gt;
&lt;p&gt;Redo log 是存储在磁盘上的物理日志，用于在数据库崩溃后恢复&lt;strong&gt;已提交事务的持久化状态&lt;/strong&gt;。它以面向存储页的方式记录修改，内容类似于“在表空间某页的偏移 Y 处写入 Z”。崩溃恢复时，InnoDB 先重做所有 redo log 记录，再通过 undo log 回滚未提交的事务，从而保证 ACID。&lt;/p&gt;
&lt;p&gt;Redo Log 是 &lt;strong&gt;WAL&lt;/strong&gt;（Write-Ahead Logging）技术的核心：修改先写日志，再写数据文件，减少随机 I/O，提高性能。&lt;/p&gt;
&lt;p&gt;崩溃恢复时 InnoDB:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重做所有已提交但未持久化的记录&lt;/li&gt;
&lt;li&gt;通过undo log 将 buffer pool 中未提交的事务回滚&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;undo-log&#34;&gt;Undo Log&lt;/h3&gt;
&lt;p&gt;Undo Log 记录了事务对数据修改的“反向操作”，允许其他事务读取未修改的旧版本数据（一致性读），并在事务回滚时恢复数据。他保存了数据的“历史快照”，确保事务的 ACID 属性（原子性、一致性、隔离性、持久性）。&lt;/p&gt;
&lt;p&gt;Undo Log 主要用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MVCC&lt;/strong&gt;：事务间隔离读，避免锁竞争。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回滚&lt;/strong&gt;：事务失败时撤销修改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;崩溃恢复&lt;/strong&gt;：虽不直接用于恢复，但辅助 purge 操作清理旧数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Undo Log 分为两类：用户表（regular tables）的 Undo Log（需 redo 日志保护，用于崩溃恢复）和临时表（temporary tables）的 Undo Log（仅用于运行时回滚，不生成 redo 日志，提高性能）。&lt;/p&gt;
&lt;p&gt;表空间（&lt;strong&gt;Tablespaces&lt;/strong&gt;）：Undo Log 存储在独立的 Undo Tablespaces（最多 128 个回滚段/表空间）和全局临时表空间（temp tablespace）。每个事务最多分配 4 个 Undo Log（分别处理用户表的 INSERT、UPDATE/DELETE 和临时表的 INSERT、UPDATE/DELETE）。&lt;/p&gt;
&lt;h2 id=&#34;change-buffer&#34;&gt;Change Buffer&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/changeBuffer.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;属于 Buffer Pool 的一块内存结构,存储着**二级索引(&lt;strong&gt;非主索引)&lt;strong&gt;发生的变更&lt;/strong&gt;,当二级索引发生更新时如果&lt;/strong&gt;受影响的二级索引页面不在 Buffer Pool 中,**不会立即更新到磁盘中,而是先存储到 Change Buffer &lt;strong&gt;当这个页面因为其他读操作被加载到 Buffer Pool 时&lt;/strong&gt;，这些变更才会“合并”（merge）进去.&lt;/p&gt;
&lt;h2 id=&#34;来源&#34;&gt;来源&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/02%20%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F.md&#34;&gt;02 日志系统：一条SQL更新语句是如何执行的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/&#34;&gt;MySQL 8.0 Reference Manual&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dunwu.github.io/pages/5fe0f3/&#34;&gt;Mysql 存储引擎 钝悟&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1ve411F794&#34;&gt;5分钟精通MySql的系统框架_哔哩哔哩_bilibili&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据库组成</title>
      <link>https://asgpipo.github.io/posts/mysql/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Tue, 21 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/mysql/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;数据库组成&#34;&gt;数据库组成&lt;/h1&gt;
&lt;p&gt;由 Server 层 + 存储引擎组成.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/DBstructure.png&#34; alt=&#34;数据库组成&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;server-层&#34;&gt;server 层&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;连接器用来维持用户与数据库的连接, 认证, 管理等&lt;/li&gt;
&lt;li&gt;缓存查询,如果当前有之前命令执行的缓存,就会直接返回之前的结果. (MySQL 8.0之后已经移除)&lt;/li&gt;
&lt;li&gt;分析器用来判断当前输入的 SQL 语句是否合法&lt;/li&gt;
&lt;li&gt;优化器会对 SQL 语句选择优化器认为最佳的方案进行执行操作&lt;/li&gt;
&lt;li&gt;执行器执行语句并检查权限&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/InnoDBSimpleStructure.awebp&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/InnoDBSimpleStructure.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;查命令&#34;&gt;查命令&lt;/h3&gt;
&lt;p&gt;当 SQL 命令进入存储引擎后 存储引擎会 首先 尝试 AHI 如果命中不查页哈希表
否则进入 页哈希表查看当前 记录所在页是否存在 buffer pool 中
不存在则从本地硬盘读取所在页进入buffer pool&lt;/p&gt;
&lt;h3 id=&#34;更新命令&#34;&gt;更新命令&lt;/h3&gt;
&lt;p&gt;前几步与查命令相同,在修改前会先将当前原始旧数据先写入 Log Buffer 写入 Undo Tablespace,
然后将数据写入 buffer pool 中的 page 同时 将当前数据通过 Log buffer 写入 Redo log, 然后异步更新.&lt;/p&gt;
&lt;h1 id=&#34;来源&#34;&gt;来源&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1ve411F794&#34;&gt;# 5分钟精通MySql的系统框架&lt;/a&gt;
&lt;a href=&#34;https://dunwu.github.io/pages/5fe0f3/&#34;&gt;Mysql 存储引擎 钝悟&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
