<!DOCTYPE html>
<html lang="en" style="font-size: 105%">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <meta name="author" content="">

  
  
  <meta name="description" content="HashMap
HashMap 是 Java 中常用的键值对几何结构，通过生成唯一的 Key 查找和存放删除 Value, 通常查找时间复杂度是 O(1).
其中通过 Key 来生成 Hash 值选择位置存放,因此 HashMap 的 Key 必须是唯一的,但是 Value 可以重复.">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313//images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313//images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313//images/favicon-16x16.png">

  
  
  <meta name="keywords" content='hugo latex theme blog texify texify2 texify3 michael neuper'>
  

  
  
  <link rel="stylesheet" href='/katex/katex.min.css'>
<script defer defer src='/katex/katex.min.js'></script>
<script defer src='/katex/contrib/auto-render.min.js'></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError : false
        });
    });
</script>
  

  
  

  
  <meta property="og:url" content="http://localhost:1313/posts/java/java-base/%E9%9B%86%E5%90%88/hashmap/">
  <meta property="og:site_name" content="pipo&#39;s site">
  <meta property="og:title" content="pipo&#39;s site">
  <meta property="og:description" content="HashMap HashMap 是 Java 中常用的键值对几何结构，通过生成唯一的 Key 查找和存放删除 Value, 通常查找时间复杂度是 O(1).
其中通过 Key 来生成 Hash 值选择位置存放,因此 HashMap 的 Key 必须是唯一的,但是 Value 可以重复.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:tag" content="OOP">
    <meta property="article:tag" content="HashMap">
    <meta property="article:tag" content="Collections">


  
  <link rel="canonical" href="http://localhost:1313/posts/java/java-base/%E9%9B%86%E5%90%88/hashmap/">

  
  
  
  <meta itemprop="name" content="pipo&#39;s site">
  <meta itemprop="description" content="HashMap HashMap 是 Java 中常用的键值对几何结构，通过生成唯一的 Key 查找和存放删除 Value, 通常查找时间复杂度是 O(1).
其中通过 Key 来生成 Hash 值选择位置存放,因此 HashMap 的 Key 必须是唯一的,但是 Value 可以重复.">
  <meta itemprop="wordCount" content="4868">
  <meta itemprop="keywords" content="OOP,HashMap,Collections">

  
  
  
    <link rel="stylesheet" href="/css/common.min.e562d763c6d0825495eb17de8b2c1d9800cf7c08db1c36accedf77a5fccfc4b9.css" integrity="sha256-5WLXY8bQglSV6xfeiywdmADPfAjbHDaszt93pfzPxLk=" crossorigin="anonymous">
  

  
  
    <link rel="stylesheet" href="/css/content.min.0eb2d1d2ea35e8a94b4208bf1bd8b30a84fc7bc8329a7b795c3db4ed9088ecfb.css" integrity="sha256-DrLR0uo16KlLQgi/G9izCoT8e8gymnt5XD207ZCI7Ps=" crossorigin="anonymous">
  

  
  
  <title> - pipo&#39;s site</title>
  

  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="pipo&#39;s site">
  <meta name="twitter:description" content="HashMap HashMap 是 Java 中常用的键值对几何结构，通过生成唯一的 Key 查找和存放删除 Value, 通常查找时间复杂度是 O(1).
其中通过 Key 来生成 Hash 值选择位置存放,因此 HashMap 的 Key 必须是唯一的,但是 Value 可以重复.">


  


  <link rel="stylesheet" href="/css/single.min.be779f459ad7e3aaf8afd0f80c6a61ca6c50993f5f18512532100ac6d93f0fa9.css" integrity="sha256-vnefRZrX46r4r9D4DGphymxQmT9fGFElMhAKxtk/D6k=" crossorigin="anonymous">


  <link rel="stylesheet" href="/css/single.min.78a121b7d7a160420f9daab0ea13add66c37b9c44f27bba07b27207e2b0975d2.css" integrity="sha256-eKEht9ehYEIPnaqw6hOt1mw3ucRPJ7ugeycgfisJddI=" crossorigin="anonymous">


</head>

<body>
  <div id="wrapper">
    


<header id="header">
  <h1>
    <a href="http://localhost:1313/">blog collcetions</a>
    <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle theme">
        <svg width="2rem" height="2rem" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 496">
        <path fill="currentColor" d="M8,256C8,393,119,504,256,504S504,393,504,256,393,8,256,8,8,119,8,256ZM256,440V72a184,184,0,0,1,0,368Z" transform="translate(-8 -8)"/>
        </svg>
    </button>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      
        <span class="icon"><svg width="1em" height="1em" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M17,11H16a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm0,4H16a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2ZM11,9h6a1,1,0,0,0,0-2H11a1,1,0,0,0,0,2ZM21,3H7A1,1,0,0,0,6,4V7H3A1,1,0,0,0,2,8V18a3,3,0,0,0,3,3H18a4,4,0,0,0,4-4V4A1,1,0,0,0,21,3ZM6,18a1,1,0,0,1-2,0V9H6Zm14-1a2,2,0,0,1-2,2H7.82A3,3,0,0,0,8,18V5H20Zm-9-4h1a1,1,0,0,0,0-2H11a1,1,0,0,0,0,2Zm0,4h1a1,1,0,0,0,0-2H11a1,1,0,0,0,0,2Z"/></svg>
</span>
      
      <a class="link" href="/posts/">Blog</a>
    </span>
    
    <span class="nav-bar-item">
      
        <span class="icon"><svg width="1em" height="1em" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M2.88,16.88a3,3,0,0,0,0,4.24,3,3,0,0,0,4.24,0,3,3,0,0,0-4.24-4.24Zm2.83,2.83a1,1,0,0,1-1.42-1.42,1,1,0,0,1,1.42,0A1,1,0,0,1,5.71,19.71ZM5,12a1,1,0,0,0,0,2,5,5,0,0,1,5,5,1,1,0,0,0,2,0,7,7,0,0,0-7-7ZM5,8a1,1,0,0,0,0,2,9,9,0,0,1,9,9,1,1,0,0,0,2,0,11.08,11.08,0,0,0-3.22-7.78A11.08,11.08,0,0,0,5,8Zm10.61.39A15.11,15.11,0,0,0,5,4,1,1,0,0,0,5,6,13,13,0,0,1,18,19a1,1,0,0,0,2,0A15.11,15.11,0,0,0,15.61,8.39Z"/></svg>
</span>
      
      <a class="link" href="/index.xml">RSS</a>
    </span>
    
    <span class="nav-bar-item">
      
        <span class="icon"><svg width="1em" height="1em" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" data-name="Layer 1">
<path d="M10.07031,20.50291a1.00008,1.00008,0,0,0-1.18115-.9834c-1.30908.24024-2.96191.27637-3.40137-.958a5.70754,5.70754,0,0,0-1.83691-2.415,1.20073,1.20073,0,0,1-.1665-.10938,1,1,0,0,0-.93067-.64551H2.54883a.99965.99965,0,0,0-1,.99512c-.00391.81543.811,1.33789,1.1416,1.51465a4.4408,4.4408,0,0,1,.92383,1.35937c.36426,1.02344,1.42285,2.57617,4.46582,2.376.001.03516.00195.06836.00244.09863l.00439.26758a1,1,0,0,0,2,0l-.00488-.31836C10.07715,21.4951,10.07031,21.22068,10.07031,20.50291Zm10.667-15.126c.03174-.125.063-.26367.09034-.41992a6.27792,6.27792,0,0,0-.40821-3.293,1.002,1.002,0,0,0-.61572-.58007c-.356-.12012-1.67041-.35645-4.18408,1.25a13.86918,13.86918,0,0,0-6.354,0C6.76221.751,5.45459.9658,5.10205,1.07908a.99744.99744,0,0,0-.63135.584,6.3003,6.3003,0,0,0-.40332,3.35644c.02442.12793.05078.2461.07813.35449A6.26928,6.26928,0,0,0,2.89014,9.20311a8.42168,8.42168,0,0,0,.04248.92187c.334,4.60254,3.334,5.98438,5.42431,6.459-.04345.125-.083.25878-.11816.40039a1.00023,1.00023,0,0,0,1.94238.47851,1.6784,1.6784,0,0,1,.46778-.87793.99947.99947,0,0,0-.5459-1.74512c-3.4541-.39453-4.95362-1.80175-5.1792-4.89843a6.61076,6.61076,0,0,1-.03369-.73828,4.25769,4.25769,0,0,1,.91943-2.71289,3.022,3.022,0,0,1,.1958-.23145.99988.99988,0,0,0,.188-1.02441,3.3876,3.3876,0,0,1-.15527-.55567A4.09356,4.09356,0,0,1,6.1167,3.06346a7.54263,7.54263,0,0,1,2.415,1.17968,1.00877,1.00877,0,0,0,.82764.13282,11.77716,11.77716,0,0,1,6.17285.001,1.00549,1.00549,0,0,0,.83056-.13769,7.572,7.572,0,0,1,2.40528-1.19043,4.03977,4.03977,0,0,1,.0874,1.57812,3.205,3.205,0,0,1-.16895.60743.9999.9999,0,0,0,.188,1.02441c.07715.08691.1543.18066.22363.26855A4.12186,4.12186,0,0,1,20,9.20311a7.03888,7.03888,0,0,1-.0376.77734c-.22021,3.05566-1.72558,4.46387-5.1958,4.85937a1,1,0,0,0-.54541,1.7461,1.63079,1.63079,0,0,1,.46631.9082,3.06079,3.06079,0,0,1,.09229.81934v2.334C14.77,21.2949,14.77,21.78025,14.77,22.00291a1,1,0,1,0,2,0c0-.2168,0-.69238.00977-1.33984V18.31346a4.8815,4.8815,0,0,0-.15479-1.31153,4.25638,4.25638,0,0,0-.11621-.416,6.51258,6.51258,0,0,0,5.44531-6.42383A8.69677,8.69677,0,0,0,22,9.20311,6.13062,6.13062,0,0,0,20.7373,5.37693Z"/></svg>
</span>
      
      <a class="link" href="https://github.com/ASGPIPO">GitHub</a>
    </span>
    
  </nav>
</header>
<hr class="head-rule"></hr>
    
<main id="main" class="post">
  
  <div class="post-heading">
    <h1 class="post-title"></h1>
    <div class="publish-metadata">
      
      <svg width="0.75em" height="0.75em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 9H21M7 3V5M17 3V5M6 13H8M6 17H8M11 13H13M11 17H13M16 13H18M16 17H18M6.2 21H17.8C18.9201 21 19.4802 21 19.908 20.782C20.2843 20.5903 20.5903 20.2843 20.782 19.908C21 19.4802 21 18.9201 21 17.8V8.2C21 7.07989 21 6.51984 20.782 6.09202C20.5903 5.71569 20.2843 5.40973 19.908 5.21799C19.4802 5 18.9201 5 17.8 5H6.2C5.0799 5 4.51984 5 4.09202 5.21799C3.71569 5.40973 3.40973 5.71569 3.21799 6.09202C3 6.51984 3 7.07989 3 8.2V17.8C3 18.9201 3 19.4802 3.21799 19.908C3.40973 20.2843 3.71569 20.5903 4.09202 20.782C4.51984 21 5.07989 21 6.2 21Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      1 January 0001
      
      
        &nbsp;
        <span>
          <svg width="0.75em" height="0.75em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M15.4998 5.49994L18.3282 8.32837M3 20.9997L3.04745 20.6675C3.21536 19.4922 3.29932 18.9045 3.49029 18.3558C3.65975 17.8689 3.89124 17.4059 4.17906 16.9783C4.50341 16.4963 4.92319 16.0765 5.76274 15.237L17.4107 3.58896C18.1918 2.80791 19.4581 2.80791 20.2392 3.58896C21.0202 4.37001 21.0202 5.63634 20.2392 6.41739L8.37744 18.2791C7.61579 19.0408 7.23497 19.4216 6.8012 19.7244C6.41618 19.9932 6.00093 20.2159 5.56398 20.3879C5.07171 20.5817 4.54375 20.6882 3.48793 20.9012L3 20.9997Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          4868 words
        </span>
      
      
      
        
      
      
        &nbsp;
        <span>
          <svg width="0.75em" height="0.75em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 7V12L14.5 13.5M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          ~10 mins
        </span>
      
    </div>
  </div>

  
  <div>
    
    <a class="link tag" href='http://localhost:1313/tags/oop'>#OOP</a>
    
    <a class="link tag" href='http://localhost:1313/tags/hashmap'>#HashMap</a>
    
    <a class="link tag" href='http://localhost:1313/tags/collections'>#Collections</a>
    
    <br></br>
  </div>
  
  
  
  <details>
    <summary>
      <b>Table of Contents</b>
    </summary>
    <div class="toc numbered-subtitles"><nav id="TableOfContents">
  <ul>
    <li><a href="#hashmap-底层是如何是实现的">HashMap 底层是如何是实现的?</a>
      <ul>
        <li><a href="#哈希">哈希</a></li>
        <li><a href="#树">树</a></li>
      </ul>
    </li>
    <li><a href="#hashmap-的转化">HashMap 的转化</a>
      <ul>
        <li><a href="#树化">树化</a></li>
        <li><a href="#链表化">链表化</a></li>
      </ul>
    </li>
    <li><a href="#执行过程">执行过程</a>
      <ul>
        <li><a href="#链表扩容">链表扩容</a></li>
        <li><a href="#一条-k-v-插入的流程">一条 K-V 插入的流程</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
  </details>
  
  
  <article class="content numbered-subtitles">
    
    <h1 id="hashmap">HashMap</h1>
<p>HashMap 是 Java 中常用的键值对几何结构，通过生成唯一的 Key 查找和存放删除 Value, 通常查找时间复杂度是 <code>O(1)</code>.</p>
<p>其中通过 Key 来生成 Hash 值选择位置存放,因此 HashMap 的 Key 必须是唯一的,但是 Value 可以重复.</p>
<h2 id="hashmap-底层是如何是实现的">HashMap 底层是如何是实现的?</h2>
<p>HashMap 在底层是通过数组+链表+红黑树的形式实现的.</p>
<p>在 JDK 1.7 之前 只由 数组+链表实现.</p>
<h3 id="哈希">哈希</h3>
<h4 id="jdk-17--18-是如何计算哈希的">JDK 1.7 &amp; 1.8 是如何计算哈希的?</h4>
<p>使用**扰动函数 (spreading function)**的目的是为了防止键的 <code>hashCode()</code> 方法实现较差，导致大量哈希冲突，从而提高键值对在数组中的分散性.</p>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>JDK 1.7 <code>hash(int h)</code></th>
          <th>JDK 1.8 <code>hash(Object key)</code></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong class=chinese>函数体</strong></td>
          <td>多次位移和异或操作，扰动 4 次。</td>
          <td>键的哈希值与自身无符号右移 16 位的值进行异或。</td>
      </tr>
      <tr>
          <td><strong class=chinese>代码</strong></td>
          <td><code>h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</code></td>
          <td><code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code></td>
      </tr>
      <tr>
          <td><strong>性能/复杂度</strong></td>
          <td>性能稍差一点点，因为扰动了 4 次。</td>
          <td>更加简化，但原理不变，通过高位低位异或分散性更好。</td>
      </tr>
  </tbody>
</table>
<p>高位低位哈希（扰动）的作用：</p>
<p>由于 <code>HashMap</code> 的数组长度 <em>N</em> 总是 <strong>2 的幂次方</strong>，计算索引时使用的是 <strong class=chinese>位运算</strong>：<code>index = (N - 1) &amp; hash</code>。</p>
<p>当 <em>N</em> 较小（例如 16）时，<em>N</em>−1 的二进制只有低 4 位是 1，这意味着只有哈希值的<strong class=chinese>低位</strong>参与了索引计算。如果键的哈希值只有高位不同，低位相同，它们会映射到同一个桶，造成冲突。</p>
<p>JDK 1.8 的扰动函数 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 解决了这个问题：</p>
<p>• 它将哈希值的高 16 位（即 <em>h</em>&raquo;&gt;16）与原哈希值 <em>h</em> 进行 <strong class=chinese>异或</strong> (<code>^</code>) 运算。</p>
<p>• 这样，哈希值的高位信息也能够影响最终的低位，从而增加了哈希值在低位上的随机性，<strong class=chinese>减少了哈希冲突的概率</strong></p>
<p>为什么容量选择 2 的幂？非 2 的幂会怎样？</p>
<p><code>HashMap</code> 总是使用 <strong>2 的幂</strong>作为哈希表的大小（容量）。</p>
<h4 id="为什么容量总是-2-的幂">为什么容量总是 2 的幂？</h4>
<p>选择 2 的幂的主要原因是为了高效地计算元素在数组中的位置（索引）。</p>
<ol>
<li><strong>位运算替代取模：</strong> 如果容量 <em>N</em> 是 2 的幂（例如 16=24），那么计算索引 <code>index = hash % N</code> 就可以通过效率更高的 <strong class=chinese>位运算</strong> 来实现：<code>index = (N - 1) &amp; hash</code>。</li>
<li><strong>效率高：</strong> 位运算比传统的取模运算 (<code>%</code>) 速度快得多。</li>
<li><strong>掩码有效性：</strong> 当 <em>N</em> 是 2 的幂时，<em>N</em>−1 的二进制表示是全 1，作为掩码能够最大限度地利用哈希值的所有低位，减少碰撞。</li>
</ol>
<p><strong>如果容量不是 2 的幂会怎样</strong>？</p>
<p>如果传入的 <code>initialCapacity</code> 不是 2 的幂，它会被立即通过 <code>tableSizeFor</code> <strong>调整为最接近且大于或等于它的 2 的幂</strong></p>
<p>如果容量 <em>N</em> 不是 2 的幂（例如 <em>N</em>=10），那么 <em>N</em>−1=9 (二进制为 <code>1001</code>)。</p>
<p>• 此时，使用 <code>(N - 1) &amp; hash</code> 进行索引计算时，<strong class=chinese>某些哈希位永远不会被使用</strong>（例如第 2 位和第 4 位），这会导致哈希值不能均匀地分布在所有桶中，从而<strong class=chinese>加剧哈希冲突</strong> 并降低性能。</p>
<h3 id="树">树</h3>
<h4 id="为什么要-在-17-之后加入红黑树">为什么要 在 1.7 之后加入红黑树?</h4>
<p>因为大量元素插入 HashMap 之后可能会出现 Hash 冲突,而 Java 中解决 Hash 冲突的方式是<strong>链式地址法.</strong></p>
<p><img src="../pics/Java/hash_table_chaining.png" alt="链式地址哈希表"></p>
<p>当发生冲突后(即 Hash 值相同时),会在这个数组位置后加入一个节点,形成链表.</p>
<p>当形成<strong>长链表之后再去查找某个元素此时时间复杂度就会退化为<code>O(n)</code></strong>,因此需要新的数据结构引入来缓解这种情况.</p>
<h4 id="为什么要引入树而不是其他">为什么要引入树而不是其他?</h4>
<p><strong>为什么要引入红黑树,而不是B+树或者AVL树?</strong></p>
<p>在多种自平衡二叉树中，<code>HashMap</code> 最终选择了 <strong>红黑树 (Red-Black Tree)</strong>，而非严格平衡的 <strong>AVL 树 (AVL Tree)</strong> 或常用于磁盘存储的 <strong>B+ 树 (B+ Tree)</strong>，主要是基于内存操作场景下的<strong>插入/删除成本与查询性能之间的权衡</strong>。</p>
<ol>
<li>为什么不是AVL树?</li>
</ol>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特性</th>
          <th style="text-align: left">红黑树</th>
          <th style="text-align: left">AVL 树</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong class=chinese>平衡标准</strong></td>
          <td style="text-align: left"><strong class=chinese>相对宽松</strong>。最长路径不超过最短路径的 2 倍。</td>
          <td style="text-align: left"><strong class=chinese>非常严格</strong>。任何节点的左右子树高度差不超过 1。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>查找性能</strong></td>
          <td style="text-align: left">略慢于 AVL 树。因为树可能更高。</td>
          <td style="text-align: left"><strong class=chinese>理论上更快</strong>。因为树更矮，查找路径更短。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>插入/删除性能</strong></td>
          <td style="text-align: left"><strong class=chinese>更快</strong>。因为平衡标准宽松，插入/删除后需要进行的旋转操作次数更少。</td>
          <td style="text-align: left">更慢。因为平衡标准严格，插入/删除后可能需要更多的旋转来维持平衡。</td>
      </tr>
  </tbody>
</table>
<p>• <strong>AVL 树追求“完全平衡”：</strong> AVL 树要求任何节点的左右子树高度差不能超过 1。这种严格的平衡状态保证了<strong class=chinese>极佳的查找性能</strong>（最坏情况下也是 <code>O(log n)</code>）。然而，维护这种严格平衡状态的成本很高，<strong class=chinese>每次插入或删除几乎都会破坏平衡规则</strong>，需要频繁地通过左旋和右旋进行调整。</p>
<p>• <strong>红黑树追求“弱平衡”：</strong> 红黑树牺牲了对“完全平衡”的追求，转而追求“弱平衡”状态，即<strong>整棵树最长路径不会超过最短路径的 2 倍</strong>。虽然这略微牺牲了一部分查找性能效率，但它换取了<strong class=chinese>维持树平衡状态的成本的降低</strong>。</p>
<p>• <strong>权衡考量：</strong> 在 <code>HashMap</code> 这种动态数据结构中，元素的<strong class=chinese>插入和删除操作相对频繁</strong>。红黑树在插入、删除等操作时，不像 AVL 树那样频繁地破坏规则，因此<strong class=chinese>不需要频繁地进行调整</strong>。这种在维护成本上的优势，使得红黑树在 <code>HashMap</code> 这种读写操作都频繁的场景下成为更优的选择。</p>
<p>2.为什么不是 B+树?</p>
<p>B+ 树（或更广泛的 B 树）通常设计用于<strong>外部存储（如数据库索引）</strong>。</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特性</th>
          <th style="text-align: left">红黑树</th>
          <th style="text-align: left">B+ 树</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong class=chinese>设计目标</strong></td>
          <td style="text-align: left"><strong class=chinese>内存中</strong>的数据结构。</td>
          <td style="text-align: left"><strong class=chinese>磁盘等外部存储</strong>的数据结构。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>节点结构</strong></td>
          <td style="text-align: left">二叉结构，每个节点最多 2 个子节点。</td>
          <td style="text-align: left">多路平衡查找树，每个节点可以有大量子节点（高扇出）。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>数据存储</strong></td>
          <td style="text-align: left">键和值存储在所有节点上。</td>
          <td style="text-align: left">所有数据（或指针）都存储在叶子节点，内部节点只存索引。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>树的高度</strong></td>
          <td style="text-align: left">相对较高。</td>
          <td style="text-align: left">非常矮胖（高度极低）。</td>
      </tr>
  </tbody>
</table>
<p>• <strong>B+ 树的主要设计目标是减少磁盘 I/O 次数</strong>。它通过将节点设计为与磁盘页大小匹配的大块，并确保数据只存储在叶子节点，从而优化了数据检索效率。</p>
<p>• <strong>HashMap 操作在内存中：</strong> <code>HashMap</code> 运行在 Java 虚拟机内存中，<strong>不存在磁盘 I/O 瓶颈</strong>。在这种场景下，使用 B+ 树这种复杂的、为磁盘操作优化的数据结构是不必要的，并且会带来更大的空间开销（红黑树的节点大小已经是常规节点大小的两倍左右了）。</p>
<p>• <strong class=chinese>应用场景不匹配</strong>：B+树最大的优势是<strong class=chinese>范围查询</strong>和<strong class=chinese>顺序遍历</strong>（因为叶子节点是链表连接的）。而 <code>HashMap</code> 的核心是<strong>通过 key 进行精确的哈希查找</strong>，完全不需要范围查询的功能。</p>
<h2 id="hashmap-的转化">HashMap 的转化</h2>
<h3 id="树化">树化</h3>
<h4 id="hashmap-什么条件下会从链表变成树">HashMap 什么条件下会从链表变成树?</h4>
<p>HashMap 在发生较多哈希冲突且单个桶（数组位置）内元素较多时，会将链表转换为红黑树，以提升查询效率。具体条件为：</p>
<ul>
<li><strong class=chinese>单个桶内节点数</strong> ≥ 8（TREEIFY_THRESHOLD = 8）</li>
<li><strong class=chinese>总元素个数</strong> ≥ 64（MIN_TREEIFY_CAPACITY = 64）</li>
</ul>
<p>满足以上两个条件时，HashMap 才会执行树化操作。</p>
<h4 id="为什么选择-8-和-64-这两个数字">为什么选择 8 和 64 这两个数字?</h4>
<p>这是一个典型的权衡（trade-off）设计：树节点（TreeNode）的大小约为普通链表节点的两倍，且维护红黑树的平衡需要额外资源。因此，不能在冲突较少时就贸然树化，以免浪费内存和性能。阈值的选择基于理想的随机哈希码分布（遵循泊松分布，参数约为 0.5）下的统计概率。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Because</span><span class="w"> </span><span class="n">TreeNodes</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">about</span><span class="w"> </span><span class="n">twice</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">regular</span><span class="w"> </span><span class="n">nodes</span><span class="p">,</span><span class="w"> </span><span class="n">we</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">them</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">when</span><span class="w"> </span><span class="n">bins</span><span class="w"> </span><span class="n">contain</span><span class="w"> </span><span class="n">enough</span><span class="w"> </span><span class="n">nodes</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">warrant</span><span class="w"> </span><span class="n">use</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">see</span><span class="w"> </span><span class="n">TREEIFY_THRESHOLD</span><span class="p">).</span><span class="w"> </span><span class="n">And</span><span class="w"> </span><span class="n">when</span><span class="w"> </span><span class="n">they</span><span class="w"> </span><span class="n">become</span><span class="w"> </span><span class="n">too</span><span class="w"> </span><span class="nf">small</span><span class="w"> </span><span class="p">(</span><span class="n">due</span><span class="w"> </span><span class="n">to</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">removal</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">resizing</span><span class="p">)</span><span class="w"> </span><span class="n">they</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">converted</span><span class="w"> </span><span class="n">back</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">plain</span><span class="w"> </span><span class="n">bins</span><span class="p">.</span><span class="w">  </span><span class="n">In</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">usages</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">well</span><span class="o">-</span><span class="n">distributed</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="n">hashCodes</span><span class="p">,</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="n">bins</span><span class="w"> </span><span class="n">are</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">rarely</span><span class="w"> </span><span class="n">used</span><span class="p">.</span><span class="w">  </span><span class="n">Ideally</span><span class="p">,</span><span class="w"> </span><span class="n">under</span><span class="w"> </span><span class="n">random</span><span class="w"> </span><span class="n">hashCodes</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">frequency</span><span class="w"> </span><span class="n">of</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">nodes</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">bins</span><span class="w"> </span><span class="n">follows</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">Poisson</span><span class="w"> </span><span class="n">distribution</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">http</span><span class="p">:</span><span class="c1">//en.wikipedia.org/wiki/Poisson_distribution) with a</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">about</span><span class="w"> </span><span class="n">0</span><span class="p">.</span><span class="na">5</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">average</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="n">resizing</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">threshold</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">0</span><span class="p">.</span><span class="na">75</span><span class="p">,</span><span class="w"> </span><span class="n">although</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">large</span><span class="w"> </span><span class="n">variance</span><span class="w"> </span><span class="n">because</span><span class="w"> </span><span class="n">of</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">resizing</span><span class="w"> </span><span class="n">granularity</span><span class="p">.</span><span class="w"> </span><span class="n">Ignoring</span><span class="w"> </span><span class="n">variance</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">expected</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">occurrences</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="nf">are</span><span class="w"> </span><span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">0</span><span class="p">.</span><span class="na">5</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">0</span><span class="p">.</span><span class="na">5</span><span class="p">,</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="n">非线程安全</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">factorial</span><span class="p">(</span><span class="n">k</span><span class="p">)).</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">are</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">0</span><span class="p">:</span><span class="w">    </span><span class="n">0</span><span class="p">.</span><span class="na">60653066</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">1</span><span class="p">:</span><span class="w">    </span><span class="n">0</span><span class="p">.</span><span class="na">30326533</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">2</span><span class="p">:</span><span class="w">    </span><span class="n">0</span><span class="p">.</span><span class="na">07581633</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">3</span><span class="p">:</span><span class="w">    </span><span class="n">0</span><span class="p">.</span><span class="na">01263606</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">4</span><span class="p">:</span><span class="w">    </span><span class="n">0</span><span class="p">.</span><span class="na">00157952</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">5</span><span class="p">:</span><span class="w">    </span><span class="n">0</span><span class="p">.</span><span class="na">00015795</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">6</span><span class="p">:</span><span class="w">    </span><span class="n">0</span><span class="p">.</span><span class="na">00001316</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">7</span><span class="p">:</span><span class="w">    </span><span class="n">0</span><span class="p">.</span><span class="na">00000094</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">8</span><span class="p">:</span><span class="w">    </span><span class="n">0</span><span class="p">.</span><span class="na">00000006</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="o">*</span><span class="w"> </span><span class="n">more</span><span class="p">:</span><span class="w"> </span><span class="n">less</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">1</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">ten</span><span class="w"> </span><span class="n">million</span><span class="w">
</span></span></span></code></pre></div><p><strong>为什么是 8 ?</strong></p>
<ul>
<li>单个桶内节点数达到 8 的概率仅为 <strong class=chinese>百万分之一</strong>（约 0.00000006），这表明已发生严重冲突。</li>
<li>在良好分布的哈希码下，树化极少触发，避免了不必要的资源开销。</li>
</ul>
<p><strong>为什么是 64？</strong></p>
<p>阈值 8 可能并非纯因冲突严重，还可能源于数组容量过小导致的偶发碰撞。为避免频繁树化（树化后退化回链表的开销较高），HashMap 优先通过扩容解决问题：</p>
<ul>
<li>当总容量 &lt; 64 时，即使单个桶节点 ≥ 8，也会先扩容（而非树化）。</li>
<li>只有容量 ≥ 64 且桶内节点 ≥ 8 时，才真正树化。</li>
</ul>
<p>此设计确保树化仅在**“容量充足但局部冲突极端”**时发生，平衡了性能与资源消耗。</p>
<h3 id="链表化">链表化</h3>
<h4 id="什么时候会退回为链表">什么时候会退回为链表?</h4>
<p>当桶中节点数≤ 6 时就会退化为链表.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**  
</span></span></span><span class="line"><span class="cl"><span class="cm"> * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">UNTREEIFY_THRESHOLD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">6</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><h4 id="为什么选择单个桶内节点数为-6-时退化">为什么选择单个桶内节点数为 6 时退化?</h4>
<p>选择节点数为 6 时链表化主要是为了防止频繁地抖动,如果设置为 7 ,此时桶内有 8 个节点,删除一个元素,退化成链表,再插入一个元素又会树化,为了避免在不同数据结构之间频繁地转化,设置为 6.</p>
<h2 id="执行过程">执行过程</h2>
<h3 id="链表扩容">链表扩容</h3>
<h4 id="17-vs-18-扩容时哈希过程">1.7 vs 1.8 扩容时哈希过程</h4>
<table>
  <thead>
      <tr>
          <th>方面</th>
          <th>JDK 1.7</th>
          <th>JDK 1.8</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong class=chinese>重新哈希方式</strong></td>
          <td>所有节点需完整重算 <code>hash % Nnew</code></td>
          <td>仅检查 <code>(hash &amp; oldCap)</code>，复用原 hash</td>
      </tr>
      <tr>
          <td><strong class=chinese>计算开销</strong></td>
          <td>高（O(n) 全扫描 + 模运算）</td>
          <td>低（O(1) 位运算 per 节点）</td>
      </tr>
      <tr>
          <td><strong class=chinese>风险</strong></td>
          <td>头插法易死循环</td>
          <td>尾插法 + 分裂规则，更安全</td>
      </tr>
  </tbody>
</table>
<p>当 <code>HashMap</code> 容量达到阈值时，会进行扩容（<code>resize</code>），容量扩大为原来的 <strong>2 倍</strong>。</p>
<p>在 JDK 1.8 中，扩容时的重新分配节点位置被设计得<strong class=chinese>非常巧妙和高效</strong>。</p>
<p>由于新容量 Nnew 是旧容量 Nold 的两倍，这意味着 Nnew 的二进制表示比 Nold 多了一个高位 bit（这个 bit 的值就是 Nold）。</p>
<p>JDK 1.8 利用这个特性来确定节点的新位置：</p>
<ol>
<li><strong>判断新增位：</strong> 算法只需要判断原始哈希值 <code>hash</code> 在新增的那个 <em>bit</em> 位置上是 0 还是 1。</li>
</ol>
<p>◦ 通过计算 <code>(e.hash &amp; oldCap)</code> 来判断这个新增的位。</p>
<ol start="2">
<li><strong>位置规则：</strong></li>
</ol>
<p>◦ 如果 <code>(e.hash &amp; oldCap) == 0</code>，则新索引位置<strong class=chinese>不变</strong>（<code>index = 原索引</code>）。这些节点被归类到 <code>loHead</code> 链表/子树中。</p>
<p>◦ 如果 <code>(e.hash &amp; oldCap) != 0</code>，则新索引位置为 <strong>原索引 + 旧容量</strong>（<code>index = 原索引 + oldCap</code>）。这些节点被归类到 <code>hiHead</code> 链表/子树中。</p>
<p><strong>优势：</strong></p>
<p>• <strong>减少计算：</strong> 避免了重新对所有键计算完整的哈希值和索引。</p>
<p>• <strong>均匀分散：</strong> 由于新增的 <em>bit</em> 是随机的，它能均匀地将原来冲突的节点分散到新的两个桶中（原索引和原索引 + 旧容量），从而有效地减少了哈希冲突</p>
<h4 id="为什么-18-改为了尾插法">为什么 1.8 改为了尾插法?</h4>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>JDK 1.7 (HashMap)</th>
          <th>JDK 1.8 (HashMap)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong class=chinese>插入方法</strong></td>
          <td><strong class=chinese>头插法</strong> (Add to Head)。新元素插入到链表头部，作为新的头节点。</td>
          <td><strong class=chinese>尾插法</strong> (Add to Tail)。新元素插入到链表的尾部。</td>
      </tr>
      <tr>
          <td><strong class=chinese>目的</strong></td>
          <td>插入快，但扩容时<strong class=chinese>顺序反转</strong>。</td>
          <td>维持链表元素的相对顺序，防止线程安全问题。</td>
      </tr>
      <tr>
          <td><strong class=chinese>多线程问题</strong></td>
          <td><strong class=chinese>不安全</strong>。在多线程环境下，扩容时可能导致链表形成<strong class=chinese>环形链表</strong>（死循环），从而使 <code>get</code> 操作陷入无限循环。</td>
          <td><strong class=chinese>安全</strong>。解决了环形链表的问题，但在多线程下仍可能存在数据覆盖（<strong class=chinese>非线程安全</strong>）。</td>
      </tr>
  </tbody>
</table>
<p><strong>总结：</strong> JDK 1.8 采用尾插法的主要原因是解决了 JDK 1.7 在多线程竞争扩容时，链表节点指针错乱，导致产生<strong class=chinese>死循环</strong>的严重线程安全问题。</p>
<h3 id="一条-k-v-插入的流程">一条 K-V 插入的流程</h3>
<div class="mermaid">flowchart TD
    A["开始: put(K key, V value)"] --> B["计算哈希值: hash = hash(key) 扰动函数"]
    B --> C["初始化/扩容检查: table == null 或 size == 0?"]
    C -->|是| D["resize(): 初始化容量 16 或指定容量"]
    C -->|否| E["计算索引: i = (N-1) & hash"]
    D --> E
    E --> F["检查 table[i] == null?"]
    F -->|是: 空桶| G["创建新 Node 并插入 table[i]"]
    F -->|否: 非空桶| H["检查头节点 hash & key 相同?"]
    G --> Z["值覆盖? 无, 新增 size++"]
    H -->|是| I["找到 e, 准备覆盖值"]
    H -->|否| J["头节点是 TreeNode?"]
    J -->|是: 红黑树| K["putTreeVal: 树中插入/更新"]
    J -->|否: 链表| L["遍历链表: 尾插法"]
    L --> M["遍历中找到相同 hash & key 的 e?"]
    M -->|是| I
    M -->|否| N["插入到链表尾部"]
    N --> O["检查链表长度 binCount >= 8?"]
    O -->|是| P["treeifyBin(): 容量 < 64? 先扩容, 否则树化"]
    O -->|否| Q["无操作"]
    P --> R["树化完成"]
    K --> R
    I --> S["替换 e.value = value, 返回旧值"]
    S --> Z
    R --> Z
    Q --> Z
    Z["modCount++, size++ 检查阈值"] --> T["size > threshold?"]
    T -->|是: 负载因子超| U["resize(): 扩容 2倍"]
    T -->|否| V["结束: 返回 null 或旧值"]
    U --> V
    style A fill:#e1f5fe
    style V fill:#c8e6c9
</div>

<ol>
<li><strong>计算哈希值：</strong> 调用 <code>hash(key)</code> 方法（扰动函数）计算键的哈希值 <code>hash</code>。</li>
<li><strong>初始化/扩容检查 (Resize)：</strong></li>
</ol>
<p>◦ 检查哈希表数组 <code>table</code> 是否为 <code>null</code> 或长度为 0。</p>
<p>◦ 如果是，调用 <code>resize()</code> 方法进行<strong class=chinese>初始化</strong>（分配默认容量 16，或使用构造函数指定的初始容量）。</p>
<ol start="3">
<li><strong>确定索引位置：</strong> 根据哈希值和当前数组长度 <em>N</em>，计算元素在数组中的索引 <code>i = (N - 1) &amp; hash</code>。</li>
<li><strong>空桶处理 (直接插入)：</strong></li>
</ol>
<p>◦ 如果 <code>table[i]</code> 处为 <code>null</code> (空桶)，则直接在该位置创建新的 <code>Node</code> 节点并插入。</p>
<ol start="5">
<li><strong>非空桶处理 (哈希冲突)：</strong></li>
</ol>
<p>◦ <strong>快速检查头节点：</strong> 检查 <code>table[i]</code> 处的头节点的 <code>hash</code> 值和 <code>key</code> 是否与待插入的键值相同。如果相同，则找到目标节点 <code>e</code>，准备进行值覆盖。</p>
<p>◦ <strong>红黑树处理：</strong> 如果头节点是 <code>TreeNode</code> 实例，说明该桶已树化。调用红黑树的 <code>putTreeVal</code> 方法在树中插入/更新元素。</p>
<p>◦ <strong>链表处理：</strong> 否则，遍历链表。</p>
<p>​    ▪ 使用 <strong class=chinese>尾插法</strong>：遍历到链表末尾，将新节点插入到链表的尾部。</p>
<p>​    ▪ <strong>查找重复键：</strong> 在遍历过程中，如果找到相同 <code>hash</code> 和 <code>key</code> 的节点 <code>e</code>，则跳出循环，准备进行值覆盖。</p>
<p>​    ▪ <strong>树化判断：</strong> 节点插入后，检查当前链表长度 <code>binCount</code>。如果链表长度达到 <code>TREEIFY_THRESHOLD</code> (默认 <strong>8</strong>)，会调用 <code>treeifyBin()</code> 方法。该方法会进一步判断：如果数组容量小于 <code>MIN_TREEIFY_CAPACITY</code> (默认 <strong>64</strong>)，则先进行<strong class=chinese>扩容</strong>，而不是直接树化。</p>
<ol start="6">
<li><strong>值覆盖：</strong> 如果步骤 5 中找到了相同键的节点 <code>e</code>，则用新值替换旧值，并返回旧值。</li>
<li><strong>扩容检查 (Load Factor)：</strong> 增加 <code>modCount</code> (修改次数)。如果 <code>size</code> 增加后超过了 <code>threshold</code> (容量 × 负载因子)，则调用 <code>resize()</code> 方法进行<strong class=chinese>扩容</strong>。</li>
</ol>

    
  </article>

  <button onclick="topFunction()" id="back-to-top" title="Go to top">Back to Top</button>

  

<div id="sharingbuttons">
    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    
</div>
  <div class="paginator">
    
    <a></a>
    
    
    <a class="link" href="http://localhost:1313/posts/%E5%93%88%E5%B8%8C%E8%A1%A8/" title="哈希表基础总结">next →</a>
    
  </div>
  <div class="comment">
    
    
    
      <script src="https://giscus.app/client.js"
        data-repo="michaelneuper/website"
        data-repo-id="R_kgDOIjPNaQ"
        data-category="General"
        data-category-id="DIC_kwDOIjPNac4CaklA"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="gruvbox"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
  </script>
  
  </div>
  
  
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script>

</main>

    <footer id="footer">
  <div>
    <span>Powered by  <a class=link href=https://gohugo.io target=_blank rel=noopener>Hugo</a> | 
Theme <a class=link href=https://github.com/michaelneuper/hugo-texify3 target=_blank rel=noopener>TeXify3</a>
</span>
  </div>
  <div>
    <span>Copyright © 2025 </span>
  </div>
</footer>

  </div>

  
  <script src='http://localhost:1313/js/script.js' defer></script>

  
  
  <link media="screen" rel="stylesheet" href="http://localhost:1313/css/syntax.css" />
  
  <link media="screen" rel="stylesheet" href="http://localhost:1313/css/scale.css" />
  

  
  

  
  

</body>

</html>
