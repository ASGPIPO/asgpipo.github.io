<!DOCTYPE html>
<html lang="en" style="font-size: 105%">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <meta name="author" content="">

  
  
  <meta name="description" content="volatile 关键字是 Java 并发编程中的一个基础且至关重要的概念。它就像是 Java 虚拟机 ([[JVM]]) 和底层硬件之间立下的一份“契约”，专门用于解决多线程环境下共享变量的可见性（Visibility）和有序性（Ordering）问题。
">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://asgpipo.github.io//images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://asgpipo.github.io//images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://asgpipo.github.io//images/favicon-16x16.png">

  
  
  <meta name="keywords" content='hugo latex theme blog texify texify2 texify3 michael neuper'>
  

  
  
  <link rel="stylesheet" href='/katex/katex.min.css'>
<script defer defer src='/katex/katex.min.js'></script>
<script defer src='/katex/contrib/auto-render.min.js'></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError : false
        });
    });
</script>
  

  
  

  
  <meta property="og:url" content="https://asgpipo.github.io/posts/java/concurrency/volatile--synchronized/">
  <meta property="og:site_name" content="pipo&#39;s site">
  <meta property="og:title" content="volatile & synchronized">
  <meta property="og:description" content="volatile 关键字是 Java 并发编程中的一个基础且至关重要的概念。它就像是 Java 虚拟机 ([[JVM]]) 和底层硬件之间立下的一份“契约”，专门用于解决多线程环境下共享变量的可见性（Visibility）和有序性（Ordering）问题。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-13T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-14T21:52:12+08:00">
    <meta property="article:tag" content="Concurrency">
    <meta property="article:tag" content="JAVA">
    <meta property="article:tag" content="JVM">


  
  <link rel="canonical" href="https://asgpipo.github.io/posts/java/concurrency/volatile--synchronized/">

  
  
  
  <meta itemprop="name" content="volatile & synchronized">
  <meta itemprop="description" content="volatile 关键字是 Java 并发编程中的一个基础且至关重要的概念。它就像是 Java 虚拟机 ([[JVM]]) 和底层硬件之间立下的一份“契约”，专门用于解决多线程环境下共享变量的可见性（Visibility）和有序性（Ordering）问题。">
  <meta itemprop="datePublished" content="2025-10-13T00:00:00+00:00">
  <meta itemprop="dateModified" content="2026-01-14T21:52:12+08:00">
  <meta itemprop="wordCount" content="4797">
  <meta itemprop="keywords" content="Concurrency,JAVA,JVM">

  
  
  
    <link rel="stylesheet" href="/css/common.min.e562d763c6d0825495eb17de8b2c1d9800cf7c08db1c36accedf77a5fccfc4b9.css" integrity="sha256-5WLXY8bQglSV6xfeiywdmADPfAjbHDaszt93pfzPxLk=" crossorigin="anonymous">
  

  
  
    <link rel="stylesheet" href="/css/content.min.f51fb43fa8f51b0642996f60541954a19ce736770f5baa9e690f79c9d1fa6421.css" integrity="sha256-9R&#43;0P6j1GwZCmW9gVBlUoZznNncPW6qeaQ95ydH6ZCE=" crossorigin="anonymous">
  

  
  
  <title>volatile &amp; synchronized - pipo&#39;s site</title>
  

  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="volatile & synchronized">
  <meta name="twitter:description" content="volatile 关键字是 Java 并发编程中的一个基础且至关重要的概念。它就像是 Java 虚拟机 ([[JVM]]) 和底层硬件之间立下的一份“契约”，专门用于解决多线程环境下共享变量的可见性（Visibility）和有序性（Ordering）问题。">


  


  <link rel="stylesheet" href="/css/single.min.3a3345f1d6f04a7a511a9c33d043ebb4ca4d7e5c3ae16c2b41f44a71138579db.css" integrity="sha256-OjNF8dbwSnpRGpwz0EPrtMpNflw64WwrQfRKcROFeds=" crossorigin="anonymous">


  <link rel="stylesheet" href="/css/single.min.78a121b7d7a160420f9daab0ea13add66c37b9c44f27bba07b27207e2b0975d2.css" integrity="sha256-eKEht9ehYEIPnaqw6hOt1mw3ucRPJ7ugeycgfisJddI=" crossorigin="anonymous">


</head>

<body>
  <div id="wrapper">
    


<header id="header">
  <h1>
    <a href="https://asgpipo.github.io/">blog collcetions</a>
    <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle theme">
        <svg width="2rem" height="2rem" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 496">
        <path fill="currentColor" d="M8,256C8,393,119,504,256,504S504,393,504,256,393,8,256,8,8,119,8,256ZM256,440V72a184,184,0,0,1,0,368Z" transform="translate(-8 -8)"/>
        </svg>
    </button>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      
        <span class="icon"><svg width="1em" height="1em" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M17,11H16a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm0,4H16a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2ZM11,9h6a1,1,0,0,0,0-2H11a1,1,0,0,0,0,2ZM21,3H7A1,1,0,0,0,6,4V7H3A1,1,0,0,0,2,8V18a3,3,0,0,0,3,3H18a4,4,0,0,0,4-4V4A1,1,0,0,0,21,3ZM6,18a1,1,0,0,1-2,0V9H6Zm14-1a2,2,0,0,1-2,2H7.82A3,3,0,0,0,8,18V5H20Zm-9-4h1a1,1,0,0,0,0-2H11a1,1,0,0,0,0,2Zm0,4h1a1,1,0,0,0,0-2H11a1,1,0,0,0,0,2Z"/></svg>
</span>
      
      <a class="link" href="/posts/">Blog</a>
    </span>
    
    <span class="nav-bar-item">
      
        <span class="icon"><svg width="1em" height="1em" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M2.88,16.88a3,3,0,0,0,0,4.24,3,3,0,0,0,4.24,0,3,3,0,0,0-4.24-4.24Zm2.83,2.83a1,1,0,0,1-1.42-1.42,1,1,0,0,1,1.42,0A1,1,0,0,1,5.71,19.71ZM5,12a1,1,0,0,0,0,2,5,5,0,0,1,5,5,1,1,0,0,0,2,0,7,7,0,0,0-7-7ZM5,8a1,1,0,0,0,0,2,9,9,0,0,1,9,9,1,1,0,0,0,2,0,11.08,11.08,0,0,0-3.22-7.78A11.08,11.08,0,0,0,5,8Zm10.61.39A15.11,15.11,0,0,0,5,4,1,1,0,0,0,5,6,13,13,0,0,1,18,19a1,1,0,0,0,2,0A15.11,15.11,0,0,0,15.61,8.39Z"/></svg>
</span>
      
      <a class="link" href="/index.xml">RSS</a>
    </span>
    
    <span class="nav-bar-item">
      
        <span class="icon"><svg width="1em" height="1em" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" data-name="Layer 1">
<path d="M10.07031,20.50291a1.00008,1.00008,0,0,0-1.18115-.9834c-1.30908.24024-2.96191.27637-3.40137-.958a5.70754,5.70754,0,0,0-1.83691-2.415,1.20073,1.20073,0,0,1-.1665-.10938,1,1,0,0,0-.93067-.64551H2.54883a.99965.99965,0,0,0-1,.99512c-.00391.81543.811,1.33789,1.1416,1.51465a4.4408,4.4408,0,0,1,.92383,1.35937c.36426,1.02344,1.42285,2.57617,4.46582,2.376.001.03516.00195.06836.00244.09863l.00439.26758a1,1,0,0,0,2,0l-.00488-.31836C10.07715,21.4951,10.07031,21.22068,10.07031,20.50291Zm10.667-15.126c.03174-.125.063-.26367.09034-.41992a6.27792,6.27792,0,0,0-.40821-3.293,1.002,1.002,0,0,0-.61572-.58007c-.356-.12012-1.67041-.35645-4.18408,1.25a13.86918,13.86918,0,0,0-6.354,0C6.76221.751,5.45459.9658,5.10205,1.07908a.99744.99744,0,0,0-.63135.584,6.3003,6.3003,0,0,0-.40332,3.35644c.02442.12793.05078.2461.07813.35449A6.26928,6.26928,0,0,0,2.89014,9.20311a8.42168,8.42168,0,0,0,.04248.92187c.334,4.60254,3.334,5.98438,5.42431,6.459-.04345.125-.083.25878-.11816.40039a1.00023,1.00023,0,0,0,1.94238.47851,1.6784,1.6784,0,0,1,.46778-.87793.99947.99947,0,0,0-.5459-1.74512c-3.4541-.39453-4.95362-1.80175-5.1792-4.89843a6.61076,6.61076,0,0,1-.03369-.73828,4.25769,4.25769,0,0,1,.91943-2.71289,3.022,3.022,0,0,1,.1958-.23145.99988.99988,0,0,0,.188-1.02441,3.3876,3.3876,0,0,1-.15527-.55567A4.09356,4.09356,0,0,1,6.1167,3.06346a7.54263,7.54263,0,0,1,2.415,1.17968,1.00877,1.00877,0,0,0,.82764.13282,11.77716,11.77716,0,0,1,6.17285.001,1.00549,1.00549,0,0,0,.83056-.13769,7.572,7.572,0,0,1,2.40528-1.19043,4.03977,4.03977,0,0,1,.0874,1.57812,3.205,3.205,0,0,1-.16895.60743.9999.9999,0,0,0,.188,1.02441c.07715.08691.1543.18066.22363.26855A4.12186,4.12186,0,0,1,20,9.20311a7.03888,7.03888,0,0,1-.0376.77734c-.22021,3.05566-1.72558,4.46387-5.1958,4.85937a1,1,0,0,0-.54541,1.7461,1.63079,1.63079,0,0,1,.46631.9082,3.06079,3.06079,0,0,1,.09229.81934v2.334C14.77,21.2949,14.77,21.78025,14.77,22.00291a1,1,0,1,0,2,0c0-.2168,0-.69238.00977-1.33984V18.31346a4.8815,4.8815,0,0,0-.15479-1.31153,4.25638,4.25638,0,0,0-.11621-.416,6.51258,6.51258,0,0,0,5.44531-6.42383A8.69677,8.69677,0,0,0,22,9.20311,6.13062,6.13062,0,0,0,20.7373,5.37693Z"/></svg>
</span>
      
      <a class="link" href="https://github.com/ASGPIPO">GitHub</a>
    </span>
    
  </nav>
</header>
<hr class="head-rule"></hr>
    


  
    
      
    
  

<main id="main" class="post">
  
  <div class="post-heading">
    <h1 class="post-title">volatile &amp; synchronized</h1>
    <div class="publish-metadata">
      
      <svg width="0.75em" height="0.75em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 9H21M7 3V5M17 3V5M6 13H8M6 17H8M11 13H13M11 17H13M16 13H18M16 17H18M6.2 21H17.8C18.9201 21 19.4802 21 19.908 20.782C20.2843 20.5903 20.5903 20.2843 20.782 19.908C21 19.4802 21 18.9201 21 17.8V8.2C21 7.07989 21 6.51984 20.782 6.09202C20.5903 5.71569 20.2843 5.40973 19.908 5.21799C19.4802 5 18.9201 5 17.8 5H6.2C5.0799 5 4.51984 5 4.09202 5.21799C3.71569 5.40973 3.40973 5.71569 3.21799 6.09202C3 6.51984 3 7.07989 3 8.2V17.8C3 18.9201 3 19.4802 3.21799 19.908C3.40973 20.2843 3.71569 20.5903 4.09202 20.782C4.51984 21 5.07989 21 6.2 21Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      13 October 2025
      
      
        &nbsp;
        <span>
          <svg width="0.75em" height="0.75em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M15.4998 5.49994L18.3282 8.32837M3 20.9997L3.04745 20.6675C3.21536 19.4922 3.29932 18.9045 3.49029 18.3558C3.65975 17.8689 3.89124 17.4059 4.17906 16.9783C4.50341 16.4963 4.92319 16.0765 5.76274 15.237L17.4107 3.58896C18.1918 2.80791 19.4581 2.80791 20.2392 3.58896C21.0202 4.37001 21.0202 5.63634 20.2392 6.41739L8.37744 18.2791C7.61579 19.0408 7.23497 19.4216 6.8012 19.7244C6.41618 19.9932 6.00093 20.2159 5.56398 20.3879C5.07171 20.5817 4.54375 20.6882 3.48793 20.9012L3 20.9997Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          4797 words
        </span>
      
      
      
        
      
      
        &nbsp;
        <span>
          <svg width="0.75em" height="0.75em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 7V12L14.5 13.5M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          ~10 mins
        </span>
      
    </div>
  </div>

  
  <div>
    
    <a class="link tag" href='https://asgpipo.github.io/tags/concurrency'>#Concurrency</a>
    
    <a class="link tag" href='https://asgpipo.github.io/tags/java'>#JAVA</a>
    
    <a class="link tag" href='https://asgpipo.github.io/tags/jvm'>#JVM</a>
    
    <br></br>
  </div>
  
  
  
    
  
  
  <article class="content numbered-subtitles">
    
    <p><code>volatile</code> 关键字是 Java 并发编程中的一个基础且至关重要的概念。它就像是 Java 虚拟机 ([[JVM]]) 和底层硬件之间立下的一份“契约”，专门用于解决多线程环境下<strong>共享变量的可见性（Visibility）和有序性（Ordering）问题</strong>。
<img src="/pics/Java/VolatileMindMap.png" alt=""></p>
<hr>
<h2 id="一-volatile-的含义及在-java-中的作用">一、 <code>volatile</code> 的含义及在 Java 中的作用</h2>
<h3 id="1-单词的意思literal-meaning">1. 单词的意思（Literal Meaning）</h3>
<p>在 Java 中，<code>volatile</code> 关键字用来标记一个 Java 变量是 &ldquo;<strong class=chinese>存储在主内存中</strong>&quot;（&ldquo;being stored in main memory&rdquo;）的。它指示 JVM，这个变量是<strong class=chinese>共享且不稳定的</strong>。</p>
<h3 id="2-它在-java-中干什么核心机制">2. 它在 Java 中干什么（核心机制）</h3>
<p><code>volatile</code> 的核心作用是<strong class=chinese>强制读写操作直接与主内存进行交互</strong>，从而解决了由于 CPU 缓存和指令重排序带来的并发问题。</p>
<h4 id="a-解决可见性问题强制内存访问">A. 解决可见性问题（强制内存访问）</h4>
<p>由于现代 CPU 为了性能，会将变量副本存储在 CPU 寄存器或缓存中。如果变量未被声明为 <code>volatile</code>，线程在操作共享变量时，对主内存的读写时间是不确定的。</p>
<ul>
<li><strong>读取操作：</strong> 对 <code>volatile</code> 变量的每一次读取都将直接从计算机的<strong class=chinese>主内存</strong>中读取，而不是从 CPU 寄存器中读取。</li>
<li><strong>写入操作：</strong> 对 <code>volatile</code> 变量的每一次写入都将立即被<strong class=chinese>写入到主内存</strong>中，而不仅仅是写入到 CPU 寄存器或写缓冲区中。</li>
</ul>
<p>通过这种方式，<code>volatile</code> 确保了当一个线程更新变量值时，处理器会立即<strong class=chinese>刷新</strong>这些更新，保证其他线程随后读取时能看到这个最新值。</p>
<h4 id="b-解决有序性问题禁止指令重排序">B. 解决有序性问题（禁止指令重排序）</h4>
<p>编译器、运行时环境或处理器可能会对指令进行重排序以优化性能。<code>volatile</code> 变量是与运行时和处理器进行通信，以<strong>避免重排序任何涉及该 <code>volatile</code> 变量的指令</strong>。</p>
<ul>
<li>它通过插入<strong>内存屏障 (Memory Barrier)</strong> 来实现这一目标。内存屏障就像一道墙，禁止某些类型的处理器重排序。</li>
</ul>
<h2 id="二-volatile-保证了什么核心承诺">二、 <code>volatile</code> 保证了什么？（核心承诺）</h2>
<p><code>volatile</code> 关键字提供了 Java 内存模型 ([[Java/Concurrency/JMM|JMM]]) 规定的两大核心保证：</p>
<h3 id="1-内存可见性visibility-guarantee">1. 内存可见性（Visibility Guarantee）</h3>
<p>这是 <code>volatile</code> 最主要也是最基础的保证。</p>
<ul>
<li><strong>一致性保证：</strong> <code>volatile</code> 保证了所有线程看到的共享变量的值是<strong class=chinese>一致的</strong>。当对 <code>volatile</code> 字段进行更新后，<strong class=chinese>该字段的共享值会立即更新</strong>，其他线程不会获取到不一致的值。</li>
<li><strong>完整可见性保证（Full Volatile Visibility Guarantee）：</strong> <code>volatile</code> 的可见性保证甚至延伸到了变量本身之外。
<ul>
<li>如果线程 A 写入一个 <code>volatile</code> 变量，随后线程 B 读取了它，那么<strong>在 A 写入该 <code>volatile</code> 变量之前对所有其他变量所做的更改，对 B 来说都是可见的</strong>。</li>
<li>类似地，当线程 A 读取 <code>volatile</code> 变量时，所有对线程 A 可见的变量都会<strong class=chinese>被强制重新从主内存读取</strong>。</li>
</ul>
</li>
</ul>
<h3 id="2-有序性与-happens-before-关系">2. 有序性与 Happens-Before 关系</h3>
<p><code>volatile</code> 关键字提供了 Java 内存模型中的 <strong>Happens-Before 保证</strong>。</p>
<ul>
<li><strong>Volatile 变量规则：</strong> 对一个 <code>volatile</code> 变量的<strong>写操作 Happens-Before 后面对这个 <code>volatile</code> 变量的读操作</strong>。</li>
<li><strong>重排序约束：</strong>
<ul>
<li><strong>写入屏障：</strong> 发生在 <code>volatile</code> 变量写入<strong class=chinese>之前</strong>对其他变量的读写，<strong class=chinese>不能</strong>被重排到 <code>volatile</code> 写入<strong class=chinese>之后</strong>发生。</li>
<li><strong>读取屏障：</strong> 发生在 <code>volatile</code> 变量读取<strong class=chinese>之后</strong>对其他变量的读写，<strong class=chinese>不能</strong>被重排到 <code>volatile</code> 读取<strong class=chinese>之前</strong>发生。</li>
</ul>
</li>
</ul>
<h3 id="3-对-64-位值操作的原子性保障">3. 对 64 位值操作的原子性保障</h3>
<p>[[Java/Concurrency/JMM|JMM]] 对 64 位值（如 <code>long</code> 和 <code>double</code>）的访问原子性有所放宽，因为在某些 32 位平台上，读写 64 位值可能需要两次内存事务，导致操作非原子。</p>
<ul>
<li><code>volatile</code> 作为一种<strong>逃生出口（escape hatch）</strong>，可以用来<strong>强制确保 64 位值的访问原子性</strong>。</li>
<li>如果代码可能在 32 位平台上运行，开发者必须使用 <code>volatile</code> 关键字来保障 64 位操作的可移植性。</li>
</ul>
<h2 id="三-什么时候使用-volatile适用场景">三、 什么时候使用 <code>volatile</code>？（适用场景）</h2>
<p><code>volatile</code> 是一个<strong class=chinese>轻量级的同步机制</strong>，适用于只需要保证可见性和有序性，但不需要互斥的场景。</p>
<ol>
<li><strong>单写多读场景 (State Flag)</strong>：当<strong class=chinese>只有一个线程</strong>会修改（写入）变量的值，而其他所有线程只负责读取该变量时，<code>volatile</code> 是足够的。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Server</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 状态标志：只有一个线程会把它设为 true</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">isRunning</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">shutdown</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">isRunning</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 单写操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doWork</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">isRunning</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 多读操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// ... 执行任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Server has been shut down.&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><ol>
<li><strong>值不依赖于旧值：</strong> 即使有多个线程写入 <code>volatile</code> 变量，只要写入的新值<strong class=chinese>不依赖于其旧值</strong>（例如，设置一个布尔状态标记，而不是计数器递增），<code>volatile</code> 也是足够的。</li>
<li><strong>替代重量级锁：</strong> 当应用程序需要确保数据的可见性方面，但同时又希望避免 <code>synchronized</code> 方法和块带来的性能开销时，<code>volatile</code> 很有用。</li>
<li><strong>&ldquo;搭便车&quot;技巧 (Piggybacking)</strong>：利用 <code>volatile</code> 带来的 happens-before 顺序性，将普通变量的写入放在 <code>volatile</code> 变量写入之前，可以使普通变量的可见性“搭上” <code>volatile</code> 变量的便车。</li>
</ol>
<h2 id="四-什么时候不使用-volatile局限性与替代方案">四、 什么时候不使用 <code>volatile</code>？（局限性与替代方案）</h2>
<p><code>volatile</code> 具有明显的局限性，在需要复杂同步时，不应单独依赖它。</p>
<h3 id="1-不能保证互斥性mutual-exclusion">1. 不能保证互斥性（Mutual Exclusion）</h3>
<ul>
<li><code>volatile</code> 字段的读写<strong class=chinese>不会阻塞</strong>其他线程的读写操作。</li>
<li><code>volatile</code> 关键字<strong>不提供互斥（mutual exclusion）</strong>，即它不能保证在任何时刻只有一个线程执行关键代码段。</li>
</ul>
<h3 id="2-无法保障复合操作的原子性">2. 无法保障复合操作的原子性</h3>
<ul>
<li>一旦线程需要<strong>先读取 <code>volatile</code> 变量的值，然后根据该值生成一个新的值</strong>（即复合操作，如 <code>i++</code> 或 <code>count = count + 1</code>），<strong>单独的 <code>volatile</code> 就不够了</strong>。</li>
<li>在读取和写入新值之间的短暂时间差内，会产生<strong>竞态条件（race condition）</strong>，多个线程可能读取到相同的值，导致相互覆盖，最终结果错误。</li>
<li><strong>替代方案：</strong> 在这种需要<strong class=chinese>原子性</strong>（读取和写入是一个不可分割操作）的情况下，必须使用：
<ul>
<li><strong><code>synchronized</code> 块或方法</strong>。</li>
<li><code>java.util.concurrent</code> 包中的各种<strong class=chinese>原子数据类型</strong>，如 <code>AtomicLong</code> 或 <code>AtomicReference</code>。</li>
</ul>
</li>
</ul>
<h3 id="3-性能考量">3. 性能考量</h3>
<ul>
<li>访问 <code>volatile</code> 变量会将其读写到主内存，这比访问 CPU 寄存器<strong class=chinese>更昂贵</strong>。</li>
<li><code>volatile</code> 还会阻止指令重排序，而指令重排序是<strong class=chinese>常见的性能增强技术</strong>。</li>
<li>因此，应该<strong class=chinese>只在真正需要强制变量可见性时</strong>才使用 <code>volatile</code> 变量，以避免不必要的同步开销。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">UnsafeCounter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 即使使用了 volatile，也无法保证正确性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">increment</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">count</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="c1">// 这不是原子操作！它包含三步：</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                 </span><span class="c1">// 1. 读取 count 的值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                 </span><span class="c1">// 2. 将值加 1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                 </span><span class="c1">// 3. 写入新值</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getCount</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><table>
  <thead>
      <tr>
          <th style="text-align: left">特性</th>
          <th style="text-align: left"><code>volatile</code></th>
          <th style="text-align: left"><code>synchronized</code></th>
          <th style="text-align: left"><code>AtomicInteger</code> (原子类)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong class=chinese>保证可见性</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>保证有序性</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong> (禁止重排序)</td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>保证原子性</strong></td>
          <td style="text-align: left">❌ <strong class=chinese>否</strong> (仅限单次读/写)</td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong> (代码块)</td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong> (特定操作)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>互斥/阻塞</strong></td>
          <td style="text-align: left">❌ <strong class=chinese>否</strong> (非阻塞)</td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong> (阻塞)</td>
          <td style="text-align: left">❌ <strong class=chinese>否</strong> (非阻塞，CAS)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>性能开销</strong></td>
          <td style="text-align: left">较低</td>
          <td style="text-align: left">较高</td>
          <td style="text-align: left">较低 (通常优于 <code>volatile</code>)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>适用场景</strong></td>
          <td style="text-align: left">状态标志、单写多读</td>
          <td style="text-align: left">复杂同步逻辑、临界区保护</td>
          <td style="text-align: left">计数器、累加等复合操作</td>
      </tr>
  </tbody>
</table>
<hr>
<p><code>synchronized</code> 关键字是 Java 并发编程的基石，它提供了一种强大而直接的同步机制。它就像是为一间“共享资源室”配备的“唯一钥匙”<strong>，专门用于解决多线程环境下的</strong>原子性、可见性和有序性<strong>问题，其核心是</strong>互斥访问。</p>
<hr>
<h2 id="一-synchronized-的含义及在-java-中的作用">一、 <code>synchronized</code> 的含义及在 Java 中的作用</h2>
<h3 id="1-意思">1. 意思</h3>
<p><code>synchronized</code> 的字面意思是“同步的”。在 Java 中，它用于确保一段代码或一个方法在同一时刻<strong class=chinese>最多只有一个线程</strong>能执行它。</p>
<h3 id="2-它在-java-中干什么核心机制-1">2. 它在 Java 中干什么（核心机制）</h3>
<p><code>synchronized</code> 的核心作用是实现<strong class=chinese>线程间的互斥</strong>，它通过一个叫做<strong class=chinese>监视器锁</strong> 的东西来实现。</p>
<ul>
<li><strong class=chinese>监视器锁</strong>：每个 Java 对象都可以作为一个锁，这个锁就是对象的内置锁或监视器锁。当线程试图进入一个被 <code>synchronized</code> 保护的代码块时，它必须先获取该代码块所关联对象的锁。</li>
<li><strong class=chinese>锁的获取与释放</strong>：
<ul>
<li><strong class=chinese>获取锁</strong>：如果锁未被其他线程持有，当前线程会获取锁并进入代码块执行。</li>
<li><strong class=chinese>阻塞等待</strong>：如果锁已被其他线程持有，当前线程将被<strong class=chinese>阻塞</strong>，并进入锁的等待队列，直到锁被释放。</li>
<li><strong class=chinese>释放锁</strong>：当线程执行完 <code>synchronized</code> 代码块或方法，或者在代码块中抛出异常时，锁会自动被释放。</li>
</ul>
</li>
</ul>
<h2 id="二-synchronized-保证了什么核心承诺">二、 <code>synchronized</code> 保证了什么？（核心承诺）</h2>
<p><code>synchronized</code> 关键字提供了三大核心保证，比 <code>volatile</code> 更为强大。</p>
<h3 id="1-原子性">1. 原子性</h3>
<p>这是 <code>synchronized</code> 最核心的保证。</p>
<ul>
<li><strong class=chinese>互斥执行</strong>：<code>synchronized</code> 确保被它保护的代码块（临界区）是<strong class=chinese>原子的</strong>。一个线程一旦进入该代码块，在它退出之前，其他任何线程都无法进入。这从根本上杜绝了竞态条件。</li>
<li><strong class=chinese>类比</strong>：就像一个只有一把钥匙的洗手间。一个人进去后锁上门（获取锁），在里面无论待多久，外面的人都只能排队等待（阻塞）。直到他出来并交出钥匙（释放锁），下一个人才能进去。</li>
</ul>
<h3 id="2-内存可见性">2. 内存可见性</h3>
<p><code>volatile</code> 保证可见性，<code>synchronized</code> 同样保证，而且更强。</p>
<ul>
<li><strong>Happens-Before 保证</strong>：[[Java/Concurrency/JMM|JMM]] 规定，对一个锁的<strong>解锁操作 [[Java/Concurrency/JMM#^444be5|Happens-Before]] 后面对同一个锁的加锁操作</strong>。</li>
<li><strong class=chinese>强制刷新</strong>：这意味着，当线程 A 释放锁时，[[Java/Concurrency/JMM|JMM]] 会强制将该线程工作内存中的所有共享变量的最新值<strong class=chinese>刷新到主内存</strong>。而当线程 B 随后获取同一个锁时，[[Java/Concurrency/JMM|JMM]] 会强制将该线程的工作内存置为无效，使其必须<strong class=chinese>从主内存中重新读取</strong>所有共享变量的值。</li>
<li><strong class=chinese>效果</strong>：这确保了前一个线程对共享变量的修改，对后一个获取锁的线程是立即可见的。</li>
</ul>
<h3 id="3-有序性">3. 有序性</h3>
<p><code>volatile</code> 通过内存屏障禁止指令重排，<code>synchronized</code> 通过其“原子性”隐式地保证了有序性。</p>
<ul>
<li><strong class=chinese>隐式保证</strong>：由于 <code>synchronized</code> 块内的代码与块外的代码是互斥执行的，一个线程在 <code>synchronized</code> 块内观察到的状态，一定是另一个线程在之前或之后同步块内操作的结果。[[Java/Concurrency/JMM|JMM]] 可以在保证最终结果正确性的前提下，对 <code>synchronized</code> 块内的代码进行重排序，但它绝不会允许块内的代码“[[Runtime Data Area#Escape|逃逸]]”到块外，从而破坏整体的同步语义。</li>
</ul>
<h3 id="4-可重入性">4. 可重入性</h3>
<p>这是 <code>synchronized</code> 一个非常重要的特性。</p>
<ul>
<li><strong class=chinese>定义</strong>：一个已经获取到锁的线程，可以<strong class=chinese>再次进入</strong>由它自己持有的锁所保护的任何代码块，而不会造成死锁。</li>
<li><strong class=chinese>机制</strong>：JVM 会为每个锁关联一个持有计数器和一个持有线程。当一个线程获取锁时，计数器加一。当同一线程再次获取时，计数器再次加一。当线程退出同步块时，计数器减一。直到计数器为 0 时，锁才被真正释放。</li>
<li><strong class=chinese>意义</strong>：可重入性极大地简化了代码编写，避免了因在同步方法中调用另一个同步方法而导致的自我死锁。</li>
</ul>
<h2 id="三-什么时候使用-synchronized适用场景">三、 什么时候使用 <code>synchronized</code>？（适用场景）</h2>
<p><code>synchronized</code> 是一个重量级的同步工具，适用于需要强一致性保证的场景。</p>
<ol>
<li><strong class=chinese>保护临界区</strong>：当多个线程需要访问和修改<strong class=chinese>共享资源</strong>（如共享的数据结构、文件、设备等）时，必须使用 <code>synchronized</code> 来保护访问这些资源的代码块。</li>
<li><strong class=chinese>保证复合操作的原子性</strong>：对于像 <code>check-then-act</code>（检查再操作，如单例模式的懒加载）或 <code>read-modify-write</code>（读取再修改，如 <code>i++</code>）这样的复合操作，<code>volatile</code> 无能为力，<code>synchronized</code> 是最直接的解决方案。</li>
<li><strong class=chinese>实现简单的线程安全类</strong>：在创建自定义的线程安全容器或工具类时，<code>synchronized</code> 是最基础、最可靠的实现手段。</li>
</ol>
<h3 id="三种使用方式"><strong class=chinese>三种使用方式</strong></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MySynchronizedClass</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1. 修饰实例方法，锁是当前实例对象 (this)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">instanceMethod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 临界区代码</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Instance method. Lock on: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">this</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 2. 修饰静态方法，锁是当前类的 Class 对象 (MySynchronizedClass.class)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">staticMethod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 临界区代码</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Static method. Lock on: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">MySynchronizedClass</span><span class="p">.</span><span class="na">class</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">lockObject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span><span class="w"> </span><span class="c1">// 专用锁对象</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">blockMethod</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 3. 修饰代码块，锁是指定的对象 (lockObject)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">lockObject</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 临界区代码</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Code block. Lock on: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">lockObject</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="四-什么时候不使用-synchronized局限性与替代方案">四、 什么时候不使用 <code>synchronized</code>？（局限性与替代方案）</h2>
<p><code>synchronized</code> 虽然强大，但其“重量级”的特性也带来了局限。</p>
<h3 id="1-性能开销">1. 性能开销</h3>
<ul>
<li><strong class=chinese>线程阻塞与上下文切换</strong>：当锁竞争激烈时，无法获取锁的线程会被阻塞，涉及从用户态到内核态的切换，这是一个<strong class=chinese>非常昂贵的操作</strong>。</li>
<li><strong class=chinese>性能瓶颈</strong>：在高并发场景下，<code>synchronized</code> 容易成为系统的性能瓶颈。</li>
</ul>
<h3 id="2-灵活性不足">2. 灵活性不足</h3>
<ul>
<li><strong class=chinese>不可中断</strong>：一个线程在等待获取 <code>synchronized</code> 锁时，不能被中断。</li>
<li><strong class=chinese>无法设置超时</strong>：无法设置一个线程等待锁的最长时间。</li>
<li><strong class=chinese>非公平锁</strong>：<code>synchronized</code> 是非公平的，即等待时间长的线程不一定能优先获取锁。</li>
</ul>
<h3 id="3-替代方案">3. 替代方案</h3>
<p>为了克服 <code>synchronized</code> 的局限性，Java 提供了更灵活、更高效的并发工具。</p>
<ul>
<li><strong><code>volatile</code></strong>：当只需要保证可见性和有序性，而不需要互斥访问时，<code>volatile</code> 是更轻量级的选择。</li>
<li><strong><code>java.util.concurrent.atomic</code> 包</strong>：对于单个变量的原子性复合操作（如计数器），<code>AtomicInteger</code> 等原子类基于 CAS（Compare-And-Swap）操作，通常比 <code>synchronized</code> 性能更好。</li>
<li><strong><code>java.util.concurrent.locks.Lock</code> 接口</strong>：提供了更高级的锁功能，如可中断的锁获取（<code>lockInterruptibly()</code>）、可超时的锁获取（<code>tryLock()</code>）和公平锁（<code>ReentrantLock</code> 的构造函数参数）。它为复杂并发场景提供了更精细的控制。</li>
</ul>
<hr>
<h3 id="核心要点总结一图流"><strong>核心要点总结（一图流）</strong></h3>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特性</th>
          <th style="text-align: left"><code>synchronized</code></th>
          <th style="text-align: left"><code>java.util.concurrent.locks.Lock</code></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong class=chinese>保证原子性</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>保证可见性</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>保证有序性</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>互斥/阻塞</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong> (阻塞)</td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong> (阻塞)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>可重入</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong> (如 <code>ReentrantLock</code>)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>可中断</strong></td>
          <td style="text-align: left">❌ <strong class=chinese>否</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong> (<code>lockInterruptibly()</code>)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>可超时</strong></td>
          <td style="text-align: left">❌ <strong class=chinese>否</strong></td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong> (<code>tryLock()</code>)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>公平性</strong></td>
          <td style="text-align: left">❌ <strong class=chinese>否</strong> (仅非公平)</td>
          <td style="text-align: left">✅ <strong class=chinese>是</strong> (可选公平/非公平)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>使用方式</strong></td>
          <td style="text-align: left">关键字 (JVM 实现，自动释放)</td>
          <td style="text-align: left">接口 (API 调用，需手动 <code>unlock()</code>)</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong class=chinese>性能开销</strong></td>
          <td style="text-align: left">较高 (JDK 6 后大幅优化)</td>
          <td style="text-align: left">通常较低，但依赖具体实现</td>
      </tr>
  </tbody>
</table>

    
  </article>

  <button onclick="topFunction()" id="back-to-top" title="Go to top">Back to Top</button>

  

<div id="sharingbuttons">
    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    
</div>
  <div class="paginator">
    
    <a class="link" href="https://asgpipo.github.io/posts/java/concurrency/%E4%B9%90%E8%A7%82%E9%94%81--%E6%82%B2%E8%A7%82%E9%94%81/" title="乐观锁 &amp; 悲观锁">← prev</a>
    
    
    <a class="link" href="https://asgpipo.github.io/posts/java/concurrency/jmm/" title="JMM">next →</a>
    
  </div>
  <div class="comment">
    
    
    
      <script src="https://giscus.app/client.js"
        data-repo="michaelneuper/website"
        data-repo-id="R_kgDOIjPNaQ"
        data-category="General"
        data-category-id="DIC_kwDOIjPNac4CaklA"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="gruvbox"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
  </script>
  
  </div>
  
  

<aside class="toc-sidebar" data-toc-sidebar>
  <h4 data-toc-toggle>Table of Contents</h4>
  <nav><nav id="TableOfContents">
  <ul>
    <li><a href="#一-volatile-的含义及在-java-中的作用">一、 <code>volatile</code> 的含义及在 Java 中的作用</a>
      <ul>
        <li><a href="#1-单词的意思literal-meaning">1. 单词的意思（Literal Meaning）</a></li>
        <li><a href="#2-它在-java-中干什么核心机制">2. 它在 Java 中干什么（核心机制）</a></li>
      </ul>
    </li>
    <li><a href="#二-volatile-保证了什么核心承诺">二、 <code>volatile</code> 保证了什么？（核心承诺）</a>
      <ul>
        <li><a href="#1-内存可见性visibility-guarantee">1. 内存可见性（Visibility Guarantee）</a></li>
        <li><a href="#2-有序性与-happens-before-关系">2. 有序性与 Happens-Before 关系</a></li>
        <li><a href="#3-对-64-位值操作的原子性保障">3. 对 64 位值操作的原子性保障</a></li>
      </ul>
    </li>
    <li><a href="#三-什么时候使用-volatile适用场景">三、 什么时候使用 <code>volatile</code>？（适用场景）</a></li>
    <li><a href="#四-什么时候不使用-volatile局限性与替代方案">四、 什么时候不使用 <code>volatile</code>？（局限性与替代方案）</a>
      <ul>
        <li><a href="#1-不能保证互斥性mutual-exclusion">1. 不能保证互斥性（Mutual Exclusion）</a></li>
        <li><a href="#2-无法保障复合操作的原子性">2. 无法保障复合操作的原子性</a></li>
        <li><a href="#3-性能考量">3. 性能考量</a></li>
      </ul>
    </li>
    <li><a href="#一-synchronized-的含义及在-java-中的作用">一、 <code>synchronized</code> 的含义及在 Java 中的作用</a>
      <ul>
        <li><a href="#1-意思">1. 意思</a></li>
        <li><a href="#2-它在-java-中干什么核心机制-1">2. 它在 Java 中干什么（核心机制）</a></li>
      </ul>
    </li>
    <li><a href="#二-synchronized-保证了什么核心承诺">二、 <code>synchronized</code> 保证了什么？（核心承诺）</a>
      <ul>
        <li><a href="#1-原子性">1. 原子性</a></li>
        <li><a href="#2-内存可见性">2. 内存可见性</a></li>
        <li><a href="#3-有序性">3. 有序性</a></li>
        <li><a href="#4-可重入性">4. 可重入性</a></li>
      </ul>
    </li>
    <li><a href="#三-什么时候使用-synchronized适用场景">三、 什么时候使用 <code>synchronized</code>？（适用场景）</a>
      <ul>
        <li><a href="#三种使用方式"><strong>三种使用方式</strong></a></li>
      </ul>
    </li>
    <li><a href="#四-什么时候不使用-synchronized局限性与替代方案">四、 什么时候不使用 <code>synchronized</code>？（局限性与替代方案）</a>
      <ul>
        <li><a href="#1-性能开销">1. 性能开销</a></li>
        <li><a href="#2-灵活性不足">2. 灵活性不足</a></li>
        <li><a href="#3-替代方案">3. 替代方案</a></li>
        <li><a href="#核心要点总结一图流"><strong>核心要点总结（一图流）</strong></a></li>
      </ul>
    </li>
  </ul>
</nav></nav>
</aside>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const toc = document.querySelector('nav#TableOfContents');
    const links = toc ? toc.querySelectorAll('a') : [];
    const sections = new Array(links.length);
    
    if (!toc || links.length === 0) return;

    
    links.forEach((link, index) => {
      const href = link.getAttribute('href');
      
      const id = decodeURIComponent(href.substring(1)); 
      const section = document.getElementById(id);
      sections[index] = section;

      
      link.addEventListener('click', (e) => {
        e.preventDefault();
        if (section) {
          section.scrollIntoView({ behavior: 'smooth' });
          history.pushState(null, null, href);
        }
      });
    });

    
    const observerOptions = {
      root: null,
      
      
      threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const id = entry.target.getAttribute('id');
          
          
          links.forEach(link => {
             link.classList.remove('active');
             if(link.parentElement.classList.contains('active')){
                link.parentElement.classList.remove('active');
             }
          });

          
          
          const activeLink = toc.querySelector(`a[href="#${encodeURIComponent(id)}"]`) || 
                             toc.querySelector(`a[href="#${id}"]`); 
          
          if (activeLink) {
            activeLink.classList.add('active');
            
            activeLink.parentElement.classList.add('active');
          }
        }
      });
    }, observerOptions);

    
    sections.forEach(section => {
      if (section) observer.observe(section);
    });

    
    const toggleBtn = document.querySelector('[data-toc-toggle]');
    const sidebar = document.querySelector('[data-toc-sidebar]');
    
    if (toggleBtn && sidebar) {
      toggleBtn.addEventListener('click', () => {
        
        sidebar.classList.toggle('open');
      });
    }

    window.addEventListener('scroll', function() {
      
      if (window.innerWidth <= 1350 && sidebar.classList.contains('open')) {
        sidebar.classList.remove('open');
      }
    });
  });
</script>


  
</main>


    <footer id="footer">
  <div>
    <span>Powered by  <a class=link href=https://gohugo.io target=_blank rel=noopener>Hugo</a> | 
Theme <a class=link href=https://github.com/michaelneuper/hugo-texify3 target=_blank rel=noopener>TeXify3</a>
</span>
  </div>
  <div>
    <span>Copyright © 2026 </span>
  </div>
</footer>

  </div>

  
  <script src='https://asgpipo.github.io/js/script.js' defer></script>

  
  
  <link media="screen" rel="stylesheet" href="https://asgpipo.github.io/css/syntax.css" />
  
  <link media="screen" rel="stylesheet" href="https://asgpipo.github.io/css/scale.css" />
  

  
  

  
  

</body>

</html>
