<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on pipo&#39;s site</title>
    <link>https://asgpipo.github.io/posts/</link>
    <description>Recent content in Posts on pipo&#39;s site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 16 Nov 2025 14:26:35 +0800</lastBuildDate><atom:link href="https://asgpipo.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HashMap</title>
      <link>https://asgpipo.github.io/posts/java/java_base/%E9%9B%86%E5%90%88/test/</link>
      <pubDate>Thu, 06 Nov 2025 15:34:35 +0800</pubDate>
      
      <guid>https://asgpipo.github.io/posts/java/java_base/%E9%9B%86%E5%90%88/test/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;date_creation: 2025-10-13 17:26&lt;/p&gt;
&lt;p&gt;date_modify: 2025-11-16 15:34&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;hashmap&#34;&gt;HashMap&lt;/h1&gt;
&lt;p&gt;HashMap 是 Java 中常用的键值对几何结构，通过生成唯一的 Key 查找和存放删除 Value, 通常查找时间复杂度是 &lt;code&gt;O(1)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;其中通过 Key 来生成 Hash 值选择位置存放,因此 HashMap 的 Key 必须是唯一的,但是 Value 可以重复.&lt;/p&gt;
&lt;h2 id=&#34;hashmap-底层是如何是实现的&#34;&gt;HashMap 底层是如何是实现的?&lt;/h2&gt;
&lt;p&gt;HashMap 在底层是通过数组+链表+红黑树的形式实现的.&lt;/p&gt;
&lt;p&gt;在 JDK 1.7 之前 只由 数组+链表实现.&lt;/p&gt;
&lt;h3 id=&#34;哈希&#34;&gt;哈希&lt;/h3&gt;
&lt;h4 id=&#34;jdk-17--18-是如何计算哈希的&#34;&gt;JDK 1.7 &amp;amp; 1.8 是如何计算哈希的?&lt;/h4&gt;
&lt;p&gt;使用**扰动函数 (spreading function)**的目的是为了防止键的 &lt;code&gt;hashCode()&lt;/code&gt; 方法实现较差，导致大量哈希冲突，从而提高键值对在数组中的分散性.&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;JDK 1.7 &lt;code&gt;hash(int h)&lt;/code&gt;&lt;/th&gt;
          &lt;th&gt;JDK 1.8 &lt;code&gt;hash(Object key)&lt;/code&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;函数体&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;多次位移和异或操作，扰动 4 次。&lt;/td&gt;
          &lt;td&gt;键的哈希值与自身无符号右移 16 位的值进行异或。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;代码&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;h ^= (h &amp;gt;&amp;gt;&amp;gt; 20) ^ (h &amp;gt;&amp;gt;&amp;gt; 12); return h ^ (h &amp;gt;&amp;gt;&amp;gt; 7) ^ (h &amp;gt;&amp;gt;&amp;gt; 4);&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;(h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;性能/复杂度&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;性能稍差一点点，因为扰动了 4 次。&lt;/td&gt;
          &lt;td&gt;更加简化，但原理不变，通过高位低位异或分散性更好。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;高位低位哈希（扰动）的作用：&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;HashMap&lt;/code&gt; 的数组长度 &lt;em&gt;N&lt;/em&gt; 总是 &lt;strong&gt;2 的幂次方&lt;/strong&gt;，计算索引时使用的是 &lt;strong&gt;位运算&lt;/strong&gt;：&lt;code&gt;index = (N - 1) &amp;amp; hash&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当 &lt;em&gt;N&lt;/em&gt; 较小（例如 16）时，&lt;em&gt;N&lt;/em&gt;−1 的二进制只有低 4 位是 1，这意味着只有哈希值的&lt;strong&gt;低位&lt;/strong&gt;参与了索引计算。如果键的哈希值只有高位不同，低位相同，它们会映射到同一个桶，造成冲突。&lt;/p&gt;
&lt;p&gt;JDK 1.8 的扰动函数 &lt;code&gt;(h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)&lt;/code&gt; 解决了这个问题：&lt;/p&gt;
&lt;p&gt;• 它将哈希值的高 16 位（即 &lt;em&gt;h&lt;/em&gt;&amp;raquo;&amp;gt;16）与原哈希值 &lt;em&gt;h&lt;/em&gt; 进行 &lt;strong&gt;异或&lt;/strong&gt; (&lt;code&gt;^&lt;/code&gt;) 运算。&lt;/p&gt;
&lt;p&gt;• 这样，哈希值的高位信息也能够影响最终的低位，从而增加了哈希值在低位上的随机性，&lt;strong&gt;减少了哈希冲突的概率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么容量选择 2 的幂？非 2 的幂会怎样？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 总是使用 &lt;strong&gt;2 的幂&lt;/strong&gt;作为哈希表的大小（容量）。&lt;/p&gt;
&lt;h4 id=&#34;为什么容量总是-2-的幂&#34;&gt;为什么容量总是 2 的幂？&lt;/h4&gt;
&lt;p&gt;选择 2 的幂的主要原因是为了高效地计算元素在数组中的位置（索引）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;位运算替代取模：&lt;/strong&gt; 如果容量 &lt;em&gt;N&lt;/em&gt; 是 2 的幂（例如 16=24），那么计算索引 &lt;code&gt;index = hash % N&lt;/code&gt; 就可以通过效率更高的 &lt;strong&gt;位运算&lt;/strong&gt; 来实现：&lt;code&gt;index = (N - 1) &amp;amp; hash&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率高：&lt;/strong&gt; 位运算比传统的取模运算 (&lt;code&gt;%&lt;/code&gt;) 速度快得多。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;掩码有效性：&lt;/strong&gt; 当 &lt;em&gt;N&lt;/em&gt; 是 2 的幂时，&lt;em&gt;N&lt;/em&gt;−1 的二进制表示是全 1，作为掩码能够最大限度地利用哈希值的所有低位，减少碰撞。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;如果容量不是 2 的幂会怎样&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;如果传入的 &lt;code&gt;initialCapacity&lt;/code&gt; 不是 2 的幂，它会被立即通过 &lt;code&gt;tableSizeFor&lt;/code&gt; &lt;strong&gt;调整为最接近且大于或等于它的 2 的幂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果容量 &lt;em&gt;N&lt;/em&gt; 不是 2 的幂（例如 &lt;em&gt;N&lt;/em&gt;=10），那么 &lt;em&gt;N&lt;/em&gt;−1=9 (二进制为 &lt;code&gt;1001&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;• 此时，使用 &lt;code&gt;(N - 1) &amp;amp; hash&lt;/code&gt; 进行索引计算时，&lt;strong&gt;某些哈希位永远不会被使用&lt;/strong&gt;（例如第 2 位和第 4 位），这会导致哈希值不能均匀地分布在所有桶中，从而&lt;strong&gt;加剧哈希冲突&lt;/strong&gt; 并降低性能。&lt;/p&gt;
&lt;h3 id=&#34;树&#34;&gt;树&lt;/h3&gt;
&lt;h4 id=&#34;为什么要-在-17-之后加入红黑树&#34;&gt;为什么要 在 1.7 之后加入红黑树?&lt;/h4&gt;
&lt;p&gt;因为大量元素插入 HashMap 之后可能会出现 Hash 冲突,而 Java 中解决 Hash 冲突的方式是&lt;strong&gt;链式地址法.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../../../../pics/Java/hash_table_chaining.png&#34; alt=&#34;链式地址哈希表&#34;&gt;&lt;/p&gt;
&lt;p&gt;当发生冲突后(即 Hash 值相同时),会在这个数组位置后加入一个节点,形成链表.&lt;/p&gt;
&lt;p&gt;当形成&lt;strong&gt;长链表之后再去查找某个元素此时时间复杂度就会退化为&lt;code&gt;O(n)&lt;/code&gt;&lt;/strong&gt;,因此需要新的数据结构引入来缓解这种情况.&lt;/p&gt;
&lt;h4 id=&#34;为什么要引入树而不是其他&#34;&gt;为什么要引入树而不是其他?&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;为什么要引入红黑树,而不是B+树或者AVL树?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在多种自平衡二叉树中，&lt;code&gt;HashMap&lt;/code&gt; 最终选择了 &lt;strong&gt;红黑树 (Red-Black Tree)&lt;/strong&gt;，而非严格平衡的 &lt;strong&gt;AVL 树 (AVL Tree)&lt;/strong&gt; 或常用于磁盘存储的 &lt;strong&gt;B+ 树 (B+ Tree)&lt;/strong&gt;，主要是基于内存操作场景下的&lt;strong&gt;插入/删除成本与查询性能之间的权衡&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为什么不是AVL树?&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;特性&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;红黑树&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;AVL 树&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;平衡标准&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;相对宽松&lt;/strong&gt;。最长路径不超过最短路径的 2 倍。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;非常严格&lt;/strong&gt;。任何节点的左右子树高度差不超过 1。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;查找性能&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;略慢于 AVL 树。因为树可能更高。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;理论上更快&lt;/strong&gt;。因为树更矮，查找路径更短。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;插入/删除性能&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;更快&lt;/strong&gt;。因为平衡标准宽松，插入/删除后需要进行的旋转操作次数更少。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;更慢。因为平衡标准严格，插入/删除后可能需要更多的旋转来维持平衡。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;• &lt;strong&gt;AVL 树追求“完全平衡”：&lt;/strong&gt; AVL 树要求任何节点的左右子树高度差不能超过 1。这种严格的平衡状态保证了&lt;strong&gt;极佳的查找性能&lt;/strong&gt;（最坏情况下也是 &lt;code&gt;O(log n)&lt;/code&gt;）。然而，维护这种严格平衡状态的成本很高，&lt;strong&gt;每次插入或删除几乎都会破坏平衡规则&lt;/strong&gt;，需要频繁地通过左旋和右旋进行调整。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;红黑树追求“弱平衡”：&lt;/strong&gt; 红黑树牺牲了对“完全平衡”的追求，转而追求“弱平衡”状态，即&lt;strong&gt;整棵树最长路径不会超过最短路径的 2 倍&lt;/strong&gt;。虽然这略微牺牲了一部分查找性能效率，但它换取了&lt;strong&gt;维持树平衡状态的成本的降低&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;权衡考量：&lt;/strong&gt; 在 &lt;code&gt;HashMap&lt;/code&gt; 这种动态数据结构中，元素的&lt;strong&gt;插入和删除操作相对频繁&lt;/strong&gt;。红黑树在插入、删除等操作时，不像 AVL 树那样频繁地破坏规则，因此&lt;strong&gt;不需要频繁地进行调整&lt;/strong&gt;。这种在维护成本上的优势，使得红黑树在 &lt;code&gt;HashMap&lt;/code&gt; 这种读写操作都频繁的场景下成为更优的选择。&lt;/p&gt;
&lt;p&gt;2.为什么不是 B+树?&lt;/p&gt;
&lt;p&gt;B+ 树（或更广泛的 B 树）通常设计用于&lt;strong&gt;外部存储（如数据库索引）&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;特性&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;红黑树&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;B+ 树&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;设计目标&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;内存中&lt;/strong&gt;的数据结构。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;磁盘等外部存储&lt;/strong&gt;的数据结构。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;节点结构&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;二叉结构，每个节点最多 2 个子节点。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;多路平衡查找树，每个节点可以有大量子节点（高扇出）。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;数据存储&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;键和值存储在所有节点上。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;所有数据（或指针）都存储在叶子节点，内部节点只存索引。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;树的高度&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;相对较高。&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;非常矮胖（高度极低）。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;• &lt;strong&gt;B+ 树的主要设计目标是减少磁盘 I/O 次数&lt;/strong&gt;。它通过将节点设计为与磁盘页大小匹配的大块，并确保数据只存储在叶子节点，从而优化了数据检索效率。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;HashMap 操作在内存中：&lt;/strong&gt; &lt;code&gt;HashMap&lt;/code&gt; 运行在 Java 虚拟机内存中，&lt;strong&gt;不存在磁盘 I/O 瓶颈&lt;/strong&gt;。在这种场景下，使用 B+ 树这种复杂的、为磁盘操作优化的数据结构是不必要的，并且会带来更大的空间开销（红黑树的节点大小已经是常规节点大小的两倍左右了）。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;应用场景不匹配&lt;/strong&gt;：B+树最大的优势是&lt;strong&gt;范围查询&lt;/strong&gt;和&lt;strong&gt;顺序遍历&lt;/strong&gt;（因为叶子节点是链表连接的）。而 &lt;code&gt;HashMap&lt;/code&gt; 的核心是&lt;strong&gt;通过 key 进行精确的哈希查找&lt;/strong&gt;，完全不需要范围查询的功能。&lt;/p&gt;
&lt;h2 id=&#34;hashmap-的转化&#34;&gt;HashMap 的转化&lt;/h2&gt;
&lt;h3 id=&#34;树化&#34;&gt;树化&lt;/h3&gt;
&lt;h4 id=&#34;hashmap-什么条件下会从链表变成树&#34;&gt;HashMap 什么条件下会从链表变成树?&lt;/h4&gt;
&lt;p&gt;HashMap 在发生较多哈希冲突且单个桶（数组位置）内元素较多时，会将链表转换为红黑树，以提升查询效率。具体条件为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单个桶内节点数&lt;/strong&gt; ≥ 8（TREEIFY_THRESHOLD = 8）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总元素个数&lt;/strong&gt; ≥ 64（MIN_TREEIFY_CAPACITY = 64）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;满足以上两个条件时，HashMap 才会执行树化操作。&lt;/p&gt;
&lt;h4 id=&#34;为什么选择-8-和-64-这两个数字&#34;&gt;为什么选择 8 和 64 这两个数字?&lt;/h4&gt;
&lt;p&gt;这是一个典型的权衡（trade-off）设计：树节点（TreeNode）的大小约为普通链表节点的两倍，且维护红黑树的平衡需要额外资源。因此，不能在冲突较少时就贸然树化，以免浪费内存和性能。阈值的选择基于理想的随机哈希码分布（遵循泊松分布，参数约为 0.5）下的统计概率。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Because&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TreeNodes&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;are&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;about&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;twice&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;the&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;regular&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nodes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;we&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;them&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;only&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;when&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bins&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;contain&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;enough&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nodes&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;warrant&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;use&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;see&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TREEIFY_THRESHOLD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;And&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;when&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;they&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;become&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;too&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;small&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;due&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;removal&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;or&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resizing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;they&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;are&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;converted&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;back&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;plain&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bins&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;In&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;usages&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;with&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;well&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;distributed&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hashCodes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bins&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;are&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rarely&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;used&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Ideally&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;under&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;random&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hashCodes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;the&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frequency&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nodes&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bins&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;follows&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Poisson&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;distribution&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//en.wikipedia.org/wiki/Poisson_distribution) with a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parameter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;about&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;average&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;the&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resizing&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;threshold&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;75&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;although&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;with&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;large&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;variance&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;because&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resizing&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;granularity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Ignoring&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;variance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;the&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;expected&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;occurrences&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;of&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;are&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;非线程安全&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)).&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;The&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;first&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;values&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;are&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;60653066&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;30326533&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;07581633&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;01263606&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;00157952&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;00015795&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;00001316&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;00000094&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;00000006&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;more&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;less&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;than&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ten&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;million&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;为什么是 8 ?&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个桶内节点数达到 8 的概率仅为 &lt;strong&gt;百万分之一&lt;/strong&gt;（约 0.00000006），这表明已发生严重冲突。&lt;/li&gt;
&lt;li&gt;在良好分布的哈希码下，树化极少触发，避免了不必要的资源开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;为什么是 64？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;阈值 8 可能并非纯因冲突严重，还可能源于数组容量过小导致的偶发碰撞。为避免频繁树化（树化后退化回链表的开销较高），HashMap 优先通过扩容解决问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当总容量 &amp;lt; 64 时，即使单个桶节点 ≥ 8，也会先扩容（而非树化）。&lt;/li&gt;
&lt;li&gt;只有容量 ≥ 64 且桶内节点 ≥ 8 时，才真正树化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此设计确保树化仅在**“容量充足但局部冲突极端”**时发生，平衡了性能与资源消耗。&lt;/p&gt;
&lt;h3 id=&#34;链表化&#34;&gt;链表化&lt;/h3&gt;
&lt;h4 id=&#34;什么时候会退回为链表&#34;&gt;什么时候会退回为链表?&lt;/h4&gt;
&lt;p&gt;当桶中节点数≤ 6 时就会退化为链表.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/**  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;UNTREEIFY_THRESHOLD&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;为什么选择单个桶内节点数为-6-时退化&#34;&gt;为什么选择单个桶内节点数为 6 时退化?&lt;/h4&gt;
&lt;p&gt;选择节点数为 6 时链表化主要是为了防止频繁地抖动,如果设置为 7 ,此时桶内有 8 个节点,删除一个元素,退化成链表,再插入一个元素又会树化,为了避免在不同数据结构之间频繁地转化,设置为 6.&lt;/p&gt;
&lt;h2 id=&#34;执行过程&#34;&gt;执行过程&lt;/h2&gt;
&lt;h3 id=&#34;链表扩容&#34;&gt;链表扩容&lt;/h3&gt;
&lt;h4 id=&#34;17-vs-18-扩容时哈希过程&#34;&gt;1.7 vs 1.8 扩容时哈希过程&lt;/h4&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;方面&lt;/th&gt;
          &lt;th&gt;JDK 1.7&lt;/th&gt;
          &lt;th&gt;JDK 1.8&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;重新哈希方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;所有节点需完整重算 &lt;code&gt;hash % Nnew&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;仅检查 &lt;code&gt;(hash &amp;amp; oldCap)&lt;/code&gt;，复用原 hash&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;计算开销&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;高（O(n) 全扫描 + 模运算）&lt;/td&gt;
          &lt;td&gt;低（O(1) 位运算 per 节点）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;风险&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;头插法易死循环&lt;/td&gt;
          &lt;td&gt;尾插法 + 分裂规则，更安全&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;当 &lt;code&gt;HashMap&lt;/code&gt; 容量达到阈值时，会进行扩容（&lt;code&gt;resize&lt;/code&gt;），容量扩大为原来的 &lt;strong&gt;2 倍&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 JDK 1.8 中，扩容时的重新分配节点位置被设计得&lt;strong&gt;非常巧妙和高效&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;由于新容量 Nnew 是旧容量 Nold 的两倍，这意味着 Nnew 的二进制表示比 Nold 多了一个高位 bit（这个 bit 的值就是 Nold）。&lt;/p&gt;
&lt;p&gt;JDK 1.8 利用这个特性来确定节点的新位置：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;判断新增位：&lt;/strong&gt; 算法只需要判断原始哈希值 &lt;code&gt;hash&lt;/code&gt; 在新增的那个 &lt;em&gt;bit&lt;/em&gt; 位置上是 0 还是 1。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;◦ 通过计算 &lt;code&gt;(e.hash &amp;amp; oldCap)&lt;/code&gt; 来判断这个新增的位。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;位置规则：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;◦ 如果 &lt;code&gt;(e.hash &amp;amp; oldCap) == 0&lt;/code&gt;，则新索引位置&lt;strong&gt;不变&lt;/strong&gt;（&lt;code&gt;index = 原索引&lt;/code&gt;）。这些节点被归类到 &lt;code&gt;loHead&lt;/code&gt; 链表/子树中。&lt;/p&gt;
&lt;p&gt;◦ 如果 &lt;code&gt;(e.hash &amp;amp; oldCap) != 0&lt;/code&gt;，则新索引位置为 &lt;strong&gt;原索引 + 旧容量&lt;/strong&gt;（&lt;code&gt;index = 原索引 + oldCap&lt;/code&gt;）。这些节点被归类到 &lt;code&gt;hiHead&lt;/code&gt; 链表/子树中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优势：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;减少计算：&lt;/strong&gt; 避免了重新对所有键计算完整的哈希值和索引。&lt;/p&gt;
&lt;p&gt;• &lt;strong&gt;均匀分散：&lt;/strong&gt; 由于新增的 &lt;em&gt;bit&lt;/em&gt; 是随机的，它能均匀地将原来冲突的节点分散到新的两个桶中（原索引和原索引 + 旧容量），从而有效地减少了哈希冲突&lt;/p&gt;
&lt;h4 id=&#34;为什么-18-改为了尾插法&#34;&gt;为什么 1.8 改为了尾插法?&lt;/h4&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;JDK 1.7 (HashMap)&lt;/th&gt;
          &lt;th&gt;JDK 1.8 (HashMap)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;插入方法&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;头插法&lt;/strong&gt; (Add to Head)。新元素插入到链表头部，作为新的头节点。&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;尾插法&lt;/strong&gt; (Add to Tail)。新元素插入到链表的尾部。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;插入快，但扩容时&lt;strong&gt;顺序反转&lt;/strong&gt;。&lt;/td&gt;
          &lt;td&gt;维持链表元素的相对顺序，防止线程安全问题。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;多线程问题&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;不安全&lt;/strong&gt;。在多线程环境下，扩容时可能导致链表形成&lt;strong&gt;环形链表&lt;/strong&gt;（死循环），从而使 &lt;code&gt;get&lt;/code&gt; 操作陷入无限循环。&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;安全&lt;/strong&gt;。解决了环形链表的问题，但在多线程下仍可能存在数据覆盖（&lt;strong&gt;非线程安全&lt;/strong&gt;）。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; JDK 1.8 采用尾插法的主要原因是解决了 JDK 1.7 在多线程竞争扩容时，链表节点指针错乱，导致产生&lt;strong&gt;死循环&lt;/strong&gt;的严重线程安全问题。&lt;/p&gt;
&lt;h3 id=&#34;一条-k-v-插入的流程&#34;&gt;一条 K-V 插入的流程&lt;/h3&gt;
&lt;div class=&#34;mermaid&#34;&gt;flowchart TD
    A[&#34;开始: put(K key, V value)&#34;] --&gt; B[&#34;计算哈希值: hash = hash(key) 扰动函数&#34;]
    B --&gt; C[&#34;初始化/扩容检查: table == null 或 size == 0?&#34;]
    C --&gt;|是| D[&#34;resize(): 初始化容量 16 或指定容量&#34;]
    C --&gt;|否| E[&#34;计算索引: i = (N-1) &amp; hash&#34;]
    D --&gt; E
    E --&gt; F[&#34;检查 table[i] == null?&#34;]
    F --&gt;|是: 空桶| G[&#34;创建新 Node 并插入 table[i]&#34;]
    F --&gt;|否: 非空桶| H[&#34;检查头节点 hash &amp; key 相同?&#34;]
    G --&gt; Z[&#34;值覆盖? 无, 新增 size++&#34;]
    H --&gt;|是| I[&#34;找到 e, 准备覆盖值&#34;]
    H --&gt;|否| J[&#34;头节点是 TreeNode?&#34;]
    J --&gt;|是: 红黑树| K[&#34;putTreeVal: 树中插入/更新&#34;]
    J --&gt;|否: 链表| L[&#34;遍历链表: 尾插法&#34;]
    L --&gt; M[&#34;遍历中找到相同 hash &amp; key 的 e?&#34;]
    M --&gt;|是| I
    M --&gt;|否| N[&#34;插入到链表尾部&#34;]
    N --&gt; O[&#34;检查链表长度 binCount &gt;= 8?&#34;]
    O --&gt;|是| P[&#34;treeifyBin(): 容量 &lt; 64? 先扩容, 否则树化&#34;]
    O --&gt;|否| Q[&#34;无操作&#34;]
    P --&gt; R[&#34;树化完成&#34;]
    K --&gt; R
    I --&gt; S[&#34;替换 e.value = value, 返回旧值&#34;]
    S --&gt; Z
    R --&gt; Z
    Q --&gt; Z
    Z[&#34;modCount++, size++ 检查阈值&#34;] --&gt; T[&#34;size &gt; threshold?&#34;]
    T --&gt;|是: 负载因子超| U[&#34;resize(): 扩容 2倍&#34;]
    T --&gt;|否| V[&#34;结束: 返回 null 或旧值&#34;]
    U --&gt; V
    style A fill:#e1f5fe
    style V fill:#c8e6c9
&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;计算哈希值：&lt;/strong&gt; 调用 &lt;code&gt;hash(key)&lt;/code&gt; 方法（扰动函数）计算键的哈希值 &lt;code&gt;hash&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化/扩容检查 (Resize)：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;◦ 检查哈希表数组 &lt;code&gt;table&lt;/code&gt; 是否为 &lt;code&gt;null&lt;/code&gt; 或长度为 0。&lt;/p&gt;
&lt;p&gt;◦ 如果是，调用 &lt;code&gt;resize()&lt;/code&gt; 方法进行&lt;strong&gt;初始化&lt;/strong&gt;（分配默认容量 16，或使用构造函数指定的初始容量）。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;strong&gt;确定索引位置：&lt;/strong&gt; 根据哈希值和当前数组长度 &lt;em&gt;N&lt;/em&gt;，计算元素在数组中的索引 &lt;code&gt;i = (N - 1) &amp;amp; hash&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空桶处理 (直接插入)：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;◦ 如果 &lt;code&gt;table[i]&lt;/code&gt; 处为 &lt;code&gt;null&lt;/code&gt; (空桶)，则直接在该位置创建新的 &lt;code&gt;Node&lt;/code&gt; 节点并插入。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;strong&gt;非空桶处理 (哈希冲突)：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;◦ &lt;strong&gt;快速检查头节点：&lt;/strong&gt; 检查 &lt;code&gt;table[i]&lt;/code&gt; 处的头节点的 &lt;code&gt;hash&lt;/code&gt; 值和 &lt;code&gt;key&lt;/code&gt; 是否与待插入的键值相同。如果相同，则找到目标节点 &lt;code&gt;e&lt;/code&gt;，准备进行值覆盖。&lt;/p&gt;
&lt;p&gt;◦ &lt;strong&gt;红黑树处理：&lt;/strong&gt; 如果头节点是 &lt;code&gt;TreeNode&lt;/code&gt; 实例，说明该桶已树化。调用红黑树的 &lt;code&gt;putTreeVal&lt;/code&gt; 方法在树中插入/更新元素。&lt;/p&gt;
&lt;p&gt;◦ &lt;strong&gt;链表处理：&lt;/strong&gt; 否则，遍历链表。&lt;/p&gt;
&lt;p&gt;​    ▪ 使用 &lt;strong&gt;尾插法&lt;/strong&gt;：遍历到链表末尾，将新节点插入到链表的尾部。&lt;/p&gt;
&lt;p&gt;​    ▪ &lt;strong&gt;查找重复键：&lt;/strong&gt; 在遍历过程中，如果找到相同 &lt;code&gt;hash&lt;/code&gt; 和 &lt;code&gt;key&lt;/code&gt; 的节点 &lt;code&gt;e&lt;/code&gt;，则跳出循环，准备进行值覆盖。&lt;/p&gt;
&lt;p&gt;​    ▪ &lt;strong&gt;树化判断：&lt;/strong&gt; 节点插入后，检查当前链表长度 &lt;code&gt;binCount&lt;/code&gt;。如果链表长度达到 &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; (默认 &lt;strong&gt;8&lt;/strong&gt;)，会调用 &lt;code&gt;treeifyBin()&lt;/code&gt; 方法。该方法会进一步判断：如果数组容量小于 &lt;code&gt;MIN_TREEIFY_CAPACITY&lt;/code&gt; (默认 &lt;strong&gt;64&lt;/strong&gt;)，则先进行&lt;strong&gt;扩容&lt;/strong&gt;，而不是直接树化。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;&lt;strong&gt;值覆盖：&lt;/strong&gt; 如果步骤 5 中找到了相同键的节点 &lt;code&gt;e&lt;/code&gt;，则用新值替换旧值，并返回旧值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩容检查 (Load Factor)：&lt;/strong&gt; 增加 &lt;code&gt;modCount&lt;/code&gt; (修改次数)。如果 &lt;code&gt;size&lt;/code&gt; 增加后超过了 &lt;code&gt;threshold&lt;/code&gt; (容量 × 负载因子)，则调用 &lt;code&gt;resize()&lt;/code&gt; 方法进行&lt;strong&gt;扩容&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>索引</title>
      <link>https://asgpipo.github.io/posts/mysql/%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Thu, 23 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/mysql/%E7%B4%A2%E5%BC%95/</guid>
      <description>&lt;h2 id=&#34;索引简介&#34;&gt;索引简介&lt;/h2&gt;
&lt;h3 id=&#34;concept&#34;&gt;Concept&lt;/h3&gt;
&lt;h4 id=&#34;index-是什么&#34;&gt;Index 是什么&lt;/h4&gt;
&lt;p&gt;Index 是一种数据结构,用于加速查找和快速定位数据,.&lt;/p&gt;
&lt;h4 id=&#34;为什么需要-index&#34;&gt;为什么需要 Index&lt;/h4&gt;
&lt;p&gt;传统数据库中进行查找时往往需要在全表全库中进行查找, Index 可以帮助快速定位表,行所在的位置,避免全表查找减少硬盘IO.&lt;/p&gt;
&lt;h3 id=&#34;contrast&#34;&gt;Contrast&lt;/h3&gt;
&lt;h4 id=&#34;有哪些不同实现的-index&#34;&gt;有哪些不同实现的 Index&lt;/h4&gt;
&lt;p&gt;Index有不同的数据结构,如 B+树, Hash索引, 全文索引. 在 InnoDB 中使用 B+树进行索引.&lt;/p&gt;
&lt;h3 id=&#34;context&#34;&gt;Context&lt;/h3&gt;
&lt;h4 id=&#34;如何使用和创建索引&#34;&gt;如何使用和创建索引&lt;/h4&gt;
&lt;p&gt;当创建好索引之后,只要进行&lt;strong&gt;等值查询&lt;/strong&gt; (&lt;code&gt;=&lt;/code&gt; , &lt;code&gt;IN()&lt;/code&gt;,  &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;) 时索引在查询条件的左侧,即可自动使用索引.&lt;/p&gt;
&lt;p&gt;创建索引:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接创建 &lt;code&gt;CREATE INDEX index_name ON table_name (key1, key2, ...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改表时创建 &lt;code&gt;ALTER TABLE users ADD INDEX idx_email (email);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;建表时创建&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;products&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;INT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;PRIMARY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;KEY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;VARCHAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;INDEX&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;idx_name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;什么时候需要索引&#34;&gt;什么时候需要索引&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当前数据具有&lt;strong&gt;唯一性&lt;/strong&gt;可以当成主键.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当某些数据段的查询十分频繁时可以考虑添加索引.即经常出现在 &lt;strong&gt;&lt;code&gt;WHERE&lt;/code&gt; 和 &lt;code&gt;JOIN&lt;/code&gt;&lt;/strong&gt; 条件里.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当前数据需要频繁排序(&lt;strong&gt;&lt;code&gt;GROUP BY&lt;/code&gt; 和 &lt;code&gt;ORDER BY&lt;/code&gt;&lt;/strong&gt;) 时添加索引后就不再需要每次重排序.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;索引的不同分类&#34;&gt;索引的不同分类&lt;/h2&gt;
&lt;h3 id=&#34;索引的不同分类-1&#34;&gt;索引的不同分类&lt;/h3&gt;
&lt;p&gt;按不同方法分,索引可以分一下几种:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Clustered 与 Secondary&lt;/li&gt;
&lt;li&gt;B+树索引 哈希索引 全文索引&lt;/li&gt;
&lt;li&gt;主键索引 唯一索引 前缀索引 普通索引&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;clustered-与-secondary&#34;&gt;Clustered 与 Secondary&lt;/h4&gt;
&lt;p&gt;在InnoDB 中 每创建一个表都会自动创建一个 Clustered 索引,在没有创建其他索引前提下所有查找都通过 Clustered进行查找.&lt;/p&gt;
&lt;p&gt;Secondary 是用户自己创建的 非主索引(二级索引)&lt;/p&gt;
&lt;h4 id=&#34;哈希索引-b树索引&#34;&gt;哈希索引 B+树索引&lt;/h4&gt;
&lt;h5 id=&#34;哈希索引&#34;&gt;哈希索引&lt;/h5&gt;
&lt;p&gt;通过哈希函数无序地将数据一一对应起来,因此哈希函数在等值查找时速度极佳 &lt;code&gt;O(1)&lt;/code&gt; 但是因为哈希表的无序型使得 哈希索引无法进行范围查询.&lt;/p&gt;
&lt;p&gt;优点: 速度快 占用内存小&lt;/p&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不支持范围查询 模糊查询&lt;/li&gt;
&lt;li&gt;无法进行排序&lt;/li&gt;
&lt;li&gt;可能会发生哈希冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;b-树索引&#34;&gt;B+ 树索引&lt;/h5&gt;
&lt;p&gt;通过树结构将 从小到大 为 index 安排位置形成有序的树结构. 非子叶节点不存放数据,最后一层子叶节点从小到大进行排列,以链表形式彼此连接&lt;/p&gt;
&lt;p&gt;优点 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持范围查询 模糊查询&lt;/li&gt;
&lt;li&gt;支持最左前缀匹配&lt;/li&gt;
&lt;li&gt;可以进行排序&lt;/li&gt;
&lt;li&gt;低层级树减少磁盘 IO&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护树需要消耗更多资源&lt;/li&gt;
&lt;li&gt;速度相对哈希较慢 &lt;code&gt;O(lgN)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;contrast-1&#34;&gt;Contrast&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;特性对比&lt;/th&gt;
          &lt;th&gt;Hash 索引&lt;/th&gt;
          &lt;th&gt;B+ 树索引&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;查找速度&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;极快，平均O(1)&lt;/td&gt;
          &lt;td&gt;较快，O(logN)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;存储空间&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;通常较小&lt;/td&gt;
          &lt;td&gt;通常较大&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;支持的查询&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;仅支持等值查询 (=, IN)&lt;/td&gt;
          &lt;td&gt;支持等值、范围 (&amp;gt;, &amp;lt;, BETWEEN)、排序和前缀模糊查询 (LIKE &amp;lsquo;abc%&amp;rsquo;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;哈希冲突&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;存在，需要处理&lt;/td&gt;
          &lt;td&gt;不存在&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;维护成本&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;高 (尤其在数据频繁变更时)&lt;/td&gt;
          &lt;td&gt;高 (需要维护树平衡)&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;索引的创建与使用&#34;&gt;索引的创建与使用&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/index_create_use_mindmap.svg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;索引越多越好吗&#34;&gt;索引越多越好吗&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每一次索引的创建都要构建对应的 B+ 树,会占用一定空间&lt;/li&gt;
&lt;li&gt;索引的更新与维护会占用数据库的资源&lt;/li&gt;
&lt;li&gt;索引创建不合理会导致大量回表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以只有合适数量的索引才能达到最好效果.&lt;/p&gt;
&lt;h3 id=&#34;索引创建应遵循什么原则&#34;&gt;索引创建应遵循什么原则&lt;/h3&gt;
&lt;h4 id=&#34;1-索引创建应该遵循最左前缀原则要把区分度大的字段排在前面这样区分度大的字段越有可能被更多的-sql-使用到&#34;&gt;1. 索引创建应该遵循最左前缀原则,要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sex&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Department&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;张三&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;男&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;软件工程师&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;技术部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;李四&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;女&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;产品经理&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	      &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;产品部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;王五&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;男&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;销售专员&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	      &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;销售部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;赵六&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;女&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;人力资源专员&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;人力资源部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;钱七&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;男&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;财务分析师&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;财务部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;孙八&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;女&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;前端开发工程师&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;技术部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;周九&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;男&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;市场专员&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	      &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;市场部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;吴十&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;女&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;测试工程师&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;技术部&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果我们查找在技术部的测试工程师&amp;quot;吴十&amp;quot;  应该如何创建索引?&lt;/p&gt;
&lt;p&gt;依据最左前缀,我们要由上到下地不断起进行过滤,所以如此安排 (Department, position, name)&lt;/p&gt;
&lt;p&gt;注意, 应尽量&lt;strong&gt;将范围查询和模糊查询靠右放置&lt;/strong&gt;,B+树数据存储节点也是先按最左边第一个字段排序，在第一个字段的排序基础上，然后在对后续字段进行排序.&lt;/p&gt;
&lt;p&gt;![img](/home/pipo/文档/Obsidian Vault/Java/pics/BplusTreeSort.png)&lt;/p&gt;
&lt;h4 id=&#34;2-应选取多读少写的常用的字段组成索引&#34;&gt;2. 应选取多读少写的,常用的字段组成索引&lt;/h4&gt;
&lt;p&gt;选取多读少写的字段,即不更新的字段以避免频繁更新导致的树重建造成的资源浪费.&lt;/p&gt;
&lt;h4 id=&#34;3-应尽量建立覆盖索引减少回表次数&#34;&gt;3. 应尽量建立覆盖索引减少回表次数&lt;/h4&gt;
&lt;p&gt;通过覆盖索引我们只需在 Secondary 索引中查询便可以得到全部所需信息,不需要再次进入 Clusters 索引查找字段.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是覆盖索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;覆盖索引就是指在当前使用索引查询中无需再次回到 Clusters 索引树即可拿到该次查询所需信息的索引.&lt;/p&gt;
&lt;h3 id=&#34;索引如何更新和维护&#34;&gt;索引如何更新和维护?&lt;/h3&gt;
&lt;h4 id=&#34;1-索引更新&#34;&gt;1. &lt;strong&gt;索引更新&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;索引更新通常发生在数据发生变化时，例如插入、删除或修改操作。索引需要相应地进行调整以反映这些变化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;插入数据时&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新记录会根据索引键值插入到索引结构中。例如，在B树索引中，新键值会被插入到适当的位置，可能需要拆分节点以保持树的平衡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;删除数据时&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引中的对应记录会被标记为删除或直接移除。如果删除操作导致节点变得空闲，可能会合并相邻节点以优化空间使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;修改数据时&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果修改了索引键值，索引会进行更新，可能包括删除旧键值并插入新键值。这可能导致索引树的重新平衡。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-索引维护&#34;&gt;2. &lt;strong&gt;索引维护&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;索引维护是为了保持索引的高效性和准确性，通常包括以下操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引重建&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定期重建索引可以优化索引结构，合并碎片，释放空间，提高查询效率。重建索引通常在低峰时段进行，以减少对系统性能的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引优化&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化索引结构，例如重新组织索引节点以减少树的高度，提高查询速度。这可能涉及重新平衡索引树或调整索引参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;清理无用索引&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定期检查索引的使用情况，删除不再使用的索引，以避免占用不必要的存储空间和影响性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;索引碎片整理&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;碎片整理可以减少索引中的碎片，优化存储空间，提高访问效率。对于B树索引，这可能涉及合并相邻的空闲页。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能监控&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监控索引的查询性能和存储使用情况，及时发现索引膨胀或性能下降的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析工具&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用数据库的分析工具（如 &lt;code&gt;EXPLAIN&lt;/code&gt; 语句）来检查查询是否有效利用索引，并根据结果调整索引策略。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;索引什么时候会失效&#34;&gt;索引什么时候会失效&lt;/h3&gt;
&lt;h4 id=&#34;1-用联合索引时加入了范围和模糊查询&#34;&gt;1. 用联合索引时加入了范围和模糊查询&lt;/h4&gt;
&lt;h4 id=&#34;2-索引使用函数或表达式&#34;&gt;2. 索引使用函数或表达式&lt;/h4&gt;
&lt;p&gt;查询语句中，如果对索引字段**使用“函数”或“表达式”，**会导致索引失效。&lt;/p&gt;
&lt;p&gt;因为索引树存储的是索引字段的原始值，因此无法索引经过函数计算或表达式计算后的值。&lt;/p&gt;
&lt;p&gt;❌ 错误示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actor_id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actor&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;actor_id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TO_DAYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;current_date&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TO_DAYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;date_col&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3-对索引隐式类型转换&#34;&gt;3. 对索引隐式类型转换&lt;/h4&gt;
&lt;p&gt;查询语句中，如果对索引字段进行隐式类型转换，会导致索引失效。由于隐式类型转换是通过 &lt;code&gt;CAST&lt;/code&gt; 函数实现的，等同于对索引列使用了函数，所以会导致索引失效。&lt;/p&gt;
&lt;h4 id=&#34;4-联合索引不遵循最左匹配原则&#34;&gt;4. 联合索引不遵循最左匹配原则&lt;/h4&gt;
&lt;p&gt;联合索引如果不遵循最左匹配原则，就会导致索引失效。原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。&lt;/p&gt;
&lt;h4 id=&#34;5-索引列判空&#34;&gt;5. 索引列判空&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;索引列与&lt;/strong&gt; &lt;code&gt;NULL&lt;/code&gt; &lt;strong&gt;或者&lt;/strong&gt; &lt;code&gt;NOT NULL&lt;/code&gt; &lt;strong&gt;进行判断的时候也会失效&lt;/strong&gt;。这是因为索引并不存储空值.&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://juejin.cn/post/7311623433817620517&#34;&gt;理解Mysql索引原理及特性 | 京东物流技术团队&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dunwu.github.io/pages/fcb19c/&#34;&gt;https://dunwu.github.io/pages/fcb19c/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[04 深入浅出索引（上）](&lt;a href=&#34;https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/04&#34;&gt;https://learn.lianglianglee.com/专栏/MySQL实战45讲/04&lt;/a&gt;  深入浅出索引（上）.md)&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;待完成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;索引优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;叶子节点内部查找&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>InnoDB 组成</title>
      <link>https://asgpipo.github.io/posts/mysql/innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Tue, 21 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/mysql/innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description>&lt;h1 id=&#34;innodb-组成&#34;&gt;InnoDB 组成&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/InnoDB_Structure.png&#34; alt=&#34;Mysql 官方图示&#34;&gt;&lt;/p&gt;
&lt;p&gt;内存结构 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buffer Pool&lt;/li&gt;
&lt;li&gt;AHI&lt;/li&gt;
&lt;li&gt;Log Buffer&lt;/li&gt;
&lt;li&gt;Change Buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;硬盘结构:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TableSpace&lt;/li&gt;
&lt;li&gt;Redo Log&lt;/li&gt;
&lt;li&gt;UnDo Log&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;buffer-pool&#34;&gt;Buffer Pool&lt;/h2&gt;
&lt;p&gt;是内存中一块连续的区域,用于缓存表和索引的数据. 用于加速数据访问与读写.&lt;/p&gt;
&lt;h3 id=&#34;page&#34;&gt;Page&lt;/h3&gt;
&lt;p&gt;buffer pool 中存放着 许多 page, 每个 page 记录着表中的数据行（rows）、索引条目（index entries）大小为16kb.
page 中存放的不是整张表 而是多行数据.&lt;/p&gt;
&lt;p&gt;当进行 SQL 查找时（如 SELECT 查询），InnoDB 会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过主键或索引定位到具体的 page（由空间 ID + 页号标识）。&lt;/li&gt;
&lt;li&gt;检查 Buffer Pool 中是否已有该 page（命中率高时，直接从内存返回数据）。&lt;/li&gt;
&lt;li&gt;如果未命中，从磁盘（.ibd 文件）加载整个 16KB page 到 Buffer Pool。&lt;/li&gt;
&lt;li&gt;返回所需数据行，同时将该 page 标记为“活跃”，以便后续快速访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;存储方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个 page 被连接成&lt;strong&gt;双向循环链表&lt;/strong&gt;,并分为两块区域.&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;LRU（Least Recently Used，最近最少使用&lt;/strong&gt;）算法的变体来淘汰不常用的页面.&lt;/li&gt;
&lt;li&gt;新子列表（young sublist）（最近访问的页面）和旧子列表（old sublist）（较少访问的页面）。&lt;/li&gt;
&lt;li&gt;中点（midpoint）：young 和 old 的分界线。新加载的 page 先插入中点（old 的头部），观察其是否被访问。
&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/bufferPoolList.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ahi&#34;&gt;AHI&lt;/h2&gt;
&lt;p&gt;InnoDB 的自适应哈希索引，是一个内置在 Buffer Pool 中的内存哈希表，用于加速等值查找&lt;/p&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;加速查询&lt;/strong&gt;：对于频繁的精确匹配查询，哈希表提供 O(1) 访问速度，比 B+ 树索引的 O(log n) 更快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态构建&lt;/strong&gt;：InnoDB 根据实际查询模式自动创建/删除哈希条目，无需手动配置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：读密集型工作负载，尤其是点查询（point queries），如主键查找或唯一索引等值条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日志系统&#34;&gt;日志系统&lt;/h2&gt;
&lt;p&gt;InnoDB 的事务恢复基于 &lt;strong&gt;WAL&lt;/strong&gt; 技术，采用 &lt;strong&gt;NO-FORCE + STEAL&lt;/strong&gt; 策略，通过 &lt;strong&gt;Redo Log（重做）与 Undo Log（回滚）&lt;strong&gt;来保障事务的&lt;/strong&gt;持久性与原子性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;log-buffer&#34;&gt;Log Buffer&lt;/h3&gt;
&lt;p&gt;Log Buffer（又称 &lt;strong&gt;redo log buffer&lt;/strong&gt;）是 InnoDB 在内存中用于暂存 &lt;strong&gt;redo log&lt;/strong&gt; 记录的区域。当事务修改 Buffer Pool 中的数据页时，InnoDB 会同时生成对应的 redo log（描述该物理修改），并写入 log buffer。随后，这些 redo log 会根据策略（如事务提交、超时或缓冲区满）被刷入磁盘的 redo log 文件。若数据库崩溃，InnoDB 可在重启时通过重放已持久化的 redo log，&lt;strong&gt;恢复那些已提交但尚未写入数据文件的更改&lt;/strong&gt;，从而保证事务的持久性。&lt;/p&gt;
&lt;h3 id=&#34;redo-log&#34;&gt;Redo Log&lt;/h3&gt;
&lt;p&gt;Redo log 是存储在磁盘上的物理日志，用于在数据库崩溃后恢复&lt;strong&gt;已提交事务的持久化状态&lt;/strong&gt;。它以面向存储页的方式记录修改，内容类似于“在表空间某页的偏移 Y 处写入 Z”。崩溃恢复时，InnoDB 先重做所有 redo log 记录，再通过 undo log 回滚未提交的事务，从而保证 ACID。&lt;/p&gt;
&lt;p&gt;Redo Log 是 &lt;strong&gt;WAL&lt;/strong&gt;（Write-Ahead Logging）技术的核心：修改先写日志，再写数据文件，减少随机 I/O，提高性能。&lt;/p&gt;
&lt;p&gt;崩溃恢复时 InnoDB:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重做所有已提交但未持久化的记录&lt;/li&gt;
&lt;li&gt;通过undo log 将 buffer pool 中未提交的事务回滚&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;undo-log&#34;&gt;Undo Log&lt;/h3&gt;
&lt;p&gt;Undo Log 记录了事务对数据修改的“反向操作”，允许其他事务读取未修改的旧版本数据（一致性读），并在事务回滚时恢复数据。他保存了数据的“历史快照”，确保事务的 ACID 属性（原子性、一致性、隔离性、持久性）。&lt;/p&gt;
&lt;p&gt;Undo Log 主要用于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MVCC&lt;/strong&gt;：事务间隔离读，避免锁竞争。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回滚&lt;/strong&gt;：事务失败时撤销修改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;崩溃恢复&lt;/strong&gt;：虽不直接用于恢复，但辅助 purge 操作清理旧数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Undo Log 分为两类：用户表（regular tables）的 Undo Log（需 redo 日志保护，用于崩溃恢复）和临时表（temporary tables）的 Undo Log（仅用于运行时回滚，不生成 redo 日志，提高性能）。&lt;/p&gt;
&lt;p&gt;表空间（&lt;strong&gt;Tablespaces&lt;/strong&gt;）：Undo Log 存储在独立的 Undo Tablespaces（最多 128 个回滚段/表空间）和全局临时表空间（temp tablespace）。每个事务最多分配 4 个 Undo Log（分别处理用户表的 INSERT、UPDATE/DELETE 和临时表的 INSERT、UPDATE/DELETE）。&lt;/p&gt;
&lt;h2 id=&#34;change-buffer&#34;&gt;Change Buffer&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/changeBuffer.png&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;属于 Buffer Pool 的一块内存结构,存储着**二级索引(&lt;strong&gt;非主索引)&lt;strong&gt;发生的变更&lt;/strong&gt;,当二级索引发生更新时如果&lt;/strong&gt;受影响的二级索引页面不在 Buffer Pool 中,**不会立即更新到磁盘中,而是先存储到 Change Buffer &lt;strong&gt;当这个页面因为其他读操作被加载到 Buffer Pool 时&lt;/strong&gt;，这些变更才会“合并”（merge）进去.&lt;/p&gt;
&lt;h2 id=&#34;来源&#34;&gt;来源&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2/02%20%20%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F.md&#34;&gt;02 日志系统：一条SQL更新语句是如何执行的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/&#34;&gt;MySQL 8.0 Reference Manual&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://dunwu.github.io/pages/5fe0f3/&#34;&gt;Mysql 存储引擎 钝悟&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1ve411F794&#34;&gt;5分钟精通MySql的系统框架_哔哩哔哩_bilibili&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据库组成</title>
      <link>https://asgpipo.github.io/posts/mysql/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Tue, 21 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/mysql/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;h1 id=&#34;数据库组成&#34;&gt;数据库组成&lt;/h1&gt;
&lt;p&gt;由 Server 层 + 存储引擎组成.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/DBstructure.png&#34; alt=&#34;数据库组成&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;server-层&#34;&gt;server 层&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;连接器用来维持用户与数据库的连接, 认证, 管理等&lt;/li&gt;
&lt;li&gt;缓存查询,如果当前有之前命令执行的缓存,就会直接返回之前的结果. (MySQL 8.0之后已经移除)&lt;/li&gt;
&lt;li&gt;分析器用来判断当前输入的 SQL 语句是否合法&lt;/li&gt;
&lt;li&gt;优化器会对 SQL 语句选择优化器认为最佳的方案进行执行操作&lt;/li&gt;
&lt;li&gt;执行器执行语句并检查权限&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/InnoDBSimpleStructure.awebp&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/MySQL/InnoDBSimpleStructure.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;查命令&#34;&gt;查命令&lt;/h3&gt;
&lt;p&gt;当 SQL 命令进入存储引擎后 存储引擎会 首先 尝试 AHI 如果命中不查页哈希表
否则进入 页哈希表查看当前 记录所在页是否存在 buffer pool 中
不存在则从本地硬盘读取所在页进入buffer pool&lt;/p&gt;
&lt;h3 id=&#34;更新命令&#34;&gt;更新命令&lt;/h3&gt;
&lt;p&gt;前几步与查命令相同,在修改前会先将当前原始旧数据先写入 Log Buffer 写入 Undo Tablespace,
然后将数据写入 buffer pool 中的 page 同时 将当前数据通过 Log buffer 写入 Redo log, 然后异步更新.&lt;/p&gt;
&lt;h1 id=&#34;来源&#34;&gt;来源&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1ve411F794&#34;&gt;# 5分钟精通MySql的系统框架&lt;/a&gt;
&lt;a href=&#34;https://dunwu.github.io/pages/5fe0f3/&#34;&gt;Mysql 存储引擎 钝悟&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Redis 生产问题</title>
      <link>https://asgpipo.github.io/posts/redis/redis-%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 19 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/redis/redis-%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;h1 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h1&gt;
&lt;p&gt;指使用非法 key 进行请求, 这个 key 不存在于 Redis 缓存和数据库中. 导致数据库一直忙于处理非法 key 的查询请求.&lt;/p&gt;
&lt;h2 id=&#34;1-缓存空值&#34;&gt;1. 缓存空值&lt;/h2&gt;
&lt;p&gt;使用 Redis 缓存空值,将不存在的 key 加入缓存,之后直接在 Redis 被拦截.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点 :实现简单,成本低.&lt;/li&gt;
&lt;li&gt;缺点 : 大量不同非法 key 访问会占用大量 redis 缓存.&lt;/li&gt;
&lt;li&gt;改进: 给空值 key 设置较短的过期时间 或者加入布隆过滤器.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-布隆过滤器&#34;&gt;2. 布隆过滤器&lt;/h2&gt;
&lt;p&gt;使用布隆过滤器首先判断当前请求的数据是否存在, 若不存在直接拦截, &amp;ldquo;存在&amp;quot;后继续交由 redis 进行.
优点: bloomfilter 使用了散列算法&amp;quot;存储&amp;rdquo;,占用空间极小,速度快.
缺点: bloomfilter 会出现假阳性,同时无法删除数据.
改进: 使用 缓存空值兜底,同时定期刷新写入真实的数据.
&lt;img src=&#34;https://asgpipo.github.io/pics/redis/Pasted_image_20251019211336.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;缓存击穿&#34;&gt;缓存击穿&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/redis/Pasted_image_20251020085030.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-分布式锁&#34;&gt;1. 分布式锁&lt;/h2&gt;
&lt;p&gt;通过加入分布式只允许一个线程同时去访问数据库进行缓存重建,其他线程等待缓存好的数据.
步骤:
A. redis 缓存未命中,尝试获取锁
B. 获取锁成功,进行双重检查
C. 查询数据库
D.重新加入 Redis 缓存 (若为空则构造空值)&lt;/p&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导致大量用户被堵塞,体验较差.&lt;/li&gt;
&lt;li&gt;锁竞争激烈时，性能下降&lt;/li&gt;
&lt;li&gt;如果锁未正确释放（如程序崩溃），可能导致死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;改进:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 Redis 的 &lt;code&gt;SET key value NX PX milliseconds&lt;/code&gt; 命令原子操作加锁。&lt;/li&gt;
&lt;li&gt;加锁失败时，&lt;strong&gt;不要无限等待&lt;/strong&gt;，可以返回“稍后再试”或“默认值”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2逻辑过期--异步更新&#34;&gt;2.逻辑过期 + 异步更新&lt;/h2&gt;
&lt;p&gt;在非强一致性场景下,缓存数据时加入逻辑过期时间,若发生过期则先返回旧数据,同时获取分布式锁进行异步更新缓存.
步骤:
A. redis 缓存命中, 但此时逻辑过期
B. 返回旧数据,同时尝试获取锁.
C. 开启子线程,进行双重检查
D. 重构缓存
缺点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复杂度较高, 需要维护逻辑过期字段、异步线程、锁机制&lt;/li&gt;
&lt;li&gt;用户可能无法及时获取到最新数据.&lt;/li&gt;
&lt;li&gt;内存占用略高,因为缓存不会真正过期，除非手动清理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;改进:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对缓存设置较长的过期时间,大于逻辑过期时间.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-缓存预热&#34;&gt;3. 缓存预热&lt;/h2&gt;
&lt;p&gt;针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。&lt;/p&gt;
&lt;h1 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h1&gt;
&lt;p&gt;指缓存内&lt;strong&gt;同时出现大量 key 过期&lt;/strong&gt;或者 &lt;strong&gt;Redis 奔溃重启,没有缓存&lt;/strong&gt;任何key,导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。&lt;/p&gt;
&lt;h2 id=&#34;1-随机过期时间&#34;&gt;1. 随机过期时间&lt;/h2&gt;
&lt;p&gt;通过 在 Redis 重构缓存时在过期时间中加入随机抖动使得过期时间均匀分散,避免了大量 key 同时过期的情况.&lt;/p&gt;
&lt;h2 id=&#34;2-redis-集群&#34;&gt;2. Redis 集群&lt;/h2&gt;
&lt;p&gt;通过构建 Redis 主从架构+哨兵机制实现, 当主节点下线后,哨兵会自动把从节点提升为主节点. 多个节点保证了不会出现缓存全部消失的情况.&lt;/p&gt;
&lt;h2 id=&#34;服务降级--熔断&#34;&gt;**服务降级 &amp;amp; 熔断&lt;/h2&gt;
&lt;p&gt;当数据库压力过大时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;返回&lt;strong&gt;默认值&lt;/strong&gt;（如“系统繁忙，请稍后再试”）。&lt;/li&gt;
&lt;li&gt;启用&lt;strong&gt;本地缓存&lt;/strong&gt;（如 Caffeine）作为二级缓存。&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;限流&lt;/strong&gt;（如 Sentinel、Hystrix）保护数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;3.预热数据&lt;/p&gt;&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Redis RDB &amp; AOF</title>
      <link>https://asgpipo.github.io/posts/redis/rdb--aof/</link>
      <pubDate>Fri, 17 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/redis/rdb--aof/</guid>
      <description>&lt;h1 id=&#34;rdb&#34;&gt;RDB&lt;/h1&gt;
&lt;p&gt;RDB是对 Redis 某一瞬间 保存的全量快照,本质上是一份二进制文件,用来在 Redis 重启或丢失数据后进行恢复,通常用作数据恢复、主从全量同步以及定期备份.&lt;/p&gt;
&lt;h2 id=&#34;执行方式&#34;&gt;执行方式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/redis/Pasted_image_20251017093754.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1手动&#34;&gt;1.手动&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;可以通过 `SAVE` 与 `BGSAVE` 手动执行 RDB 备份, `SAVE` 命令会在主线程内进行备份操作,此时Redis主线程会被堵塞直到写入 RDB 完成.
使用 `BGSAVE` 时 则是通过 `fork` 一个子线程进行写时复制写入硬盘,不会造成 Redis 主线程堵塞.
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Copy-On-Write（写时复制）&lt;/strong&gt; 是一种 &lt;strong&gt;优化内存使用和提升性能的系统级技术&lt;/strong&gt;，广泛用于操作系统（如 Linux）、数据库、虚拟化等领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多个进程/线程共享同一份物理内存，只有当某个进程试图“修改”数据时，才真正复制一份私有副本。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读操作&lt;/strong&gt;：直接共享原始数据，&lt;strong&gt;无需复制&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写操作&lt;/strong&gt;：触发复制，之后修改的是副本，不影响原数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;2-自动通过配置文件&#34;&gt;2. 自动(通过配置文件)&lt;/h3&gt;
&lt;p&gt;Redis 支持通过在 &lt;code&gt;redis.conf&lt;/code&gt; 文件中配置 &lt;code&gt;save&lt;/code&gt; 选项，让服务器每隔一段时间自动执行一次 &lt;code&gt;BGSAVE&lt;/code&gt; 命令。&lt;code&gt;save&lt;/code&gt; 选项可以设置多个保存条件，只要其中任意一个条件被满足，服务器就会执行 &lt;code&gt;BGSAVE&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;【示例】&lt;code&gt;redis.conf&lt;/code&gt; 中自动保存配置&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 900 秒内，至少对数据库进行了 1 次修改
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;save 900 1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 300 秒内，至少对数据库进行了 10 次修改
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;save 300 10
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 60 秒内，至少对数据库进行了 10000 次修改
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;save 60 10000
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;只要满足以上任意条件，Redis 服务就会执行 &lt;code&gt;BGSAVE&lt;/code&gt; 命令。&lt;/p&gt;
&lt;h2 id=&#34;rdb-优缺点&#34;&gt;RDB 优缺点&lt;/h2&gt;
&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;重启后加载快, 相比 AOF 命令执行式恢复, RDB本质就是压缩过的二进制文件,只需要将其全部读入内存即可.&lt;/li&gt;
&lt;li&gt;相比 AOF RDB空间利用率更高.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;备份频率较低,每次只能全量备份,如果在备份开始前发生故障,会导致丢失大量数据,无法满足强一致性.&lt;/li&gt;
&lt;li&gt;备份时间长,如果数据量很大，保存快照的时间会很长.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;aofappend-only-file&#34;&gt;AOF（Append Only File）&lt;/h1&gt;
&lt;p&gt;AOF 是 Redis 的另一种持久化机制，它通过&lt;strong&gt;记录服务器接收到的每一个写命令&lt;/strong&gt;，以日志形式追加到文件末尾。在 Redis 重启时，通过&lt;strong&gt;重新执行 AOF 文件中的命令&lt;/strong&gt;来恢复数据。AOF 文件是&lt;strong&gt;可读的文本格式&lt;/strong&gt;，通常用于对数据安全性要求较高的场景。&lt;/p&gt;
&lt;h2 id=&#34;执行方式-1&#34;&gt;执行方式&lt;/h2&gt;
&lt;h3 id=&#34;1-手动&#34;&gt;1. 手动&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;开启 AOF&lt;/strong&gt;：默认关闭，需在 &lt;code&gt;redis.conf&lt;/code&gt; 中设置 &lt;code&gt;appendonly yes&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重写 AOF&lt;/strong&gt;：执行 &lt;code&gt;BGREWRITEAOF&lt;/code&gt; 命令，Redis 会 fork 一个子进程，根据当前数据库状态生成一个&lt;strong&gt;更紧凑的新 AOF 文件&lt;/strong&gt;（利用 Copy-On-Write 机制，不阻塞主线程）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-自动通过配置文件-1&#34;&gt;2. 自动（通过配置文件）&lt;/h3&gt;
&lt;p&gt;AOF 的同步策略由 &lt;code&gt;appendfsync&lt;/code&gt; 配置项控制，决定写命令何时从缓冲区刷入磁盘：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 每次写操作都同步到磁盘（最安全，性能最差）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;appendfsync always
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 每秒同步一次（默认推荐，平衡安全与性能）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;appendfsync everysec
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 由操作系统决定何时同步（性能最好，但可能丢失较多数据）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;appendfsync no
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此外，AOF 重写也可自动触发，通过以下配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 当 AOF 文件大小超过上一次重写后大小的指定百分比时，自动触发重写
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto-aof-rewrite-percentage 100
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# AOF 文件至少达到指定大小（字节）才触发自动重写
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;auto-aof-rewrite-min-size 64mb
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;aof-优缺点&#34;&gt;AOF 优缺点&lt;/h2&gt;
&lt;h3 id=&#34;优点-1&#34;&gt;优点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据更安全&lt;/strong&gt;：&lt;code&gt;everysec&lt;/code&gt; 模式下最多丢失 1 秒数据，&lt;code&gt;always&lt;/code&gt; 模式可做到几乎零丢失。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可读可编辑&lt;/strong&gt;：AOF 是纯文本格式，若误操作（如误删 key），可手动修改文件删除对应命令后恢复。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动压缩&lt;/strong&gt;：通过重写机制，可将冗余命令（如多次 &lt;code&gt;INCR&lt;/code&gt;）合并为一条 &lt;code&gt;SET&lt;/code&gt;，减小文件体积。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缺点-1&#34;&gt;缺点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;文件体积大&lt;/strong&gt;：相比 RDB，AOF 通常更大（尽管重写可优化）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复速度慢&lt;/strong&gt;：需逐条重放命令，大数据集下恢复时间远长于 RDB。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能开销&lt;/strong&gt;：尤其在 &lt;code&gt;always&lt;/code&gt; 模式下，每次写操作都需同步磁盘，影响吞吐量。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Redis 数据结构</title>
      <link>https://asgpipo.github.io/posts/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 16 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/redis/redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/redis/Pasted_image_20251016093545.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;sds&#34;&gt;SDS&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/redis/Pasted_image_20251016093108.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;o1-获取长度&#34;&gt;&lt;code&gt;O(1)&lt;/code&gt; 获取长度&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SDS 在len属性保存了 SDS的长度所以无需遍历即可获得当前长度&lt;/li&gt;
&lt;li&gt;C 字符串不记录自身的长度信息， 为获取字符串的长度， 必须遍历整个字符串， 直到遇到代表字符串结尾的空字符为止， &lt;code&gt;O(N)&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;杜绝缓冲区溢出&#34;&gt;杜绝缓冲区溢出&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;SDS 通过 &lt;code&gt;len&lt;/code&gt; 记录长度 和 自动扩容机制在修改时保证了当前有足够的缓冲区.&lt;/li&gt;
&lt;li&gt;C 字符串 不检查空间 而且仅通过 &lt;code&gt;\0&lt;/code&gt; 判断结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;空间预分配--惰性空间&#34;&gt;空间预分配 &amp;amp; 惰性空间&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;空间预分配: 当需要进行空间扩容时 不仅会分配必要的空间 还会分配额外的空间.&lt;/li&gt;
&lt;li&gt;惰性空间: 当SDS 缩短保存字符串时 程序不立即重新分配缩短后的字节,而是用 &lt;code&gt;free&lt;/code&gt; 记录,等待之后使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;C 字符串&lt;/th&gt;
          &lt;th&gt;SDS（Simple Dynamic String）&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;获取字符串长度的时间复杂度&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;O(N)&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;必须遍历整个字符串直到遇到 &lt;code&gt;\0&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;O(1)&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;长度直接存储在 &lt;code&gt;len&lt;/code&gt; 字段中，API 自动维护&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;缓冲区溢出风险&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;高&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;操作函数（如 &lt;code&gt;strcat&lt;/code&gt;）不检查目标缓冲区大小，易越界写入&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;无&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;所有修改 API（如 &lt;code&gt;sdscat&lt;/code&gt;）先检查空间，自动扩容后再操作&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;内存重分配频率&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;每次修改都需重分配&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;增长需 &lt;code&gt;realloc&lt;/code&gt; 防溢出，缩减需 &lt;code&gt;realloc&lt;/code&gt; 防内存泄漏&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;大幅减少&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;通过 &lt;strong&gt;空间预分配&lt;/strong&gt;（增长时多分配）和 &lt;strong&gt;惰性空间释放&lt;/strong&gt;（缩短时不立即释放）优化，避免频繁 &lt;code&gt;malloc/realloc&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;二进制安全性&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;不安全&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;字符串中间不能含 &lt;code&gt;\0&lt;/code&gt;，否则被截断；仅适合文本&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;安全&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;可存储任意字节（包括 &lt;code&gt;\0&lt;/code&gt;），数据原样存取，支持图片、音频等二进制数据&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SDS 的结构（简化）&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sdshdr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 已使用字节数（字符串长度）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 未使用字节数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 实际字符存储区（以 \0 结尾，但内容可含 \0）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;链表&#34;&gt;链表&lt;/h1&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;实现为 &lt;strong&gt;双端无环链表&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;支持 &lt;strong&gt;多态&lt;/strong&gt;（通过 &lt;code&gt;dup&lt;/code&gt;/&lt;code&gt;free&lt;/code&gt;/&lt;code&gt;match&lt;/code&gt; 函数指针）。&lt;/li&gt;
&lt;li&gt;用于：List 键、客户端列表、慢查询、发布订阅等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listNode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;listNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h1 id=&#34;字典&#34;&gt;字典&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/redis/Pasted_image_20251016095023.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;底层结构&#34;&gt;底层结构&lt;/h2&gt;
&lt;p&gt;Redis 字典由 &lt;strong&gt;两个哈希表&lt;/strong&gt;（&lt;code&gt;ht[0]&lt;/code&gt; 和 &lt;code&gt;ht[1]&lt;/code&gt;）组成：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dictht&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ht&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// ht[0]: 主表；ht[1]: rehash 时的新表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rehashidx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// rehash 进度，-1 表示未进行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;每个哈希表（&lt;code&gt;dictht&lt;/code&gt;）是一个 &lt;strong&gt;数组 + 单向链表&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;数组元素为桶（bucket）；&lt;/li&gt;
&lt;li&gt;桶内冲突通过 &lt;strong&gt;链地址法&lt;/strong&gt;（单向链表）解决；&lt;/li&gt;
&lt;li&gt;节点类型为 &lt;code&gt;dictEntry&lt;/code&gt;，含 &lt;code&gt;key&lt;/code&gt;、&lt;code&gt;value&lt;/code&gt; 和 &lt;code&gt;next&lt;/code&gt; 指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;扩容与缩容机制&#34;&gt;扩容与缩容机制&lt;/h2&gt;
&lt;h3 id=&#34;1-触发条件基于负载因子&#34;&gt;1. 触发条件（基于负载因子）&lt;/h3&gt;
&lt;p&gt;负载因子 = &lt;code&gt;ht[0].used / ht[0].size&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;场景&lt;/th&gt;
          &lt;th&gt;触发 rehash 条件&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;无 BGSAVE / BGREWRITEAOF&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;负载因子 ≥ 1 → 扩容&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;有 BGSAVE / BGREWRITEAOF&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;负载因子 ≥ 5 → 才扩容（避免 fork 内存翻倍）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;缩容&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;负载因子 &amp;lt; 0.1 且表足够大&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;2-扩容过程渐进式-rehash&#34;&gt;&lt;strong&gt;2. 扩容过程（渐进式 rehash）&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分配 &lt;code&gt;ht[1]&lt;/code&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;扩容：&lt;code&gt;size = 第一个 ≥ ht[0].used * 2 的 2 的幂&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;缩容：&lt;code&gt;size = 第一个 ≥ ht[0].used 的 2 的幂&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置 &lt;code&gt;rehashidx = 0&lt;/code&gt;&lt;/strong&gt;，开始 rehash。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;每次字典操作（GET/SET/DEL）时&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺带迁移 &lt;code&gt;ht[0][rehashidx]&lt;/code&gt; 整个桶&lt;/strong&gt; 到 &lt;code&gt;ht[1]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rehashidx++&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新增操作只写入 &lt;code&gt;ht[1]&lt;/code&gt;&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查找/删除需查两个表&lt;/strong&gt;（因数据分散在两表中）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;迁移完成&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;释放 &lt;code&gt;ht[0]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ht[1] → ht[0]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rehashidx = -1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;三关键特点与代价&#34;&gt;三、关键特点与代价&lt;/h2&gt;
&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无阻塞&lt;/strong&gt;：rehash 分摊到每次操作，主线程不卡顿；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据安全&lt;/strong&gt;：双表共存期间，读写正确；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动适应&lt;/strong&gt;：根据负载动态扩缩容。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存占用翻倍&lt;/strong&gt;：rehash 期间 &lt;code&gt;ht[0]&lt;/code&gt; 和 &lt;code&gt;ht[1]&lt;/code&gt; 同时存在；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冷数据 rehash 延迟&lt;/strong&gt;：长期无访问的字典可能迟迟无法完成 rehash；
&lt;ul&gt;
&lt;li&gt;Redis 通过 &lt;code&gt;serverCron&lt;/code&gt; 定时任务主动推进缓解此问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;跳表&#34;&gt;跳表&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/redis/Pasted_image_20251016151401.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;底层结构-1&#34;&gt;底层结构&lt;/h2&gt;
&lt;p&gt;跳表本质上就是多层级链表,不同层级保存着随机跨度的后驱节点的指针,用来快速查找.&lt;/p&gt;
&lt;p&gt;节点:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//Zset 对象的元素值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;sds&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ele&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;//元素权重值,用于排序
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;score&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;//后向指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;backward&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;//节点的level数组，保存每层上的前向指针和跨度
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistLevel&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;forward&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;c1&#34;&gt;//跨度
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;span&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;顶层结构:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplistNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;header&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 头尾指针（O(1) 访问）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                 &lt;span class=&#34;c1&#34;&gt;// 节点总数（O(1) 获取长度）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;                            &lt;span class=&#34;c1&#34;&gt;// 当前跳表最大层数（不含头节点）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zskiplist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;header&lt;/code&gt; 是一个 &lt;strong&gt;特殊的头节点&lt;/strong&gt;，不存实际数据（&lt;code&gt;ele = NULL&lt;/code&gt;, &lt;code&gt;score = 0&lt;/code&gt;），但有完整的 &lt;code&gt;level[]&lt;/code&gt; 数组（如 32 层或 64 层）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tail&lt;/code&gt; 指向最后一个&lt;strong&gt;真实数据节点&lt;/strong&gt;（用于 &lt;code&gt;ZREVRANGE&lt;/code&gt; 等反向操作）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;level&lt;/code&gt; 是 &lt;strong&gt;所有数据节点中的最大层数&lt;/strong&gt;（头节点层数不计入）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建过程&#34;&gt;创建过程&lt;/h2&gt;
&lt;p&gt;Redis在创建头节点时如果层高最大限制是 32，那么在创建跳表「头节点」的时候，就会直接创建 32 层高的头节点.
在创建新节点时会在 &lt;code&gt;[0, 1]&lt;/code&gt; 随机取值,如果小于 0.25 则会增加层高,继续取值,直到值大于 0.25.&lt;/p&gt;
&lt;h2 id=&#34;redis为什么使用跳表而不是用b树&#34;&gt;Redis为什么使用跳表而不是用B+树?&lt;/h2&gt;
&lt;p&gt;Redis 是内存数据库，&lt;strong&gt;跳表在实现简单性、写入性能、内存访问模式等方面的综合优势&lt;/strong&gt;，使其成为更合适的选择。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;维度&lt;/td&gt;
          &lt;td&gt;跳表优势&lt;/td&gt;
          &lt;td&gt;B+ 树劣势&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;内存访问&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;符合CPU缓存局部性，指针跳转更高效&lt;/td&gt;
          &lt;td&gt;节点结构复杂，缓存不友好&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;实现复杂度&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;代码简洁，无复杂平衡操作&lt;/td&gt;
          &lt;td&gt;节点分裂/合并逻辑复杂，代码量大&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;写入性能&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;插入/删除仅需调整局部指针&lt;/td&gt;
          &lt;td&gt;插入可能触发递归节点分裂，成本高&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;内存占用&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;结构紧凑，无内部碎片&lt;/td&gt;
          &lt;td&gt;节点预分配可能浪费内存&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Redis 选择使用跳表（Skip List）而不是 B+ 树来实现有序集合（Sorted Set）等数据结构，是经过多方面权衡后的结果。以下是详细的原因分析：&lt;/p&gt;
&lt;p&gt;1、内存结构与访问模式的差异&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B+ 树的特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;磁盘友好&lt;/strong&gt;：B+ 树的设计目标是优化磁盘I/O，通过减少树的高度来降低磁盘寻道次数（例如，一个3层的B+树可以管理数百万数据）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;节点填充率高&lt;/strong&gt;：每个节点存储多个键值（Page/Block），适合批量读写。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;范围查询高效&lt;/strong&gt;：叶子节点形成有序链表，范围查询（如 &lt;code&gt;ZRANGE&lt;/code&gt;）性能极佳。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;跳表的特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存友好&lt;/strong&gt;：跳表基于链表，通过多级索引加速查询，&lt;strong&gt;内存访问模式更符合CPU缓存局部性&lt;/strong&gt;（指针跳跃更少）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;简单灵活&lt;/strong&gt;：插入/删除时仅需调整局部指针，无需复杂的节点分裂与合并。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;概率平衡&lt;/strong&gt;：通过随机层高实现近似平衡，避免了严格的平衡约束（如红黑树的旋转）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Redis 是内存数据库&lt;/strong&gt;，数据完全存储在内存中，不需要优化磁盘I/O，因此 B+ 树的磁盘友好特性对 Redis 意义不大。而跳表的内存访问模式更优，更适合高频的内存操作。&lt;/p&gt;
&lt;p&gt;2、实现复杂度的对比&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B+ 树的实现复杂度&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点分裂与合并&lt;/strong&gt;：插入/删除时可能触发节点分裂或合并，需要复杂的再平衡逻辑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;锁竞争&lt;/strong&gt;：在并发环境下，B+ 树的锁粒度较粗（如页锁），容易成为性能瓶颈。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码复杂度&lt;/strong&gt;：B+ 树的实现需要处理大量边界条件（如最小填充因子、兄弟节点借用等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;跳表的实现复杂度&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无再平衡操作&lt;/strong&gt;：插入时只需随机生成层高，删除时直接移除节点并调整指针。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;细粒度锁或无锁&lt;/strong&gt;：跳表可以通过分段锁或无锁结构（如 CAS）实现高效并发。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码简洁&lt;/strong&gt;：Redis 的跳表核心代码仅需约 200 行（B+ 树实现通常需要数千行）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对于 Redis 这种追求高性能和代码简洁性的项目&lt;/strong&gt;，跳表的低实现复杂度更具吸引力，Redis作者Antirez曾表示，跳表的实现复杂度远低于平衡树，且性能相近，是更优选择。&lt;/p&gt;
&lt;p&gt;3、性能对比&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询性能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单点查询&lt;/strong&gt;：跳表和 B+ 树的时间复杂度均为 &lt;code&gt;O(log N)&lt;/code&gt;，但跳表的实际常数更小（内存中指针跳转比磁盘块访问快得多）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;范围查询&lt;/strong&gt;：B+ 树的叶子链表在范围查询时占优，但跳表通过双向链表也能高效支持 &lt;code&gt;ZRANGE&lt;/code&gt; 操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;写入性能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;B+ 树&lt;/strong&gt;：插入可能触发节点分裂，涉及父节点递归更新，成本较高。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跳表&lt;/strong&gt;：插入仅需修改相邻节点的指针，写入性能更优（Redis 的 &lt;code&gt;ZADD&lt;/code&gt; 操作时间复杂度为 &lt;code&gt;O(log N)&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实测数据&lt;/strong&gt;：在内存中，跳表的插入速度比 B+ 树快 2-3 倍，查询速度相当。&lt;/p&gt;
&lt;p&gt;4、内存占用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;B+ 树&lt;/strong&gt;：每个节点需要存储多个键值和子节点指针，存在内部碎片（节点未填满时）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跳表&lt;/strong&gt;：每个节点只需存储键值、层高和多个前向指针，内存占用更紧凑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;压缩列表是怎么实现的&#34;&gt;压缩列表是怎么实现的？&lt;/h1&gt;
&lt;p&gt;压缩列表是 Redis 为了节约内存而开发的，它是&lt;strong&gt;由连续内存块组成的顺序型数据结构&lt;/strong&gt;，有点类似于数组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/redis/ziplist1.webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;压缩列表在表头有三个字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;zlbytes&lt;/strong&gt;&lt;/em&gt;，记录整个压缩列表占用对内存字节数；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;zltail&lt;/strong&gt;&lt;/em&gt;，记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;zllen&lt;/strong&gt;&lt;/em&gt;，记录压缩列表包含的节点数量；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;zlend&lt;/strong&gt;&lt;/em&gt;，标记压缩列表的结束点，固定值 0xFF（十进制255）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在压缩列表中，如果我们要查找定位首尾元素通过表头三个字段（zllen）的长度直接定位，复杂度是 O(1)。&lt;strong&gt;查找其他元素时，只能逐个查找O(N) ，因此压缩列表不适合保存过多的元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外，压缩列表节点（entry）的构成如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/redis/ziplistinner.webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;压缩列表节点包含三部分内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;prevlen&lt;/strong&gt;，记录了「前一个节点」的长度，目的是为了实现从后向前遍历；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;encoding&lt;/strong&gt;，记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data&lt;/strong&gt;，记录了当前节点的实际数据，类型和长度都由 encoding 决定；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;往压缩列表中插入数据时，压缩列表就会根据数据类型是字符串还是整数，以及数据的大小，会使用不同空间大小的 prevlen 和 encoding 这两个元素里保存的信息，&lt;strong&gt;这种根据数据大小和类型进行不同的空间大小分配的设计思想，正是 Redis 为了节省内存而采用的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;压缩列表的缺点是会发生连锁更新的问题，因此&lt;strong&gt;连锁更新一旦发生，就会导致压缩列表占用的内存空间要多次重新分配，这就会直接影响到压缩列表的访问性能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以说，&lt;strong&gt;虽然压缩列表紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，会导致内存重新分配，最糟糕的是会有「连锁更新」的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;压缩列表只会用于保存的节点数量不多的场景&lt;/strong&gt;，只要节点数量足够小，即使发生连锁更新，也是能接受的。&lt;/p&gt;
&lt;p&gt;虽说如此，Redis 针对压缩列表在设计上的不足，在后来的版本中，新增设计了两种数据结构：quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）。这两种数据结构的设计目标，就是尽可能地保持压缩列表节省内存的优势，同时解决压缩列表的「连锁更新」的问题。&lt;/p&gt;
&lt;p&gt;listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。&lt;/p&gt;
&lt;p&gt;我们先看看 listpack 结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/redis/listpack1.webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。&lt;/p&gt;
&lt;p&gt;每个 listpack 节点结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/redis/listpack.webp&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;主要包含三个方面内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；&lt;/li&gt;
&lt;li&gt;data，实际存放的数据；&lt;/li&gt;
&lt;li&gt;len，encoding+data的总长度；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，&lt;strong&gt;listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题&lt;/strong&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JMM</title>
      <link>https://asgpipo.github.io/posts/java/concurrency/jmm/</link>
      <pubDate>Mon, 13 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/java/concurrency/jmm/</guid>
      <description>&lt;h1 id=&#34;jmm&#34;&gt;JMM&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是-jmm&#34;&gt;&lt;strong&gt;1. 什么是 JMM？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Java 内存模型（JMM）是一个&lt;strong&gt;抽象模型&lt;/strong&gt;，它定义了线程和主内存之间的抽象关系。JMM 的核心目的是&lt;strong&gt;屏蔽各种硬件和操作系统的内存访问差异&lt;/strong&gt;，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果，为开发者提供清晰的并发编程保证。
&lt;img src=&#34;https://asgpipo.github.io/pics/Java/JMM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-jmm-的核心抽象&#34;&gt;&lt;strong&gt;2. JMM 的核心抽象&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;JMM 通过以下概念来抽象内存交互：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主内存&lt;/strong&gt;：所有线程共享的区域，存储了所有的实例字段、静态字段和构成数组对象的元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地内存&lt;/strong&gt;：每个线程私有的区域，是 JMM 的一个抽象概念。它存储了该线程对主内存变量的副本。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通信原则&lt;/strong&gt;：线程间的通信必须通过主内存进行。一个线程将本地内存的变量副本写入主内存，另一个线程再从主内存读取到最新的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/JMMAbstract.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-jmm-诞生的原因&#34;&gt;&lt;strong&gt;3. JMM 诞生的原因&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;JMM 的出现主要是为了解决现代计算机体系结构带来的两个核心问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU 缓存导致的可见性问题&lt;/strong&gt;：为了提高速度，每个 CPU 都有自己的高速缓存。当多个线程运行在不同 CPU 上时，它们可能各自持有一个共享变量的缓存副本，导致一个线程的修改对另一个线程不可见。尽管硬件层面有缓存一致性协议（如 MESI）来协调，但 JMM 提供了更高层、更强的可见性保证。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指令重排导致的有序性问题&lt;/strong&gt;：为了优化性能，编译器和处理器可能会对输入的代码进行指令重排序。在单线程环境下，重排序不会影响最终结果，但在多线程环境下，可能会破坏代码原有的执行逻辑，导致意想不到的结果。
&lt;img src=&#34;https://asgpipo.github.io/pics/Java/HowJMMBrith.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-jmm-的核心工具happens-before-原则&#34;&gt;&lt;strong&gt;4. JMM 的核心工具：Happens-Before 原则&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;happens-before&lt;/code&gt; 是 JMM 中最核心的概念，它定义了两个操作之间的偏序关系。如果操作 A &lt;code&gt;happens-before&lt;/code&gt; 操作 B，那么 A 操作的执行结果对 B 操作是可见的，且 A 操作的执行顺序在 B 操作之前。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：&lt;code&gt;happens-before&lt;/code&gt; 原则主要用于保证并发环境下的&lt;strong&gt;可见性&lt;/strong&gt;和&lt;strong&gt;有序性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;程序顺序规则&lt;/strong&gt;：在一个线程内，书写在前面的代码操作 &lt;code&gt;happens-before&lt;/code&gt; 书写在后面的代码操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监视器锁规则&lt;/strong&gt;：对一个锁的解锁操作 &lt;code&gt;happens-before&lt;/code&gt; 后续对同一个锁的加锁操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;volatile 变量规则&lt;/strong&gt;：对一个 &lt;code&gt;volatile&lt;/code&gt; 变量的写操作 &lt;code&gt;happens-before&lt;/code&gt; 后续对该变量的读操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传递性&lt;/strong&gt;：如果 A &lt;code&gt;happens-before&lt;/code&gt; B，且 B &lt;code&gt;happens-before&lt;/code&gt; C，那么 A &lt;code&gt;happens-before&lt;/code&gt; C。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程启动规则&lt;/strong&gt;：线程的 &lt;code&gt;start()&lt;/code&gt; 方法 &lt;code&gt;happens-before&lt;/code&gt; 于此线程的每一个动作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程终止规则&lt;/strong&gt;：线程中的所有操作都 &lt;code&gt;happens-before&lt;/code&gt; 对此线程的终止检测。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程中断规则&lt;/strong&gt;：对线程 &lt;code&gt;interrupt()&lt;/code&gt; 方法的调用 &lt;code&gt;happens-before&lt;/code&gt; 发生于被中断线程的代码检测到中断时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象终结规则&lt;/strong&gt;：一个对象的初始化完成（构造函数执行结束）&lt;code&gt;happens-before&lt;/code&gt; 它的 &lt;code&gt;finalize()&lt;/code&gt; 方法的开始。
&lt;img src=&#34;https://asgpipo.github.io/pics/Java/HappensBefore.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结&#34;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;JMM 通过抽象出主内存和本地内存，并提供一套 &lt;code&gt;happens-before&lt;/code&gt; 规则，成功地为 Java 开发者屏蔽了底层硬件的复杂性。理解 JMM 有助于我们编写出正确、可靠的并发程序，避免可见性和有序性带来的问题。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>volatile &amp; synchronized</title>
      <link>https://asgpipo.github.io/posts/java/concurrency/volatile--synchronized/</link>
      <pubDate>Mon, 13 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/java/concurrency/volatile--synchronized/</guid>
      <description>&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 关键字是 Java 并发编程中的一个基础且至关重要的概念。它就像是 Java 虚拟机 ([[JVM]]) 和底层硬件之间立下的一份“契约”，专门用于解决多线程环境下&lt;strong&gt;共享变量的可见性（Visibility）和有序性（Ordering）问题&lt;/strong&gt;。
&lt;img src=&#34;https://asgpipo.github.io/pics/Java/VolatileMindMap.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一-volatile-的含义及在-java-中的作用&#34;&gt;一、 &lt;code&gt;volatile&lt;/code&gt; 的含义及在 Java 中的作用&lt;/h2&gt;
&lt;h3 id=&#34;1-单词的意思literal-meaning&#34;&gt;1. 单词的意思（Literal Meaning）&lt;/h3&gt;
&lt;p&gt;在 Java 中，&lt;code&gt;volatile&lt;/code&gt; 关键字用来标记一个 Java 变量是 &amp;ldquo;&lt;strong&gt;存储在主内存中&lt;/strong&gt;&amp;quot;（&amp;ldquo;being stored in main memory&amp;rdquo;）的。它指示 JVM，这个变量是&lt;strong&gt;共享且不稳定的&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;2-它在-java-中干什么核心机制&#34;&gt;2. 它在 Java 中干什么（核心机制）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 的核心作用是&lt;strong&gt;强制读写操作直接与主内存进行交互&lt;/strong&gt;，从而解决了由于 CPU 缓存和指令重排序带来的并发问题。&lt;/p&gt;
&lt;h4 id=&#34;a-解决可见性问题强制内存访问&#34;&gt;A. 解决可见性问题（强制内存访问）&lt;/h4&gt;
&lt;p&gt;由于现代 CPU 为了性能，会将变量副本存储在 CPU 寄存器或缓存中。如果变量未被声明为 &lt;code&gt;volatile&lt;/code&gt;，线程在操作共享变量时，对主内存的读写时间是不确定的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读取操作：&lt;/strong&gt; 对 &lt;code&gt;volatile&lt;/code&gt; 变量的每一次读取都将直接从计算机的&lt;strong&gt;主内存&lt;/strong&gt;中读取，而不是从 CPU 寄存器中读取。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写入操作：&lt;/strong&gt; 对 &lt;code&gt;volatile&lt;/code&gt; 变量的每一次写入都将立即被&lt;strong&gt;写入到主内存&lt;/strong&gt;中，而不仅仅是写入到 CPU 寄存器或写缓冲区中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这种方式，&lt;code&gt;volatile&lt;/code&gt; 确保了当一个线程更新变量值时，处理器会立即&lt;strong&gt;刷新&lt;/strong&gt;这些更新，保证其他线程随后读取时能看到这个最新值。&lt;/p&gt;
&lt;h4 id=&#34;b-解决有序性问题禁止指令重排序&#34;&gt;B. 解决有序性问题（禁止指令重排序）&lt;/h4&gt;
&lt;p&gt;编译器、运行时环境或处理器可能会对指令进行重排序以优化性能。&lt;code&gt;volatile&lt;/code&gt; 变量是与运行时和处理器进行通信，以&lt;strong&gt;避免重排序任何涉及该 &lt;code&gt;volatile&lt;/code&gt; 变量的指令&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它通过插入&lt;strong&gt;内存屏障 (Memory Barrier)&lt;/strong&gt; 来实现这一目标。内存屏障就像一道墙，禁止某些类型的处理器重排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-volatile-保证了什么核心承诺&#34;&gt;二、 &lt;code&gt;volatile&lt;/code&gt; 保证了什么？（核心承诺）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 关键字提供了 Java 内存模型 ([[Java/Concurrency/JMM|JMM]]) 规定的两大核心保证：&lt;/p&gt;
&lt;h3 id=&#34;1-内存可见性visibility-guarantee&#34;&gt;1. 内存可见性（Visibility Guarantee）&lt;/h3&gt;
&lt;p&gt;这是 &lt;code&gt;volatile&lt;/code&gt; 最主要也是最基础的保证。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一致性保证：&lt;/strong&gt; &lt;code&gt;volatile&lt;/code&gt; 保证了所有线程看到的共享变量的值是&lt;strong&gt;一致的&lt;/strong&gt;。当对 &lt;code&gt;volatile&lt;/code&gt; 字段进行更新后，&lt;strong&gt;该字段的共享值会立即更新&lt;/strong&gt;，其他线程不会获取到不一致的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;完整可见性保证（Full Volatile Visibility Guarantee）：&lt;/strong&gt; &lt;code&gt;volatile&lt;/code&gt; 的可见性保证甚至延伸到了变量本身之外。
&lt;ul&gt;
&lt;li&gt;如果线程 A 写入一个 &lt;code&gt;volatile&lt;/code&gt; 变量，随后线程 B 读取了它，那么&lt;strong&gt;在 A 写入该 &lt;code&gt;volatile&lt;/code&gt; 变量之前对所有其他变量所做的更改，对 B 来说都是可见的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;类似地，当线程 A 读取 &lt;code&gt;volatile&lt;/code&gt; 变量时，所有对线程 A 可见的变量都会&lt;strong&gt;被强制重新从主内存读取&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-有序性与-happens-before-关系&#34;&gt;2. 有序性与 Happens-Before 关系&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 关键字提供了 Java 内存模型中的 &lt;strong&gt;Happens-Before 保证&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Volatile 变量规则：&lt;/strong&gt; 对一个 &lt;code&gt;volatile&lt;/code&gt; 变量的&lt;strong&gt;写操作 Happens-Before 后面对这个 &lt;code&gt;volatile&lt;/code&gt; 变量的读操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重排序约束：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写入屏障：&lt;/strong&gt; 发生在 &lt;code&gt;volatile&lt;/code&gt; 变量写入&lt;strong&gt;之前&lt;/strong&gt;对其他变量的读写，&lt;strong&gt;不能&lt;/strong&gt;被重排到 &lt;code&gt;volatile&lt;/code&gt; 写入&lt;strong&gt;之后&lt;/strong&gt;发生。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读取屏障：&lt;/strong&gt; 发生在 &lt;code&gt;volatile&lt;/code&gt; 变量读取&lt;strong&gt;之后&lt;/strong&gt;对其他变量的读写，&lt;strong&gt;不能&lt;/strong&gt;被重排到 &lt;code&gt;volatile&lt;/code&gt; 读取&lt;strong&gt;之前&lt;/strong&gt;发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-对-64-位值操作的原子性保障&#34;&gt;3. 对 64 位值操作的原子性保障&lt;/h3&gt;
&lt;p&gt;[[Java/Concurrency/JMM|JMM]] 对 64 位值（如 &lt;code&gt;long&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt;）的访问原子性有所放宽，因为在某些 32 位平台上，读写 64 位值可能需要两次内存事务，导致操作非原子。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; 作为一种&lt;strong&gt;逃生出口（escape hatch）&lt;/strong&gt;，可以用来&lt;strong&gt;强制确保 64 位值的访问原子性&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果代码可能在 32 位平台上运行，开发者必须使用 &lt;code&gt;volatile&lt;/code&gt; 关键字来保障 64 位操作的可移植性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-什么时候使用-volatile适用场景&#34;&gt;三、 什么时候使用 &lt;code&gt;volatile&lt;/code&gt;？（适用场景）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 是一个&lt;strong&gt;轻量级的同步机制&lt;/strong&gt;，适用于只需要保证可见性和有序性，但不需要互斥的场景。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;单写多读场景 (State Flag)&lt;/strong&gt;：当&lt;strong&gt;只有一个线程&lt;/strong&gt;会修改（写入）变量的值，而其他所有线程只负责读取该变量时，&lt;code&gt;volatile&lt;/code&gt; 是足够的。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 状态标志：只有一个线程会把它设为 true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isRunning&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;shutdown&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isRunning&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 单写操作&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;doWork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;isRunning&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 多读操作&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ... 执行任务&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Server has been shut down.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;值不依赖于旧值：&lt;/strong&gt; 即使有多个线程写入 &lt;code&gt;volatile&lt;/code&gt; 变量，只要写入的新值&lt;strong&gt;不依赖于其旧值&lt;/strong&gt;（例如，设置一个布尔状态标记，而不是计数器递增），&lt;code&gt;volatile&lt;/code&gt; 也是足够的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替代重量级锁：&lt;/strong&gt; 当应用程序需要确保数据的可见性方面，但同时又希望避免 &lt;code&gt;synchronized&lt;/code&gt; 方法和块带来的性能开销时，&lt;code&gt;volatile&lt;/code&gt; 很有用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;ldquo;搭便车&amp;quot;技巧 (Piggybacking)&lt;/strong&gt;：利用 &lt;code&gt;volatile&lt;/code&gt; 带来的 happens-before 顺序性，将普通变量的写入放在 &lt;code&gt;volatile&lt;/code&gt; 变量写入之前，可以使普通变量的可见性“搭上” &lt;code&gt;volatile&lt;/code&gt; 变量的便车。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;四-什么时候不使用-volatile局限性与替代方案&#34;&gt;四、 什么时候不使用 &lt;code&gt;volatile&lt;/code&gt;？（局限性与替代方案）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 具有明显的局限性，在需要复杂同步时，不应单独依赖它。&lt;/p&gt;
&lt;h3 id=&#34;1-不能保证互斥性mutual-exclusion&#34;&gt;1. 不能保证互斥性（Mutual Exclusion）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; 字段的读写&lt;strong&gt;不会阻塞&lt;/strong&gt;其他线程的读写操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; 关键字&lt;strong&gt;不提供互斥（mutual exclusion）&lt;/strong&gt;，即它不能保证在任何时刻只有一个线程执行关键代码段。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-无法保障复合操作的原子性&#34;&gt;2. 无法保障复合操作的原子性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一旦线程需要&lt;strong&gt;先读取 &lt;code&gt;volatile&lt;/code&gt; 变量的值，然后根据该值生成一个新的值&lt;/strong&gt;（即复合操作，如 &lt;code&gt;i++&lt;/code&gt; 或 &lt;code&gt;count = count + 1&lt;/code&gt;），&lt;strong&gt;单独的 &lt;code&gt;volatile&lt;/code&gt; 就不够了&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在读取和写入新值之间的短暂时间差内，会产生&lt;strong&gt;竞态条件（race condition）&lt;/strong&gt;，多个线程可能读取到相同的值，导致相互覆盖，最终结果错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替代方案：&lt;/strong&gt; 在这种需要&lt;strong&gt;原子性&lt;/strong&gt;（读取和写入是一个不可分割操作）的情况下，必须使用：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;synchronized&lt;/code&gt; 块或方法&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;java.util.concurrent&lt;/code&gt; 包中的各种&lt;strong&gt;原子数据类型&lt;/strong&gt;，如 &lt;code&gt;AtomicLong&lt;/code&gt; 或 &lt;code&gt;AtomicReference&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-性能考量&#34;&gt;3. 性能考量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;访问 &lt;code&gt;volatile&lt;/code&gt; 变量会将其读写到主内存，这比访问 CPU 寄存器&lt;strong&gt;更昂贵&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volatile&lt;/code&gt; 还会阻止指令重排序，而指令重排序是&lt;strong&gt;常见的性能增强技术&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;因此，应该&lt;strong&gt;只在真正需要强制变量可见性时&lt;/strong&gt;才使用 &lt;code&gt;volatile&lt;/code&gt; 变量，以避免不必要的同步开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;UnsafeCounter&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 即使使用了 volatile，也无法保证正确性&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;increment&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 这不是原子操作！它包含三步：&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 1. 读取 count 的值&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 2. 将值加 1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;                 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 3. 写入新值&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;特性&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;code&gt;volatile&lt;/code&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;code&gt;synchronized&lt;/code&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;code&gt;AtomicInteger&lt;/code&gt; (原子类)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证可见性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证有序性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (禁止重排序)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证原子性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt; (仅限单次读/写)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (代码块)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (特定操作)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;互斥/阻塞&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt; (非阻塞)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (阻塞)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt; (非阻塞，CAS)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;性能开销&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较低&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较高&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较低 (通常优于 &lt;code&gt;volatile&lt;/code&gt;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;状态标志、单写多读&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;复杂同步逻辑、临界区保护&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;计数器、累加等复合操作&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 关键字是 Java 并发编程的基石，它提供了一种强大而直接的同步机制。它就像是为一间“共享资源室”配备的“唯一钥匙”&lt;strong&gt;，专门用于解决多线程环境下的&lt;/strong&gt;原子性、可见性和有序性&lt;strong&gt;问题，其核心是&lt;/strong&gt;互斥访问。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一-synchronized-的含义及在-java-中的作用&#34;&gt;一、 &lt;code&gt;synchronized&lt;/code&gt; 的含义及在 Java 中的作用&lt;/h2&gt;
&lt;h3 id=&#34;1-意思&#34;&gt;1. 意思&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 的字面意思是“同步的”。在 Java 中，它用于确保一段代码或一个方法在同一时刻&lt;strong&gt;最多只有一个线程&lt;/strong&gt;能执行它。&lt;/p&gt;
&lt;h3 id=&#34;2-它在-java-中干什么核心机制-1&#34;&gt;2. 它在 Java 中干什么（核心机制）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 的核心作用是实现&lt;strong&gt;线程间的互斥&lt;/strong&gt;，它通过一个叫做&lt;strong&gt;监视器锁&lt;/strong&gt; 的东西来实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;监视器锁&lt;/strong&gt;：每个 Java 对象都可以作为一个锁，这个锁就是对象的内置锁或监视器锁。当线程试图进入一个被 &lt;code&gt;synchronized&lt;/code&gt; 保护的代码块时，它必须先获取该代码块所关联对象的锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;锁的获取与释放&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;获取锁&lt;/strong&gt;：如果锁未被其他线程持有，当前线程会获取锁并进入代码块执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞等待&lt;/strong&gt;：如果锁已被其他线程持有，当前线程将被&lt;strong&gt;阻塞&lt;/strong&gt;，并进入锁的等待队列，直到锁被释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;释放锁&lt;/strong&gt;：当线程执行完 &lt;code&gt;synchronized&lt;/code&gt; 代码块或方法，或者在代码块中抛出异常时，锁会自动被释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二-synchronized-保证了什么核心承诺&#34;&gt;二、 &lt;code&gt;synchronized&lt;/code&gt; 保证了什么？（核心承诺）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 关键字提供了三大核心保证，比 &lt;code&gt;volatile&lt;/code&gt; 更为强大。&lt;/p&gt;
&lt;h3 id=&#34;1-原子性&#34;&gt;1. 原子性&lt;/h3&gt;
&lt;p&gt;这是 &lt;code&gt;synchronized&lt;/code&gt; 最核心的保证。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;互斥执行&lt;/strong&gt;：&lt;code&gt;synchronized&lt;/code&gt; 确保被它保护的代码块（临界区）是&lt;strong&gt;原子的&lt;/strong&gt;。一个线程一旦进入该代码块，在它退出之前，其他任何线程都无法进入。这从根本上杜绝了竞态条件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类比&lt;/strong&gt;：就像一个只有一把钥匙的洗手间。一个人进去后锁上门（获取锁），在里面无论待多久，外面的人都只能排队等待（阻塞）。直到他出来并交出钥匙（释放锁），下一个人才能进去。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-内存可见性&#34;&gt;2. 内存可见性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 保证可见性，&lt;code&gt;synchronized&lt;/code&gt; 同样保证，而且更强。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Happens-Before 保证&lt;/strong&gt;：[[Java/Concurrency/JMM|JMM]] 规定，对一个锁的&lt;strong&gt;解锁操作 [[Java/Concurrency/JMM#^444be5|Happens-Before]] 后面对同一个锁的加锁操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强制刷新&lt;/strong&gt;：这意味着，当线程 A 释放锁时，[[Java/Concurrency/JMM|JMM]] 会强制将该线程工作内存中的所有共享变量的最新值&lt;strong&gt;刷新到主内存&lt;/strong&gt;。而当线程 B 随后获取同一个锁时，[[Java/Concurrency/JMM|JMM]] 会强制将该线程的工作内存置为无效，使其必须&lt;strong&gt;从主内存中重新读取&lt;/strong&gt;所有共享变量的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效果&lt;/strong&gt;：这确保了前一个线程对共享变量的修改，对后一个获取锁的线程是立即可见的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-有序性&#34;&gt;3. 有序性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt; 通过内存屏障禁止指令重排，&lt;code&gt;synchronized&lt;/code&gt; 通过其“原子性”隐式地保证了有序性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;隐式保证&lt;/strong&gt;：由于 &lt;code&gt;synchronized&lt;/code&gt; 块内的代码与块外的代码是互斥执行的，一个线程在 &lt;code&gt;synchronized&lt;/code&gt; 块内观察到的状态，一定是另一个线程在之前或之后同步块内操作的结果。[[Java/Concurrency/JMM|JMM]] 可以在保证最终结果正确性的前提下，对 &lt;code&gt;synchronized&lt;/code&gt; 块内的代码进行重排序，但它绝不会允许块内的代码“[[Runtime Data Area#Escape|逃逸]]”到块外，从而破坏整体的同步语义。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-可重入性&#34;&gt;4. 可重入性&lt;/h3&gt;
&lt;p&gt;这是 &lt;code&gt;synchronized&lt;/code&gt; 一个非常重要的特性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：一个已经获取到锁的线程，可以&lt;strong&gt;再次进入&lt;/strong&gt;由它自己持有的锁所保护的任何代码块，而不会造成死锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;机制&lt;/strong&gt;：JVM 会为每个锁关联一个持有计数器和一个持有线程。当一个线程获取锁时，计数器加一。当同一线程再次获取时，计数器再次加一。当线程退出同步块时，计数器减一。直到计数器为 0 时，锁才被真正释放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;意义&lt;/strong&gt;：可重入性极大地简化了代码编写，避免了因在同步方法中调用另一个同步方法而导致的自我死锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三-什么时候使用-synchronized适用场景&#34;&gt;三、 什么时候使用 &lt;code&gt;synchronized&lt;/code&gt;？（适用场景）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 是一个重量级的同步工具，适用于需要强一致性保证的场景。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;保护临界区&lt;/strong&gt;：当多个线程需要访问和修改&lt;strong&gt;共享资源&lt;/strong&gt;（如共享的数据结构、文件、设备等）时，必须使用 &lt;code&gt;synchronized&lt;/code&gt; 来保护访问这些资源的代码块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保证复合操作的原子性&lt;/strong&gt;：对于像 &lt;code&gt;check-then-act&lt;/code&gt;（检查再操作，如单例模式的懒加载）或 &lt;code&gt;read-modify-write&lt;/code&gt;（读取再修改，如 &lt;code&gt;i++&lt;/code&gt;）这样的复合操作，&lt;code&gt;volatile&lt;/code&gt; 无能为力，&lt;code&gt;synchronized&lt;/code&gt; 是最直接的解决方案。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现简单的线程安全类&lt;/strong&gt;：在创建自定义的线程安全容器或工具类时，&lt;code&gt;synchronized&lt;/code&gt; 是最基础、最可靠的实现手段。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;三种使用方式&#34;&gt;&lt;strong&gt;三种使用方式&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MySynchronizedClass&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 1. 修饰实例方法，锁是当前实例对象 (this)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;instanceMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 临界区代码&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Instance method. Lock on: &amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 2. 修饰静态方法，锁是当前类的 Class 对象 (MySynchronizedClass.class)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;staticMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 临界区代码&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Static method. Lock on: &amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MySynchronizedClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lockObject&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 专用锁对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;blockMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 3. 修饰代码块，锁是指定的对象 (lockObject)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lockObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 临界区代码&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Code block. Lock on: &amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lockObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;四-什么时候不使用-synchronized局限性与替代方案&#34;&gt;四、 什么时候不使用 &lt;code&gt;synchronized&lt;/code&gt;？（局限性与替代方案）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 虽然强大，但其“重量级”的特性也带来了局限。&lt;/p&gt;
&lt;h3 id=&#34;1-性能开销&#34;&gt;1. 性能开销&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;线程阻塞与上下文切换&lt;/strong&gt;：当锁竞争激烈时，无法获取锁的线程会被阻塞，涉及从用户态到内核态的切换，这是一个&lt;strong&gt;非常昂贵的操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能瓶颈&lt;/strong&gt;：在高并发场景下，&lt;code&gt;synchronized&lt;/code&gt; 容易成为系统的性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-灵活性不足&#34;&gt;2. 灵活性不足&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不可中断&lt;/strong&gt;：一个线程在等待获取 &lt;code&gt;synchronized&lt;/code&gt; 锁时，不能被中断。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无法设置超时&lt;/strong&gt;：无法设置一个线程等待锁的最长时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非公平锁&lt;/strong&gt;：&lt;code&gt;synchronized&lt;/code&gt; 是非公平的，即等待时间长的线程不一定能优先获取锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-替代方案&#34;&gt;3. 替代方案&lt;/h3&gt;
&lt;p&gt;为了克服 &lt;code&gt;synchronized&lt;/code&gt; 的局限性，Java 提供了更灵活、更高效的并发工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;volatile&lt;/code&gt;&lt;/strong&gt;：当只需要保证可见性和有序性，而不需要互斥访问时，&lt;code&gt;volatile&lt;/code&gt; 是更轻量级的选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 包&lt;/strong&gt;：对于单个变量的原子性复合操作（如计数器），&lt;code&gt;AtomicInteger&lt;/code&gt; 等原子类基于 CAS（Compare-And-Swap）操作，通常比 &lt;code&gt;synchronized&lt;/code&gt; 性能更好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt; 接口&lt;/strong&gt;：提供了更高级的锁功能，如可中断的锁获取（&lt;code&gt;lockInterruptibly()&lt;/code&gt;）、可超时的锁获取（&lt;code&gt;tryLock()&lt;/code&gt;）和公平锁（&lt;code&gt;ReentrantLock&lt;/code&gt; 的构造函数参数）。它为复杂并发场景提供了更精细的控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;核心要点总结一图流&#34;&gt;&lt;strong&gt;核心要点总结（一图流）&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;特性&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;code&gt;synchronized&lt;/code&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;code&gt;java.util.concurrent.locks.Lock&lt;/code&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证原子性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证可见性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;保证有序性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;互斥/阻塞&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (阻塞)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (阻塞)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可重入&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (如 &lt;code&gt;ReentrantLock&lt;/code&gt;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可中断&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (&lt;code&gt;lockInterruptibly()&lt;/code&gt;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;可超时&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (&lt;code&gt;tryLock()&lt;/code&gt;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;公平性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;❌ &lt;strong&gt;否&lt;/strong&gt; (仅非公平)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;✅ &lt;strong&gt;是&lt;/strong&gt; (可选公平/非公平)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;使用方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;关键字 (JVM 实现，自动释放)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;接口 (API 调用，需手动 &lt;code&gt;unlock()&lt;/code&gt;)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;性能开销&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较高 (JDK 6 后大幅优化)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;通常较低，但依赖具体实现&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>乐观锁 &amp; 悲观锁</title>
      <link>https://asgpipo.github.io/posts/java/concurrency/%E4%B9%90%E8%A7%82%E9%94%81--%E6%82%B2%E8%A7%82%E9%94%81/</link>
      <pubDate>Sun, 12 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://asgpipo.github.io/posts/java/concurrency/%E4%B9%90%E8%A7%82%E9%94%81--%E6%82%B2%E8%A7%82%E9%94%81/</guid>
      <description>&lt;h1 id=&#34;悲观锁&#34;&gt;悲观锁&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/PessimisticLock.png&#34; alt=&#34;&#34;&gt;
悲观锁的核心思想是&lt;strong&gt;在共享资源被操作时假设冲突一定会发生&lt;/strong&gt;全部都加锁.&lt;/p&gt;
&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;synchronized&lt;/strong&gt; : Java 中的关键字，可以修饰方法或代码块，保证同一时刻只有一个线程可以执行被修饰的代码。&lt;/li&gt;
&lt;li&gt;ReentrantLock: Java &lt;code&gt;java.util.concurrent.locks&lt;/code&gt; 包下的一个类，提供了比 &lt;code&gt;synchronized&lt;/code&gt; 更广泛的锁操作。例如，它可以实现公平锁、非公平锁，可以被中断地获取锁等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缺点&#34;&gt;缺点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;多个线程在持有锁并请求对方已持有的锁时，会造成相互等待，导致所有线程都无法继续执行。&lt;/li&gt;
&lt;li&gt;当一个线程获取锁失败后，会被阻塞（挂起），操作系统需要将其从运行态切换到等待态。当锁被释放时，又需要将等待的线程唤醒，这个线程上下文的切换会消耗一定的 CPU 资源。&lt;/li&gt;
&lt;li&gt;只要有一个线程持有了锁，其他所有想要访问该资源的线程都必须等待，这会降低系统的并发性能和吞吐量。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;适用场景&#34;&gt;适用场景&lt;/h2&gt;
&lt;p&gt;适合写多读少的情况,因为读操作并不对资源进行修改不会出现线程问题,而写操作要求强数值一致性所以适合悲观锁.&lt;/p&gt;
&lt;h1 id=&#34;乐观锁&#34;&gt;乐观锁&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;pics/Java/OptimisticLock.png&#34; alt=&#34;&#34;&gt;
它总是假设最好的情况，认为数据在被自己操作时不会被其他线程修改。所以它不会加锁，&lt;strong&gt;而是在更新数据时，去检查&lt;/strong&gt;在此期间有没有其他线程修改过数据。&lt;/p&gt;
&lt;h2 id=&#34;实现方式-1&#34;&gt;实现方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;concurrent.atomic&lt;/code&gt;&lt;/strong&gt;: Java 的 &lt;code&gt;java.util.concurrent.atomic&lt;/code&gt; 包下的一系列原子类，如 &lt;code&gt;AtomicInteger&lt;/code&gt;, &lt;code&gt;AtomicLong&lt;/code&gt; 等。它们内部使用了 CAS 机制来实现原子操作。&lt;/p&gt;
&lt;h2 id=&#34;机制&#34;&gt;机制&lt;/h2&gt;
&lt;h3 id=&#34;版本控制&#34;&gt;版本控制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://asgpipo.github.io/pics/Java/VersionControl.png&#34; alt=&#34;&#34;&gt;
在数据库中加入版本属性,当线程操作时需要携带当前操作数据的版本号,操作完成后比较此时版本与数据库中版本是否相同.&lt;/p&gt;
&lt;h3 id=&#34;cascompare-and-swap&#34;&gt;CAS(&lt;strong&gt;Compare And Swap&lt;/strong&gt;)&lt;/h3&gt;
&lt;p&gt;CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原子操作&lt;/strong&gt; 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;CAS 涉及到三个操作数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;V&lt;/strong&gt;：要更新的变量值(Var)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E&lt;/strong&gt;：预期值(Expected)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;N&lt;/strong&gt;：拟写入的新值(New)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。&lt;/p&gt;
&lt;h1 id=&#34;来源&#34;&gt;来源&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://javaguide.cn/java/concurrent/optimistic-lock-and-pessimistic-lock.html&#34;&gt;Javaguide# 乐观锁和悲观锁详解&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
