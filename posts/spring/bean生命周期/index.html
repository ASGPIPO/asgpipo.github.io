<!DOCTYPE html>
<html lang="en" style="font-size: 105%">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  <meta name="author" content="">

  
  
  <meta name="description" content="Bean 的生命流程简述

Instantitaion
populate
Initialization
使用
结束销毁

Instantiation
什么是 Instatiation？ 他和 populate 有什么区别？
Spring 的 Bean 创建是控制反转（IoC）的核心体现。容器根据 BeanDefinition 中的元数据（如类名、作用域、构造参数、工厂方法、初始化/销毁方法等），通过 Java 反射机制来实例化 Bean 对象。 这个阶段只是‘创建空壳对象’，尚未进行依赖注入。
后续 Spring 会基于同样的 BeanDefinition 完成 属性填充（即依赖注入）和初始化，最终将一个完整可用的 Bean 交还给应用。
通过这种方式，对象的创建和依赖管理不再由程序员手动控制（比如 new），而是交给了 Spring 容器，实现了控制反转。">
  

  
  <link rel="apple-touch-icon" sizes="180x180" href="https://asgpipo.github.io//images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://asgpipo.github.io//images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://asgpipo.github.io//images/favicon-16x16.png">

  
  
  <meta name="keywords" content='hugo latex theme blog texify texify2 texify3 michael neuper'>
  

  
  
  <link rel="stylesheet" href='/katex/katex.min.css'>
<script defer defer src='/katex/katex.min.js'></script>
<script defer src='/katex/contrib/auto-render.min.js'></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError : false
        });
    });
</script>
  

  
  

  
  <meta property="og:url" content="https://asgpipo.github.io/posts/spring/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">
  <meta property="og:site_name" content="pipo&#39;s site">
  <meta property="og:title" content="Spring Bean生命周期">
  <meta property="og:description" content="Bean 的生命流程简述 Instantitaion populate Initialization 使用 结束销毁 Instantiation 什么是 Instatiation？ 他和 populate 有什么区别？ Spring 的 Bean 创建是控制反转（IoC）的核心体现。容器根据 BeanDefinition 中的元数据（如类名、作用域、构造参数、工厂方法、初始化/销毁方法等），通过 Java 反射机制来实例化 Bean 对象。 这个阶段只是‘创建空壳对象’，尚未进行依赖注入。 后续 Spring 会基于同样的 BeanDefinition 完成 属性填充（即依赖注入）和初始化，最终将一个完整可用的 Bean 交还给应用。 通过这种方式，对象的创建和依赖管理不再由程序员手动控制（比如 new），而是交给了 Spring 容器，实现了控制反转。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-11-25T20:22:35+08:00">
    <meta property="article:modified_time" content="2025-11-25T20:22:35+08:00">
    <meta property="article:tag" content="Bean">
    <meta property="article:tag" content="Spring">


  
  <link rel="canonical" href="https://asgpipo.github.io/posts/spring/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

  
  
  
  <meta itemprop="name" content="Spring Bean生命周期">
  <meta itemprop="description" content="Bean 的生命流程简述 Instantitaion populate Initialization 使用 结束销毁 Instantiation 什么是 Instatiation？ 他和 populate 有什么区别？ Spring 的 Bean 创建是控制反转（IoC）的核心体现。容器根据 BeanDefinition 中的元数据（如类名、作用域、构造参数、工厂方法、初始化/销毁方法等），通过 Java 反射机制来实例化 Bean 对象。 这个阶段只是‘创建空壳对象’，尚未进行依赖注入。 后续 Spring 会基于同样的 BeanDefinition 完成 属性填充（即依赖注入）和初始化，最终将一个完整可用的 Bean 交还给应用。 通过这种方式，对象的创建和依赖管理不再由程序员手动控制（比如 new），而是交给了 Spring 容器，实现了控制反转。">
  <meta itemprop="datePublished" content="2025-11-25T20:22:35+08:00">
  <meta itemprop="dateModified" content="2025-11-25T20:22:35+08:00">
  <meta itemprop="wordCount" content="1335">
  <meta itemprop="keywords" content="Bean,Spring">

  
  
  
    <link rel="stylesheet" href="/css/common.min.e562d763c6d0825495eb17de8b2c1d9800cf7c08db1c36accedf77a5fccfc4b9.css" integrity="sha256-5WLXY8bQglSV6xfeiywdmADPfAjbHDaszt93pfzPxLk=" crossorigin="anonymous">
  

  
  
    <link rel="stylesheet" href="/css/content.min.f51fb43fa8f51b0642996f60541954a19ce736770f5baa9e690f79c9d1fa6421.css" integrity="sha256-9R&#43;0P6j1GwZCmW9gVBlUoZznNncPW6qeaQ95ydH6ZCE=" crossorigin="anonymous">
  

  
  
  <title>Spring Bean生命周期 - pipo&#39;s site</title>
  

  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Spring Bean生命周期">
  <meta name="twitter:description" content="Bean 的生命流程简述 Instantitaion populate Initialization 使用 结束销毁 Instantiation 什么是 Instatiation？ 他和 populate 有什么区别？ Spring 的 Bean 创建是控制反转（IoC）的核心体现。容器根据 BeanDefinition 中的元数据（如类名、作用域、构造参数、工厂方法、初始化/销毁方法等），通过 Java 反射机制来实例化 Bean 对象。 这个阶段只是‘创建空壳对象’，尚未进行依赖注入。 后续 Spring 会基于同样的 BeanDefinition 完成 属性填充（即依赖注入）和初始化，最终将一个完整可用的 Bean 交还给应用。 通过这种方式，对象的创建和依赖管理不再由程序员手动控制（比如 new），而是交给了 Spring 容器，实现了控制反转。">


  


  <link rel="stylesheet" href="/css/single.min.3a3345f1d6f04a7a511a9c33d043ebb4ca4d7e5c3ae16c2b41f44a71138579db.css" integrity="sha256-OjNF8dbwSnpRGpwz0EPrtMpNflw64WwrQfRKcROFeds=" crossorigin="anonymous">


  <link rel="stylesheet" href="/css/single.min.78a121b7d7a160420f9daab0ea13add66c37b9c44f27bba07b27207e2b0975d2.css" integrity="sha256-eKEht9ehYEIPnaqw6hOt1mw3ucRPJ7ugeycgfisJddI=" crossorigin="anonymous">


</head>

<body>
  <div id="wrapper">
    


<header id="header">
  <h1>
    <a href="https://asgpipo.github.io/">blog collcetions</a>
    <button id="dark-mode-toggle" class="dark-mode-toggle" aria-label="Toggle theme">
        <svg width="2rem" height="2rem" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 496">
        <path fill="currentColor" d="M8,256C8,393,119,504,256,504S504,393,504,256,393,8,256,8,8,119,8,256ZM256,440V72a184,184,0,0,1,0,368Z" transform="translate(-8 -8)"/>
        </svg>
    </button>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      
        <span class="icon"><svg width="1em" height="1em" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M17,11H16a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2Zm0,4H16a1,1,0,0,0,0,2h1a1,1,0,0,0,0-2ZM11,9h6a1,1,0,0,0,0-2H11a1,1,0,0,0,0,2ZM21,3H7A1,1,0,0,0,6,4V7H3A1,1,0,0,0,2,8V18a3,3,0,0,0,3,3H18a4,4,0,0,0,4-4V4A1,1,0,0,0,21,3ZM6,18a1,1,0,0,1-2,0V9H6Zm14-1a2,2,0,0,1-2,2H7.82A3,3,0,0,0,8,18V5H20Zm-9-4h1a1,1,0,0,0,0-2H11a1,1,0,0,0,0,2Zm0,4h1a1,1,0,0,0,0-2H11a1,1,0,0,0,0,2Z"/></svg>
</span>
      
      <a class="link" href="/posts/">Blog</a>
    </span>
    
    <span class="nav-bar-item">
      
        <span class="icon"><svg width="1em" height="1em" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
<path d="M2.88,16.88a3,3,0,0,0,0,4.24,3,3,0,0,0,4.24,0,3,3,0,0,0-4.24-4.24Zm2.83,2.83a1,1,0,0,1-1.42-1.42,1,1,0,0,1,1.42,0A1,1,0,0,1,5.71,19.71ZM5,12a1,1,0,0,0,0,2,5,5,0,0,1,5,5,1,1,0,0,0,2,0,7,7,0,0,0-7-7ZM5,8a1,1,0,0,0,0,2,9,9,0,0,1,9,9,1,1,0,0,0,2,0,11.08,11.08,0,0,0-3.22-7.78A11.08,11.08,0,0,0,5,8Zm10.61.39A15.11,15.11,0,0,0,5,4,1,1,0,0,0,5,6,13,13,0,0,1,18,19a1,1,0,0,0,2,0A15.11,15.11,0,0,0,15.61,8.39Z"/></svg>
</span>
      
      <a class="link" href="/index.xml">RSS</a>
    </span>
    
    <span class="nav-bar-item">
      
        <span class="icon"><svg width="1em" height="1em" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" data-name="Layer 1">
<path d="M10.07031,20.50291a1.00008,1.00008,0,0,0-1.18115-.9834c-1.30908.24024-2.96191.27637-3.40137-.958a5.70754,5.70754,0,0,0-1.83691-2.415,1.20073,1.20073,0,0,1-.1665-.10938,1,1,0,0,0-.93067-.64551H2.54883a.99965.99965,0,0,0-1,.99512c-.00391.81543.811,1.33789,1.1416,1.51465a4.4408,4.4408,0,0,1,.92383,1.35937c.36426,1.02344,1.42285,2.57617,4.46582,2.376.001.03516.00195.06836.00244.09863l.00439.26758a1,1,0,0,0,2,0l-.00488-.31836C10.07715,21.4951,10.07031,21.22068,10.07031,20.50291Zm10.667-15.126c.03174-.125.063-.26367.09034-.41992a6.27792,6.27792,0,0,0-.40821-3.293,1.002,1.002,0,0,0-.61572-.58007c-.356-.12012-1.67041-.35645-4.18408,1.25a13.86918,13.86918,0,0,0-6.354,0C6.76221.751,5.45459.9658,5.10205,1.07908a.99744.99744,0,0,0-.63135.584,6.3003,6.3003,0,0,0-.40332,3.35644c.02442.12793.05078.2461.07813.35449A6.26928,6.26928,0,0,0,2.89014,9.20311a8.42168,8.42168,0,0,0,.04248.92187c.334,4.60254,3.334,5.98438,5.42431,6.459-.04345.125-.083.25878-.11816.40039a1.00023,1.00023,0,0,0,1.94238.47851,1.6784,1.6784,0,0,1,.46778-.87793.99947.99947,0,0,0-.5459-1.74512c-3.4541-.39453-4.95362-1.80175-5.1792-4.89843a6.61076,6.61076,0,0,1-.03369-.73828,4.25769,4.25769,0,0,1,.91943-2.71289,3.022,3.022,0,0,1,.1958-.23145.99988.99988,0,0,0,.188-1.02441,3.3876,3.3876,0,0,1-.15527-.55567A4.09356,4.09356,0,0,1,6.1167,3.06346a7.54263,7.54263,0,0,1,2.415,1.17968,1.00877,1.00877,0,0,0,.82764.13282,11.77716,11.77716,0,0,1,6.17285.001,1.00549,1.00549,0,0,0,.83056-.13769,7.572,7.572,0,0,1,2.40528-1.19043,4.03977,4.03977,0,0,1,.0874,1.57812,3.205,3.205,0,0,1-.16895.60743.9999.9999,0,0,0,.188,1.02441c.07715.08691.1543.18066.22363.26855A4.12186,4.12186,0,0,1,20,9.20311a7.03888,7.03888,0,0,1-.0376.77734c-.22021,3.05566-1.72558,4.46387-5.1958,4.85937a1,1,0,0,0-.54541,1.7461,1.63079,1.63079,0,0,1,.46631.9082,3.06079,3.06079,0,0,1,.09229.81934v2.334C14.77,21.2949,14.77,21.78025,14.77,22.00291a1,1,0,1,0,2,0c0-.2168,0-.69238.00977-1.33984V18.31346a4.8815,4.8815,0,0,0-.15479-1.31153,4.25638,4.25638,0,0,0-.11621-.416,6.51258,6.51258,0,0,0,5.44531-6.42383A8.69677,8.69677,0,0,0,22,9.20311,6.13062,6.13062,0,0,0,20.7373,5.37693Z"/></svg>
</span>
      
      <a class="link" href="https://github.com/ASGPIPO">GitHub</a>
    </span>
    
  </nav>
</header>
<hr class="head-rule"></hr>
    


  
    
      
    
  

<main id="main" class="post">
  
  <div class="post-heading">
    <h1 class="post-title">Spring Bean生命周期</h1>
    <div class="publish-metadata">
      
      <svg width="0.75em" height="0.75em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M3 9H21M7 3V5M17 3V5M6 13H8M6 17H8M11 13H13M11 17H13M16 13H18M16 17H18M6.2 21H17.8C18.9201 21 19.4802 21 19.908 20.782C20.2843 20.5903 20.5903 20.2843 20.782 19.908C21 19.4802 21 18.9201 21 17.8V8.2C21 7.07989 21 6.51984 20.782 6.09202C20.5903 5.71569 20.2843 5.40973 19.908 5.21799C19.4802 5 18.9201 5 17.8 5H6.2C5.0799 5 4.51984 5 4.09202 5.21799C3.71569 5.40973 3.40973 5.71569 3.21799 6.09202C3 6.51984 3 7.07989 3 8.2V17.8C3 18.9201 3 19.4802 3.21799 19.908C3.40973 20.2843 3.71569 20.5903 4.09202 20.782C4.51984 21 5.07989 21 6.2 21Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
      25 November 2025
      
      
        &nbsp;
        <span>
          <svg width="0.75em" height="0.75em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M15.4998 5.49994L18.3282 8.32837M3 20.9997L3.04745 20.6675C3.21536 19.4922 3.29932 18.9045 3.49029 18.3558C3.65975 17.8689 3.89124 17.4059 4.17906 16.9783C4.50341 16.4963 4.92319 16.0765 5.76274 15.237L17.4107 3.58896C18.1918 2.80791 19.4581 2.80791 20.2392 3.58896C21.0202 4.37001 21.0202 5.63634 20.2392 6.41739L8.37744 18.2791C7.61579 19.0408 7.23497 19.4216 6.8012 19.7244C6.41618 19.9932 6.00093 20.2159 5.56398 20.3879C5.07171 20.5817 4.54375 20.6882 3.48793 20.9012L3 20.9997Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          1335 words
        </span>
      
      
      
        
      
      
        &nbsp;
        <span>
          <svg width="0.75em" height="0.75em" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 7V12L14.5 13.5M21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3C16.9706 3 21 7.02944 21 12Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          ~3 mins
        </span>
      
    </div>
  </div>

  
  <div>
    
    <a class="link tag" href='https://asgpipo.github.io/tags/bean'>#Bean</a>
    
    <a class="link tag" href='https://asgpipo.github.io/tags/spring'>#Spring</a>
    
    <br></br>
  </div>
  
  
  
    
  
  
  <article class="content numbered-subtitles">
    
    <h2 id="bean-的生命流程简述">Bean 的生命流程简述</h2>
<ol>
<li>Instantitaion</li>
<li>populate</li>
<li>Initialization</li>
<li>使用</li>
<li>结束销毁</li>
</ol>
<h2 id="instantiation">Instantiation</h2>
<h3 id="什么是-instatiation-他和-populate-有什么区别">什么是 Instatiation？ 他和 populate 有什么区别？</h3>
<p>Spring 的 Bean 创建是控制反转（IoC）的核心体现。容器根据 <strong>BeanDefinition 中的元数据</strong>（如类名、作用域、构造参数、工厂方法、初始化/销毁方法等），通过 <strong>Java 反射机制来实例化 Bean 对象</strong>。 这个阶段只是‘<strong>创建空壳对象’，尚未进行依赖注入</strong>。
后续 Spring 会基于同样的 BeanDefinition 完成 <strong>属性填充（即依赖注入）和初始化</strong>，最终将一个完整可用的 Bean 交还给应用。
通过这种方式，对象的创建和依赖管理不再由程序员手动控制（比如 new），而是交给了 Spring 容器，实现了控制反转。</p>
<h3 id="三种创建对象的方法">三种创建对象的方法</h3>
<ol>
<li>Supplier</li>
<li>工厂方法</li>
<li>构造函数</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">protected</span><span class="w"> </span><span class="n">BeanWrapper</span><span class="w"> </span><span class="nf">createBeanInstance</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">RootBeanDefinition</span><span class="w"> </span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="nd">@Nullable</span><span class="w"> </span><span class="n">Object</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="c1">//检查获取 BeanDefinition</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">Class</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">beanClass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">resolveBeanClass</span><span class="p">(</span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="c1">//首先检查是否提供了 Supplier，如果有就直接返回创建对象</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">Supplier</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">instanceSupplier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mbd</span><span class="p">.</span><span class="na">getInstanceSupplier</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instanceSupplier</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">obtainFromSupplier</span><span class="p">(</span><span class="n">instanceSupplier</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="c1">//检查是否有工厂方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mbd</span><span class="p">.</span><span class="na">getFactoryMethodName</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">instantiateUsingFactoryMethod</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   
</span></span></span><span class="line"><span class="cl"><span class="w">   
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="c1">//执行后置处理器, 获取候选构造方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="n">Constructor</span><span class="o">&lt;?&gt;[]</span><span class="w"> </span><span class="n">ctors</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">determineConstructorsFromBeanPostProcessors</span><span class="p">(</span><span class="n">beanClass</span><span class="p">,</span><span class="w"> </span><span class="n">beanName</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ctors</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">mbd</span><span class="p">.</span><span class="na">getResolvedAutowireMode</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">AUTOWIRE_CONSTRUCTOR</span><span class="w"> </span><span class="o">||</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="n">mbd</span><span class="p">.</span><span class="na">hasConstructorArgumentValues</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">ObjectUtils</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">(</span><span class="n">args</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">autowireConstructor</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">,</span><span class="w"> </span><span class="n">ctors</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">instantiateBean</span><span class="p">(</span><span class="n">beanName</span><span class="p">,</span><span class="w"> </span><span class="n">mbd</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="populate">populate</h2>
<h3 id="populate-在做什么">populate 在做什么？</h3>
<p>popluate 流程主要是将属性注入到上一步创建好的“空壳对象”，核心是对对象中有 [[@Autowired]] 和 @Resource 的字段 Setter 函数等注入属性，完成这一步后会进行 Initialization 进行 AOP 代理、回调 Aware 接口、回调初始化方法。</p>
<h3 id="属性填充的核心流程"><strong class=chinese>属性填充的核心流程</strong></h3>
<ol>
<li><strong>读取 BeanDefinition</strong><br>
Spring 查看这个 Bean 的 <code>PropertyValues</code>（属性值元数据）</li>
<li><strong class=chinese>解析依赖来源</strong>
<ul>
<li>如果依赖来源于其他 Bean，那么递归先去创建该 Bean（如果成环这里就可能诞生 [[依赖循环]]依赖循环的问题）</li>
<li>如果来源于配置文件，则从 <code>Environment</code> 中读取</li>
</ul>
</li>
<li>通过反射赋值
<ul>
<li>[[Spring/@AutoWired.md|@AutoWired ]]注入（构造器注入已经在 Instantiation 阶段完成）</li>
<li>@Resource 注入</li>
</ul>
</li>
</ol>
<h3 id="initalization">Initalization</h3>
<p>Aware
BeanPostProcessor
invokeInitMethods()
BeanPostFactory.postProcessAfterInitialization()</p>
<table>
  <thead>
      <tr>
          <th>步骤</th>
          <th>名称</th>
          <th>作用</th>
          <th>代码体现</th>
          <th>具体效果</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>4</strong></td>
          <td><code>BeanPostProcessor</code> 前置处理</td>
          <td>在初始化方法执行前，允许你对 Bean 做预处理</td>
          <td><code>postProcessBeforeInitialization</code></td>
          <td>打印日志，告诉开发者“Bean 即将初始化”，可用于权限检查、日志埋点等。</td>
      </tr>
      <tr>
          <td><strong>5</strong></td>
          <td>是否实现 <code>InitializingBean</code></td>
          <td>Spring 提供的标准初始化回调接口</td>
          <td><code>afterPropertiesSet()</code></td>
          <td>在这里做数据校验（如用户名不能为空），确保 Bean 状态合法。</td>
      </tr>
      <tr>
          <td><strong>6</strong></td>
          <td>是否配置自定义 <code>init-method</code></td>
          <td>用户自定义的初始化方法</td>
          <td><code>myInitMethod()</code></td>
          <td>在这里做业务初始化（如加载缓存、连接数据库），非常灵活。</td>
      </tr>
      <tr>
          <td><strong>7</strong></td>
          <td><code>BeanPostProcessor</code> 后置处理</td>
          <td>在所有初始化完成后，对 Bean 进行最终处理或包装</td>
          <td><code>postProcessAfterInitialization</code></td>
          <td><strong class=chinese>关键效果</strong>：返回一个代理对象！这使得你可以无侵入地给 Bean 添加功能（如事务、日志、安全检查），这就是 <strong>AOP</strong> 的基础。</td>
      </tr>
  </tbody>
</table>
<hr>
<p>! [[../pics/SpringBean.png]]</p>
<hr>
<h2 id="destruction">Destruction</h2>
<p>当容器关闭时会调用</p>
<ul>
<li>DisposableBean.destroy()</li>
<li>destory-method()
与初始化阶段的 <code>InitializingBean.afterPropertiesSet()</code> 和 <code>init_method</code> 对称</li>
</ul>
<h2 id="总结destruction-的核心要点">总结：Destruction 的核心要点</h2>
<table>
  <thead>
      <tr>
          <th>要点</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong class=chinese>两个钩子</strong></td>
          <td><code>DisposableBean.destroy()</code> + <code>destroy-method</code></td>
      </tr>
      <tr>
          <td><strong class=chinese>执行顺序</strong></td>
          <td><code>@PreDestroy</code> → <code>destroy()</code> → <code>destroy-method</code></td>
      </tr>
      <tr>
          <td><strong class=chinese>触发条件</strong></td>
          <td><strong>必须调用 <code>context.close()</code></strong></td>
      </tr>
      <tr>
          <td><strong class=chinese>为什么重要</strong></td>
          <td>防止 <strong class=chinese>资源泄漏</strong>（数据库连接、线程池、文件句柄等）</td>
      </tr>
      <tr>
          <td><strong class=chinese>最佳实践</strong></td>
          <td>用 <code>@PreDestroy</code> 注解方法，清晰且解耦</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="reference">Reference</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">title: &#34;聊透Spring bean的生命周期一步一图带你理解Spring bean的生命周期，清楚Spring的IOC、DI、A - 掘金&#34;
</span></span><span class="line"><span class="cl">image: &#34;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1960950d22104a639e09de10d2bff105~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?&#34;
</span></span><span class="line"><span class="cl">description: &#34;一步一图带你理解Spring bean的生命周期，清楚Spring的IOC、DI、AOP是怎么完成的，并教你如何借助Bean的生命周期，拓展你的应用&#34;
</span></span><span class="line"><span class="cl">url: &#34;https://juejin.cn/post/7155884227714613285&#34;
</span></span><span class="line"><span class="cl">favicon: &#34;&#34;
</span></span><span class="line"><span class="cl">aspectRatio: &#34;24.867724867724867&#34;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">title: &#34;聊透Spring依赖注入依赖自动注入；依赖注入模型；[[@AutoWired]]和@Resource依赖注入的解析、超找、注入流 - 掘金&#34;
</span></span><span class="line"><span class="cl">image: &#34;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f2a1a92368a44c8bfb343fc864a7a52~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?&#34;
</span></span><span class="line"><span class="cl">description: &#34;依赖自动注入；依赖注入模型；@AutoWired和@Resource依赖注入的解析、超找、注入流程分析；@Qualifier实现名称查找的原理分析&#34;
</span></span><span class="line"><span class="cl">url: &#34;https://juejin.cn/post/7143419261657022472&#34;
</span></span><span class="line"><span class="cl">favicon: &#34;&#34;
</span></span><span class="line"><span class="cl">aspectRatio: &#34;42.28310502283105&#34;
</span></span></code></pre></div>
    
  </article>

  <button onclick="topFunction()" id="back-to-top" title="Go to top">Back to Top</button>

  

<div id="sharingbuttons">
    
    

    
    

    
    

    
    

    
    

    
    

    
    

    
    
</div>
  <div class="paginator">
    
    <a class="link" href="https://asgpipo.github.io/posts/spring/ioc%E4%B8%8Edi/" title="IoC控制反转与DI依赖注入">← prev</a>
    
    
    <a class="link" href="https://asgpipo.github.io/posts/spring/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/" title="Spring循环依赖解决">next →</a>
    
  </div>
  <div class="comment">
    
    
    
      <script src="https://giscus.app/client.js"
        data-repo="michaelneuper/website"
        data-repo-id="R_kgDOIjPNaQ"
        data-category="General"
        data-category-id="DIC_kwDOIjPNac4CaklA"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="gruvbox"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
  </script>
  
  </div>
  
  

<aside class="toc-sidebar" data-toc-sidebar>
  <h4 data-toc-toggle>Table of Contents</h4>
  <nav><nav id="TableOfContents">
  <ul>
    <li><a href="#bean-的生命流程简述">Bean 的生命流程简述</a></li>
    <li><a href="#instantiation">Instantiation</a>
      <ul>
        <li><a href="#什么是-instatiation-他和-populate-有什么区别">什么是 Instatiation？ 他和 populate 有什么区别？</a></li>
        <li><a href="#三种创建对象的方法">三种创建对象的方法</a></li>
      </ul>
    </li>
    <li><a href="#populate">populate</a>
      <ul>
        <li><a href="#populate-在做什么">populate 在做什么？</a></li>
        <li><a href="#属性填充的核心流程"><strong>属性填充的核心流程</strong></a></li>
        <li><a href="#initalization">Initalization</a></li>
      </ul>
    </li>
    <li><a href="#destruction">Destruction</a></li>
    <li><a href="#总结destruction-的核心要点">总结：Destruction 的核心要点</a></li>
    <li><a href="#reference">Reference</a></li>
  </ul>
</nav></nav>
</aside>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    const toc = document.querySelector('nav#TableOfContents');
    const links = toc ? toc.querySelectorAll('a') : [];
    const sections = new Array(links.length);
    
    if (!toc || links.length === 0) return;

    
    links.forEach((link, index) => {
      const href = link.getAttribute('href');
      
      const id = decodeURIComponent(href.substring(1)); 
      const section = document.getElementById(id);
      sections[index] = section;

      
      link.addEventListener('click', (e) => {
        e.preventDefault();
        if (section) {
          section.scrollIntoView({ behavior: 'smooth' });
          history.pushState(null, null, href);
        }
      });
    });

    
    const observerOptions = {
      root: null,
      
      
      threshold: 0
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const id = entry.target.getAttribute('id');
          
          
          links.forEach(link => {
             link.classList.remove('active');
             if(link.parentElement.classList.contains('active')){
                link.parentElement.classList.remove('active');
             }
          });

          
          
          const activeLink = toc.querySelector(`a[href="#${encodeURIComponent(id)}"]`) || 
                             toc.querySelector(`a[href="#${id}"]`); 
          
          if (activeLink) {
            activeLink.classList.add('active');
            
            activeLink.parentElement.classList.add('active');
          }
        }
      });
    }, observerOptions);

    
    sections.forEach(section => {
      if (section) observer.observe(section);
    });

    
    const toggleBtn = document.querySelector('[data-toc-toggle]');
    const sidebar = document.querySelector('[data-toc-sidebar]');
    
    if (toggleBtn && sidebar) {
      toggleBtn.addEventListener('click', () => {
        
        sidebar.classList.toggle('open');
      });
    }

    window.addEventListener('scroll', function() {
      
      if (window.innerWidth <= 1350 && sidebar.classList.contains('open')) {
        sidebar.classList.remove('open');
      }
    });
  });
</script>


  
</main>


    <footer id="footer">
  <div>
    <span>Powered by  <a class=link href=https://gohugo.io target=_blank rel=noopener>Hugo</a> | 
Theme <a class=link href=https://github.com/michaelneuper/hugo-texify3 target=_blank rel=noopener>TeXify3</a>
</span>
  </div>
  <div>
    <span>Copyright © 2026 </span>
  </div>
</footer>

  </div>

  
  <script src='https://asgpipo.github.io/js/script.js' defer></script>

  
  
  <link media="screen" rel="stylesheet" href="https://asgpipo.github.io/css/syntax.css" />
  
  <link media="screen" rel="stylesheet" href="https://asgpipo.github.io/css/scale.css" />
  

  
  

  
  

</body>

</html>
